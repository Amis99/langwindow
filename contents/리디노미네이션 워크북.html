<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리디노미네이션 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">리디노미네이션</div>
                <div class="subtitle">2022 수능완성 지문 학습</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 0;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage0: null,
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                // 1문단 질문들
                {
                    id: 1,
                    text: "이 문단은 '리디노미네이션'이라는 핵심 개념의 _____을 설명하며 글을 시작하고 있네.",
                    highlight: "리디노미네이션(redenomination)은 명사 디노미네이션 앞에 '다시'를 뜻하는 접두사 're-'를 붙여 만든 단어이다.",
                    options: ["정의", "사례"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "가장 중요한 조건은 돈의 '실질 가치'는 _____ 숫자, 즉 '액면가'만 바꾼다는 점이구나.",
                    highlight: "실질 가치는 그대로 둔 채 액면을 특정 비율을 적용하여 낮은 숫자로 변경",
                    options: ["그대로 두면서", "바꾸면서"],
                    correct: 0
                },
                {
                    id: 3,
                    text: "다음 문단에서는 리디노미네이션의 _____에 대해 본격적으로 이야기할 가능성이 높겠지?",
                    highlight: "화폐의 자릿수를 줄여 기업 등에서의 장부 기재상 불편을 줄일 수 있다.",
                    options: ["구체적인 장점이나 단점", "역사적 배경"],
                    correct: 0
                },
                {
                    id: 4,
                    text: "개념을 정의하는 부분은 항상 _____ 문제의 단골 출제 포인트야.",
                    highlight: "이미 쓰이고 있는 화폐의 액면가를 다시 설정하는 일",
                    options: ["내용 일치", "비판적 사고"],
                    correct: 0
                },
                // 2문단 질문들
                {
                    id: 5,
                    text: "이 문단은 우리나라에서의 _____을 보여주면서, 리디노미네이션의 장점과 단점을 본격적으로 제시하고 있네.",
                    highlight: "현재 우리나라에서 국가 차원의 리디노미네이션은 본격적 논의에 이르렀다고 볼 수 없다.",
                    options: ["논의 현황", "성공 사례"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "반대쪽에서 고려해야 할 점은 막대한 _____이라는 거구나.",
                    highlight: "화폐 관련 기계나 프로그램 등을 교체하고 수정하는 데 들어갈 사회적 비용",
                    options: ["사회적 비용", "국민적 반감"],
                    correct: 0
                },
                {
                    id: 7,
                    text: "다음 문단에서는 이런 단점이나 _____에 대해 더 자세히 다룰 것 같아.",
                    highlight: "계산과 지급상의 편의가 확보된다는 장점",
                    options: ["구체적인 부작용", "예상 밖의 장점"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "이렇게 장점과 단점이 명확히 나뉘는 부분은 _____ 문제로 출제하기 정말 좋아.",
                    highlight: "자국 통화의 대외적 위상을 제고하는 일",
                    options: ["내용 일치", "<보기> 적용"],
                    correct: 0
                },
                // 3문단 질문들
                {
                    id: 9,
                    text: "이 문단은 국가적 리디노미네이션의 가장 큰 _____인 '인플레이션' 발생 가능성을 구체적으로 설명하고 있어.",
                    highlight: "화폐의 자릿수의 감소에 따라 생활 물가가 오르며 인플레이션을 낳을 수 있다",
                    options: ["부정적 측면", "긍정적 측면"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "물가가 오르는 이유는 상인들이 가격을 _____하여 판매할 가능성이 크기 때문이구나.",
                    highlight: "19,000원짜리 물건을 19원이 아니라 20원으로 올려서 판매",
                    options: ["올림(Rounding)", "내림(Rounding down)"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "그럼 다음에는 _____가 나올 수 있겠다고 예상해볼 수 있지.",
                    highlight: "소비자는 실행 후 1원의 인상에 대해 관대한 입장을 보일 것",
                    options: ["다른 차원의 이야기", "해결 방안"],
                    correct: 0
                },
                {
                    id: 12,
                    text: "'리디노미네이션 → 가격 올림 → 인플레이션 → 실물 자산 수요 증가'로 이어지는 _____의 흐름을 이해했는지 묻는 문제가 나올 수 있겠어.",
                    highlight: "부동산과 같은 실물 자산에 대한 수요를 높이는 데까지 이어질 수 있다",
                    options: ["인과 관계", "대조 관계"],
                    correct: 0
                },
                // 4문단 질문들
                {
                    id: 13,
                    text: "이 문단은 국가 차원이 아닌, 일부 소매점에서 자발적으로 사용하는 _____라는 새로운 화제를 제시하고 있네.",
                    highlight: "일부 국내 소매점에서 리디노미네이션 표기가 자발적으로 쓰이고 있는 경우",
                    options: ["사적 리디노미네이션", "불법적 리디노미네이션"],
                    correct: 0
                },
                {
                    id: 14,
                    text: "이런 표기의 목적은 실제 가치를 바꾸려는 게 아니라, 소비자에게 _____를 주려는 것이라는 점이 핵심이야.",
                    highlight: "소비자에게 미칠 수 있는 심리적인 효과를 극대화하려는 목적",
                    options: ["심리적인 효과", "경제적인 이득"],
                    correct: 0
                },
                {
                    id: 15,
                    text: "그럼 다음 문단에서는 당연히 _____이 뭔지 자세히 설명해 주겠지?",
                    highlight: "이중 정보 처리 이론",
                    options: ["새로운 이론", "앞서 나온 이론"],
                    correct: 0
                },
                {
                    id: 16,
                    text: "새로운 개념이나 이론이 등장하면, 그 개념을 정확히 이해했는지 묻는 _____ 문제가 나올 거라고 바로 예상해야 해.",
                    highlight: "가격이 제시되는 형태는 소비자가 정보를 처리하는 방식에 영향을 미칠 수 있다",
                    options: ["내용 일치", "서술 방식"],
                    correct: 0
                },
                // 5문단 질문들
                {
                    id: 17,
                    text: "이 문단은 '이중 정보 처리 이론'의 핵심 개념인 _____을 본격적으로 설명하는 역할을 하고 있어.",
                    highlight: "인간의 사고 체계를 이른바 '빠른 직관'과 '느린 이성'으로 구분한다",
                    options: ["'빠른 직관'과 '느린 이성'", "'인지 부하와 휴리스틱'"],
                    correct: 0
                },
                {
                    id: 18,
                    text: "'빠른 직관'은 인지적 부담이 _____ 오류가 잦은 반면, '느린 이성'은 그 반대라는 점을 명확히 구분해야겠어.",
                    highlight: "자동적이고 즉각적인 반응에 따라 인지적 부담을 줄이며",
                    options: ["적고", "크고"],
                    correct: 0
                },
                {
                    id: 19,
                    text: "이제 이론 설명이 끝났으니, 다음에는 이 이론을 _____하는 내용이 이어질 차례라고 예측할 수 있어.",
                    highlight: "빠른 직관과 느린 이성의 협응을 통해 의사 결정을 효율적으로",
                    options: ["앞서 말한 가격 표기 사례에 적용", "다른 경제 현상에 확대"],
                    correct: 0
                },
                {
                    id: 20,
                    text: "이렇게 두 가지 개념을 비교·대조하는 내용은 _____ 문제로 만들기 딱 좋아.",
                    highlight: "느린 이성은 인지적 노력이 요구되는 작업에서 의미 있는 역할",
                    options: ["내용 일치", "주장 비판"],
                    correct: 0
                },
                // 6문단 질문들
                {
                    id: 21,
                    text: "이 문단은 '빠른 직관'에 의존하는 경향이 _____에서 더 강해진다는 점을 설명하고 있어.",
                    highlight: "시간의 제약이나 복잡한 계산과 같은 어려움에 직면한 상황",
                    options: ["시간 제약이나 복잡한 상황", "여유롭고 익숙한 상황"],
                    correct: 0
                },
                {
                    id: 22,
                    text: "해외에서 환율 계산하기 귀찮으니까(느린 이성) 그냥 액면가만 보고 대충 어림짐작(빠른 직관)해서 물건을 사는 게 바로 이 때문이구나.",
                    highlight: "여행지에서 외화로 제품을 구매하는 경우",
                    options: ["시간 제약이나 복잡한 상황", "여유롭고 익숙한 상황"],
                    correct: 0
                },
                {
                    id: 23,
                    text: "이제 정말 마지막 문단에서는 이 모든 내용을 종합해서 글의 원래 주제였던 _____에 대한 결론을 내릴 차례야.",
                    highlight: "표기된 액면가를 확인하고는 그것을 기준으로 삼아 불완전한 어림짐작",
                    options: ["소매점의 리디노미네이션 표기", "국가적 리디노미네이션의 미래"],
                    correct: 0
                },
                {
                    id: 24,
                    text: "'해외여행' 사례는 <보기>로 제시하고, 지문의 이론과 연결해서 이해했는지 묻는 _____ 문제로 발전시키기 아주 좋은 재료야.",
                    highlight: "일상 속 인간은 빠른 직관을 주로 활성화하고",
                    options: ["사례 적용 <보기>형", "내용 전개 방식"],
                    correct: 0
                },
                // 7문단 질문들
                {
                    id: 25,
                    text: "드디어 마지막 문단! 이 문단은 글 전체의 내용을 _____을 내리는 역할을 하고 있어.",
                    highlight: "현재 우리나라의 카페나 음식점에서 종종 찾아볼 수 있는 리디노미네이션 표기 방식",
                    options: ["정리하고 결론", "반박하고 대안 제시"],
                    correct: 0
                },
                {
                    id: 26,
                    text: "결국 '10.0' 같은 가격 표기는 우리의 인지적 부담을 덜어줘서, 신중하게 따지는 '느린 이성' 대신에 즉흥적인 _____을 더 활발하게 만든다는 거구나.",
                    highlight: "소비자가 가격 정보를 처리할 때 빠른 직관의 영향을 강화하는 방식",
                    options: ["'빠른 직관'", "'느린 이성'"],
                    correct: 0
                },
                {
                    id: 27,
                    text: "우리는 실제 가치와 상관없이 숫자가 작다는 이유만으로 '저렴하다'고 착각하게 되고, 이것이 우리의 _____에 영향을 미친다는 것이 이 글의 최종 결론이네.",
                    highlight: "실제 지불 금액의 가치를 떠나, 적은 숫자이기에 저렴하다고 여기게 되는 판단",
                    options: ["의사 결정", "경제 관념"],
                    correct: 0
                },
                {
                    id: 28,
                    text: "글의 주제와 직결되는 이런 결론 부분은 글 전체를 포괄적으로 이해했는지 묻는 _____ 문제로 출제될 가능성이 매우 높아.",
                    highlight: "실질 가치의 변화 없이 액면의 자릿수가 달라지는 것은 소비 활동 과정에서 금액을 지불하는 주체의 의사 결정 과정에 영향을 미칠 수 있다",
                    options: ["주제 찾기", "어휘"],
                    correct: 0
                }
            ],
            fullText: `## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**

이 글은 '리디노미네이션'이라는 경제 현상을 사회적 차원과 개인적 차원으로 나누어 설명합니다. 국가가 시행하는 **공적 리디노미네이션**의 개념과 장단점을 소개하고, 이와 별개로 상점에서 사용하는 **사적 리디노미네이션 표기**가 소비자의 구매 심리에 미치는 영향을 '이중 정보 처리 이론'을 통해 심층적으로 분석합니다. 경제 개념과 인지 심리학 이론을 연결하여 사회 현상을 다각적으로 이해하는 능력이 요구되는 지문입니다.

### **[핵심 정리 표]**

| 구분 | 내용 |
| :---- | :---- |
| **글의 주제** | **공적·사적 리디노미네이션의 개념과 영향, 그리고 '이중 정보 처리 이론'으로 분석한 소비 심리** |
| **글의 구조** | **1. 공적 리디노미네이션의 개념과 특징 (1~2문단)**<br>• 리디노미네이션은 화폐의 실질 가치는 (그대로 둔 채 / 변화시킨 채) 액면가, 즉 화폐 단위를 다시 설정하는 화폐 개혁의 일종이다.<br>• 지속적인 경제 성장으로 물가가 상승하고 화폐의 자릿수가 커지면, 기업의 장부 기재나 계산상의 (편리함 / 불편함)이 발생하는데, 리디노미네이션은 이를 해결하기 위한 방안이 될 수 있다.<br>• 긍정적 측면으로는 계산 및 지급의 편의성을 확보하고, 나아가 자국 통화의 대외적 위상을 (하락시키는 / 제고하는) 효과를 기대할 수 있다는 의견이 있다.<br>• 그러나 새로운 화폐 제작, 관련 기기 및 프로그램 교체 등에 막대한 (사회적 비용 / 국가 신용도)가 발생한다는 점은 신중하게 고려해야 할 단점이다.<br>• 우리나라에서는 리디노미네이션의 필요성이 제기된 적은 있으나, 아직 (성공적으로 시행되었다 / 본격적 논의에 이르지 못했다)<br><br>**2. 공적 리디노미네이션의 잠재적 부작용 (3문단)**<br>• 리디노미네이션 실행 시, 상인들이 1,900원짜리 물건을 1.9원이 아닌 2.0원으로 가격을 올리는 현상, 즉 '올림(Rounding)'으로 인해 전반적인 물가가 상승하는 (인플레이션 / 디플레이션)이 발생할 수 있다.<br>• 소비자는 화폐 단위 변경 후 1원의 인상에 대해 (민감한 / 관대한) 입장을 보일 가능성이 크기 때문에 이러한 물가 상승이 용인될 수 있다.<br>• 물가 상승으로 인한 경제적 불안은 화폐 가치에 대한 (불확실성 / 신뢰도)을 키워, 사람들이 안정적인 가치를 지닌 부동산과 같은 (금융 자산 / 실물 자산)에 대한 수요를 높이는 결과로 이어질 수 있다.<br><br>**3. 사적 리디노미네이션 표기와 이중 정보 처리 이론 (4~5문단)**<br>• 일부 카페나 음식점에서 10,000원을 '10.0'으로 표기하는 것은, 실제 가치에 영향을 주지 않으면서 소비자의 (합리적 판단 / 심리적 효과)를 극대화하려는 목적을 갖는다.<br>• '이중 정보 처리 이론'은 인간의 사고 체계를 무의식적으로 빠르게 반응하는 '(빠른 직관 / 느린 이성)'과 의식적으로 심사숙고하는 '(빠른 직관 / 느린 이성)'으로 구분한다.<br>• **빠른 직관**: 인지적 부담이 (크고 / 적고) 즉각적인 반응을 보이지만, 종종 부정확한 판단을 내릴 수 있다.<br>• **느린 이성**: 인지적 노력이 필요하고 시간이 걸리지만, 판단의 오류를 (최소화 / 극대화)할 수 있다는 장점이 있다.<br>• 인간의 정보 처리 능력에는 한계가 있으므로, 두 사고 체계의 (경쟁 / 협응)을 통해 의사 결정을 효율적으로 처리하고자 한다.<br><br>**4. 리디노미네이션 표기가 소비 심리에 미치는 영향 (6~7문단)**<br>• 인간은 일상 속에서 반응 속도가 빠른 '(빠른 직관 / 느린 이성)'을 주로 활성화하여 인지 과정의 수고를 줄이려 한다.<br>• 이러한 경향은 시간 제약이나 복잡한 계산과 같은 (익숙한 상황 / 어려운 상황)에 직면했을 때 더욱 강화된다.<br>• 여행지에서 외화로 물건을 살 때, 정확한 환율 계산보다 액면가를 기준으로 어림짐작하는 것이 이와 (유사한 / 상반된) 사례에 해당한다.<br>• 결국, 자릿수를 줄인 가격 표기는 소비자의 인지적 부담을 덜어주어 '(빠른 직관 / 느린 이성)'의 영향을 강화시킨다.<br>• 그 결과 소비자는 실제 가치와는 무관하게 표시된 숫자가 작다는 이유만으로 상품이 (저렴하다고 / 비싸다고) 판단할 확률이 높아진다. |

## **2️⃣ 지문 라이트 버전 / 작품 미리보기 📝**

혹시 '리디노미네이션'이라는 말을 (들어본 적 / 처음 듣는) 있나요? 조금 (어렵게 / 쉽게) 들릴 수 있지만, 사실 우리 생활과 아주 (먼 / 가까운) 이야기랍니다. 우리나라 돈의 단위가 너무 (커져서 / 작아져서) 생기는 불편함, 그리고 가게에서 물건값을 교묘하게 (똑같이 / 다르게) 표시하는 이유에 대해 함께 알아볼까요?

**1. 돈의 단위를 확 줄인다고? - '리디노미네이션'**

'리디노미네이션'은 아주 (복잡하게 / 간단하게) 말해 '화폐 단위 바꾸기'예요. 예를 들어, 지금 우리가 쓰는 1,000원을 새로운 (1원 / 100원)으로 바꾸는 거죠. 물론 돈의 실제 가치는 (바뀌어야 해요 / 그대로여야 해요). 1,000원으로 사 먹던 과자는 새로운 1원으로 (다르게 / 똑같이) 사 먹을 수 있어야 해요.

그럼 이걸 (왜 / 어떻게) 할까요? 우리나라가 경제적으로 크게 (성장하면서 / 후퇴하면서) 물건값이 아주 비싸졌어요. 밥 한 끼에 (몇백 원 / 몇만 원) 하고, 집 한 채는 몇억 원씩 하죠. 이렇게 돈의 자릿수(0의 개수)가 너무 (적어지면 / 많아지면) 여러 가지 불편한 점이 생겨요.

* **장점**: 만약 1,000원을 1원으로 바꾼다면, 7,500원짜리 커피는 (7.5원 / 75원)이 되고 50,000원짜리 피자는 50원이 되겠죠? 이렇게 되면 가게에서 장부를 쓰거나 우리가 계산할 때 훨씬 (편리해져요 / 불편해져요). 다른 나라와 무역을 할 때도 편하고, 우리나라 돈의 위상도 (높아 / 낮아) 보일 수 있어요.
* **단점**: 하지만 (단점 / 장점)도 만만치 않아요. 전국의 모든 돈을 새로 찍어내야 하고, 현금인출기(ATM)나 컴퓨터 프로그램도 전부 (그대로 둬도 되니 / 바꿔야 하니) 어마어마한 돈, 즉 **사회적 비용**이 들어요.

**2. 꼬리가 몸통을 흔드는 물가 상승?**

더 큰 문제는 **물가 (상승 / 하락)**, 즉 **인플레이션**이 생길 수 있다는 거예요. 예를 들어 (1,900원 / 19,000원)짜리 과자가 있다고 해봐요. 이걸 1.9원으로 바꾸면 계산하기 (복잡하니까 / 편리하니까) 가게 주인이 은근슬쩍 2.0원으로 (내려 / 올려) 받을 수 있어요. 우리 입장에서는 고작 0.1원이 오른 것처럼 보여서 "에이, 그 정도야 뭐." 하고 (쉽게 / 망설이다) 사게 되죠. 하지만 실제로는 (100원 / 10원)이 오른 셈이에요! 이런 일이 여기저기서 일어나면 전체 물가가 크게 (오를 / 내릴) 수 있고, 사람들은 돈의 가치를 (신뢰해서 / 믿지 못해서) 불안해하며 부동산 같은 **실물 자산**을 사려고 할 수도 있어요.

**3. '10.0'의 비밀 - 우리의 뇌를 속이는 숫자**

나라에서 하는 리디노미네이션 말고, 요즘 카페나 음식점에서 '10.0' (10,000원), '5.5' (5,500원)처럼 가격을 표시하는 걸 (본 적 없나요 / 본 적 있나요)? 이것도 일종의 리디노미네이션 표기인데, 사실 우리 (뇌를 / 몸을) 속이는 아주 재미있는 (심리 / 물리) 전략이랍니다.

(심리학에는 / 경제학에는) '이중 정보 처리 이론'이라는 게 있어요. 우리 머릿속에는 (한 명 / 두 명)의 일꾼이 살고 있다고 생각하면 쉬워요.

* **빠른 직관**: 아무 생각 없이 (본능적으로 / 이성적으로) 빠르게 결정하는 일꾼이에요. "어, 이거 (싸다 / 비싸다)!" 하고 바로 반응하죠. 힘이 별로 (안 들어서 / 많이 들어서) 편하지만, 가끔 (절대 실수 안 해요 / 실수도 해요).
* **느린 이성**: 아주 (신중하고 / 충동적이고) 꼼꼼하게 따져보는 일꾼이에요. "이게 정말 싼 게 맞을까?" 하고 (천천히 / 빨리) 생각하죠. (정확하지만 / 부정확하지만) 머리를 많이 써야 해서 피곤해요.

우리는 보통 피곤한 걸 (싫어해서 / 좋아해서) 대부분의 일을 '(빠른 직관 / 느린 이성)'에게 맡겨요. 가게 주인들은 바로 이 점을 (이용하는 / 무시하는) 거예요! '10,000원'이라고 쓰인 걸 보면 '(느린 이성 / 빠른 직관)'이 "음, 만 원이군." 하고 생각하지만, '10.0'이라고 쓰인 걸 보면 '빠른 직관'이 "어? 숫자 10이네? (싸다 / 비싸다)!" 하고 순간적으로 (착각하게 / 이해하게) 만드는 거죠.

이처럼 숫자의 자릿수를 (줄이는 / 늘리는) 표기 방식은 우리의 인지적 부담을 (덜어주어 / 더해주어) '빠른 직관'을 더 (활발하게 / 둔하게) 만들고, 그 결과 소비자는 실제 가치와는 무관하게 표시된 숫자가 작다는 이유만으로 상품이 (저렴하다고 / 비싸다고) 판단할 확률이 높아져 쉽게 지갑을 열게 될 수 있답니다.`
        };

        // 2단계 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "리디노미네이션",
                meaning: "화폐의 실질 가치는 그대로 두고 액면가를 낮은 숫자로 변경하는 화폐 개혁",
                type: "개념",
                confusors: {
                    word: ["디노미네이션", "화폐 개혁", "평가 절하"],
                    meaning: ["화폐의 실질 가치를 변경하여 경제 구조 자체를 바꾸는 화폐 개혁", "새로운 화폐를 발행하여 이전 화폐를 완전히 대체하는 것만을 의미", "국제 외환 시장에서 자국 화폐의 가치를 인위적으로 떨어뜨리는 것"]
                }
            },
            {
                word: "액면가",
                meaning: "화폐나 증권의 표면에 적혀 있는 가격",
                type: "한자어",
                confusors: {
                    word: ["시가", "실질가", "공정가"],
                    meaning: ["시장에서 실제로 거래되고 있는 순간의 변동 가격", "인플레이션 등 물가 변동을 반영하여 조정한 실제 구매력 가치", "거래 당사자들이 합의하여 내부적으로 숨겨놓은 비공개 가격"]
                }
            },
            {
                word: "통용",
                meaning: "화폐가 사회에서 널리 쓰임",
                type: "한자어",
                confusors: {
                    word: ["유통", "발행", "통행"],
                    meaning: ["특정 지역이나 제한된 범위 안에서만 부분적으로 사용되는 것", "중앙은행이나 정부가 화폐를 처음 만들어서 시장에 내놓는 것", "상품이나 물건이 생산지에서 소비지로 이동하며 오가는 것"]
                }
            },
            {
                word: "실질 가치",
                meaning: "상품이 실제로 가지고 있는 사용 가치. 물가 변동을 제외하고 계산한 가치",
                type: "개념",
                confusors: {
                    word: ["명목 가치", "시장 가치", "교환 가치"],
                    meaning: ["인플레이션 등 물가 변동을 그대로 포함하여 표시한 명목상의 가격", "화폐나 증권의 겉면에 직접 표시되어 있는 액면 금액 자체", "금융 상품에 투자했을 때 기대할 수 있는 수익률만을 나타내는 가치"]
                }
            },
            {
                word: "제고",
                meaning: "정도나 수준을 끌어올림",
                type: "한자어",
                confusors: {
                    word: ["향상", "증진", "상승"],
                    meaning: ["현재의 정도나 수준을 의도적으로 낮추거나 하향 조정하는 것", "변화 없이 현재의 상태나 수준을 그대로 지속하며 유지하는 것", "단기간 동안 일시적으로만 높였다가 다시 원래대로 돌아오는 것"]
                }
            },
            {
                word: "인플레이션",
                meaning: "통화량이 팽창하여 화폐 가치가 떨어지고 물가가 계속적으로 오르는 현상",
                type: "개념",
                confusors: {
                    word: ["디플레이션", "스태그플레이션", "경기 침체"],
                    meaning: ["통화량이 축소되어 화폐 가치가 상승하고 물가가 지속적으로 하락하는 현상", "단기간에 일시적으로만 물가가 오르다가 다시 안정되는 일회성 현상", "물가는 그대로인데 화폐의 가치만 올라가서 구매력이 증가하는 현상"]
                }
            },
            {
                word: "실물 자산",
                meaning: "토지, 건물, 원자재 등과 같이 형태가 있는 자산",
                type: "개념",
                confusors: {
                    word: ["금융 자산", "유동 자산", "무형 자산"],
                    meaning: ["주식이나 채권처럼 실체가 없고 증서로만 존재하는 금융상품 자산", "보유한 자산 중에서 현금이나 즉시 인출 가능한 예금만을 특정하여 의미", "기업이 가지고 있는 부채나 채무, 또는 갚아야 할 빚을 의미"]
                }
            },
            {
                word: "기제",
                meaning: "어떤 현상을 일으키는 작용의 원리나 과정",
                type: "한자어",
                confusors: {
                    word: ["원리", "과정", "방법"],
                    meaning: ["작용이 일어나고 나서 최종적으로 나타나는 결과물이나 산출물", "시작과 끝이 정해진 단순하고 기계적인 절차나 순서의 나열", "목적 달성을 위해 사용하는 특정한 도구나 기계적 장치"]
                }
            },
            {
                word: "인지적 부담",
                meaning: "정보를 처리하는 데에 드는 정신적인 노력이나 어려움",
                type: "개념",
                confusors: {
                    word: ["정신적 부담", "심리적 압박", "인지 능력"],
                    meaning: ["육체를 사용한 활동으로 인해 발생하는 신체적인 피로나 육체적 노력", "외부 요인으로 인해 받게 되는 감정적인 압박감이나 정서적 스트레스", "정보를 받아들이고 처리할 수 있는 개인의 기본적인 능력이나 역량 자체"]
                }
            },
            {
                word: "협응",
                meaning: "둘 이상의 부분이 서로 조화롭게 응하여 협력함",
                type: "한자어",
                confusors: {
                    word: ["조화", "협력", "통합"],
                    meaning: ["둘 이상의 부분이 서로 반대 입장에서 대립하거나 경쟁하는 것", "여러 부분 중 한쪽이 우위를 점하여 다른 쪽을 지배하고 통제하는 것", "둘 이상의 독립된 부분이 경계 없이 완전히 하나로 융합되어 합쳐지는 것"]
                }
            },
            {
                word: "이중 정보 처리 이론",
                meaning: "인간의 사고 체계를 '빠른 직관'과 '느린 이성'으로 나누어 설명하는 심리학 이론",
                type: "학문 용어",
                confusors: {
                    word: ["정보 처리 이론", "이중 부호화 이론", "인지 부하 이론"],
                    meaning: ["인간의 뇌가 두 가지 종류의 정보를 동시에 처리할 수 없다는 한계를 설명하는 이론", "인간에게는 단 하나의 통합된 사고 체계만 존재하며 분리할 수 없다는 이론", "의사 결정 과정에서 빠른 직관만이 중요하고 느린 이성은 불필요하다는 이론"]
                }
            }
        ];

        // Stage 0 원문 텍스트 (리디노미네이션 7개 문단)
        const stage0OriginalText = `**[1문단]**

리디노미네이션(redenomination)은 명사 디노미네이션 앞에 '다시'를 뜻하는 접두사 're-'를 붙여 만든 단어이다. 이미 쓰이고 있는 화폐의 액면가를 다시 설정하는 일을 일컬으며 통상적으로 화폐의 액면 절하를 뜻하는 말로 쓰인다. 리디노미네이션은 통용되는 모든 지폐나 동전에 대한 실질 가치는 그대로 둔 채 액면을 특정 비율을 적용하여 낮은 숫자로 변경하거나 그와 더불어 새로운 화폐 단위를 지정하는 방법을 통해 실행된다. 우리나라의 경우 마지막 화폐 개혁이 있었던 1962년 이후, 지속적 경제 성장으로 말미암아 화폐 발행이 증가하는 만큼 물가도 꾸준히 상승했다. 국가 차원의 리디노미네이션을 실행하면, 통용되는 화폐의 자릿수를 줄여 기업 등에서의 장부 기재상 불편을 줄일 수 있다.

**[2문단]**

2016년 우리나라의 중앙은행인 한국은행에서는 국내 경제 규모를 고려하여 우리나라 화폐 단위에 대한 리디노미네이션을 고민해 보아야 할 시점이라는 내용의 보고서를 내놓은 바 있으나, 현재 우리나라에서 국가 차원의 리디노미네이션은 본격적 논의에 이르렀다고 볼 수 없다. 일각에서는 국가 경제 규모가 비약적으로 커지며 통용되는 화폐의 자릿수가 늘어난 우리나라의 상황을 고려한다면, 화폐의 자릿수를 줄여 국제 무역에서 편의를 도모해야 하며 그것이 자국 통화의 대외적 위상을 제고하는 일이라는 의견도 있다. 국가 차원의 리디노미네이션이 실행되면 모든 상점에서 화폐의 자릿수를 줄여 표기하게 되므로 계산과 지급상의 편의가 확보된다는 장점이 있지만, 새로운 화폐에 대한 제작 비용과 더불어 화폐 관련 기계나 프로그램 등을 교체하고 수정하는 데 들어갈 사회적 비용도 고려해야 한다.

**[3문단]**

국가 차원의 리디노미네이션이 실행될 경우, 화폐의 자릿수의 감소에 따라 생활 물가가 오르며 인플레이션을 낳을 수 있다는 우려의 목소리도 있다. 원화 단위를 그대로 유지하는 1,000분의 1 리디노미네이션이 우리나라에서 실행된다면 상인은 기존의 19,000원짜리 물건을 19원이 아니라 20원으로 올려서 판매할 가능성이 크다. 리디노미네이션 실행 전 1,000원과 실행 후 1원의 가치가 같더라도, 소비자는 실행 후 1원의 인상에 대해 관대한 입장을 보일 것이라 예상되기 때문이다. 그리고 이와 같은 방식으로 야기되는 물가 상승으로 인한 불안이 지속된다면, 화폐 가치에 대한 불확실성이 확대되어 부동산과 같은 실물 자산에 대한 수요를 높이는 데까지 이어질 수 있다.

**[4문단]**

국가 차원의 리디노미네이션 도입과는 별개로 일부 국내 소매점에서 리디노미네이션 표기가 자발적으로 쓰이고 있는 경우가 있다. 10,000원을 1,000:1의 비율로 조정하여 '10.0'과 같이 표기하는 것이다. 이는 상품의 실제 경제적 가치에 영향을 미치는 것은 아니지만 숫자 표시 방식의 변화를 통해 구매 결정 과정의 소비자에게 미칠 수 있는 심리적인 효과를 극대화하려는 목적에서 비롯된 것으로 보인다. 이와 관련하여 이중 정보 처리 이론에서는 구매 과정에서 가격이 제시되는 형태는 소비자가 정보를 처리하는 방식에 영향을 미칠 수 있다고 설명한다.

**[5문단]**

이중 정보 처리 이론에서는 인간의 사고 체계를 이른바 '빠른 직관'과 '느린 이성'으로 구분한다. 빠른 직관은 무의식, 직관에 의해 작동하는 기제로서 본능적이거나 숙달된 업무를 처리하는 데에 적합하며, 빠른 직관의 사고 체계를 통해 인간은 자동적이고 즉각적인 반응에 따라 인지적 부담을 줄이며 정보를 처리할 수 있다. 이때 처리 과정을 의식적으로 통제하는 것은 어렵다. 반면 느린 이성은 의식, 이성에 의해 작동하는 사고 체계로 심사숙고하여 비중 있는 일을 처리하는 과정에 작동한다. 느린 이성은 인지적 노력이 요구되는 작업에서 의미 있는 역할을 하고, 비교적 긴 시간을 들여 정보를 처리하고 판단에 이르므로 오류를 최소화할 수 있다는 장점이 있다. 이중 정보 처리 이론에 따르면 인간의 정보 처리 능력에는 한계가 있으므로 상황에 따라 인간은 빠른 직관과 느린 이성의 협응을 통해 의사 결정을 효율적으로 내리고자 한다. 일상적 사건의 원활한 처리와 단기적 예측에 효과적인 빠른 직관은, 느린 이성을 필요로 하는 일을 최소화하도록 만든다. 빠른 직관의 사고 체계 내에서 인간은 종종 부정확한 판단을 하고, 예측이 어긋나는 상황에 직면한다.

**[6문단]**

이중 정보 처리 이론에서는 반응 속도의 차이로 인해 일상 속 인간은 빠른 직관을 주로 활성화하고, 느린 이성의 개입을 가능한 한 줄이고자 한다고 설명한다. 그리고 시간의 제약이나 복잡한 계산과 같은 어려움에 직면한 상황에서 그러한 경향은 강화된다고 본다. 심리학자 에플리와 길로비치는 유사한 사례로 여행지에서 외화로 제품을 구매하는 경우 사람들은 정확한 환율 계산을 통해 구매를 결정하기보다는 표기된 액면가를 확인하고는 그것을 기준으로 삼아 불완전한 어림짐작으로 구매를 결정하는 경향이 있다는 연구 결과를 발표했다.

**[7문단]**

현재 우리나라의 카페나 음식점에서 종종 찾아볼 수 있는 리디노미네이션 표기 방식은 소비자가 가격 정보를 처리할 때 빠른 직관의 영향을 강화하는 방식으로 작용할 수 있다. 자릿수의 감소는 소비자에게 인지적 부담을 덜어 주고, 소비자는 구매 여부를 결정하는 순간적 과정에서 실제 지불 금액의 가치를 떠나, 적은 숫자이기에 저렴하다고 여기게 되는 판단을 할 확률이 높아지는 것이다. 실질 가치의 변화 없이 액면의 자릿수가 달라지는 것은 소비 활동 과정에서 금액을 지불하는 주체의 의사 결정 과정에 영향을 미칠 수 있다.`;

        // Stage 1 질문 배열 (딥리서치 - 핵심 정리 표의 빈칸 문제)
        const stage1Questions = [
            {
                id: 1,
                text: "리디노미네이션은 화폐의 실질 가치는 _____ 액면가, 즉 화폐 단위를 다시 설정하는 화폐 개혁의 일종이다.",
                highlight: "리디노미네이션은 화폐의 실질 가치는 (그대로 둔 채 / 변화시킨 채) 액면가",
                options: ["그대로 둔 채", "변화시킨 채"],
                correct: 0
            },
            {
                id: 2,
                text: "지속적인 경제 성장으로 물가가 상승하고 화폐의 자릿수가 커지면, 기업의 장부 기재나 계산상의 _____이 발생하는데, 리디노미네이션은 이를 해결하기 위한 방안이 될 수 있다.",
                highlight: "기업의 장부 기재나 계산상의 (편리함 / 불편함)이 발생하는데",
                options: ["편리함", "불편함"],
                correct: 1
            },
            {
                id: 3,
                text: "긍정적 측면으로는 계산 및 지급의 편의성을 확보하고, 나아가 자국 통화의 대외적 위상을 _____ 효과를 기대할 수 있다는 의견이 있다.",
                highlight: "자국 통화의 대외적 위상을 (하락시키는 / 제고하는) 효과를 기대할 수 있다는 의견이 있다",
                options: ["하락시키는", "제고하는"],
                correct: 1
            },
            {
                id: 4,
                text: "그러나 새로운 화폐 제작, 관련 기기 및 프로그램 교체 등에 막대한 _____가 발생한다는 점은 신중하게 고려해야 할 단점이다.",
                highlight: "막대한 (사회적 비용 / 국가 신용도)가 발생한다는 점은 신중하게 고려해야 할 단점이다",
                options: ["사회적 비용", "국가 신용도"],
                correct: 0
            },
            {
                id: 5,
                text: "우리나라에서는 리디노미네이션의 필요성이 제기된 적은 있으나, 아직 _____",
                highlight: "아직 (성공적으로 시행되었다 / 본격적 논의에 이르지 못했다)",
                options: ["성공적으로 시행되었다", "본격적 논의에 이르지 못했다"],
                correct: 1
            },
            {
                id: 6,
                text: "리디노미네이션 실행 시, 상인들이 1,900원짜리 물건을 1.9원이 아닌 2.0원으로 가격을 올리는 현상, 즉 '올림(Rounding)'으로 인해 전반적인 물가가 상승하는 _____이 발생할 수 있다.",
                highlight: "(인플레이션 / 디플레이션)이 발생할 수 있다",
                options: ["인플레이션", "디플레이션"],
                correct: 0
            },
            {
                id: 7,
                text: "소비자는 화폐 단위 변경 후 1원의 인상에 대해 _____ 입장을 보일 가능성이 크기 때문에 이러한 물가 상승이 용인될 수 있다.",
                highlight: "1원의 인상에 대해 (민감한 / 관대한) 입장을 보일 가능성이 크기 때문에",
                options: ["민감한", "관대한"],
                correct: 1
            },
            {
                id: 8,
                text: "물가 상승으로 인한 경제적 불안은 화폐 가치에 대한 _____을 키워, 사람들이 안정적인 가치를 지닌 부동산과 같은 실물 자산에 대한 수요를 높이는 결과로 이어질 수 있다.",
                highlight: "화폐 가치에 대한 (불확실성 / 신뢰도)을 키워",
                options: ["불확실성", "신뢰도"],
                correct: 0
            },
            {
                id: 9,
                text: "물가 상승으로 인한 경제적 불안은 화폐 가치에 대한 불확실성을 키워, 사람들이 안정적인 가치를 지닌 부동산과 같은 _____에 대한 수요를 높이는 결과로 이어질 수 있다.",
                highlight: "부동산과 같은 (금융 자산 / 실물 자산)에 대한 수요를 높이는 결과로 이어질 수 있다",
                options: ["금융 자산", "실물 자산"],
                correct: 1
            },
            {
                id: 10,
                text: "일부 카페나 음식점에서 10,000원을 '10.0'으로 표기하는 것은, 실제 가치에 영향을 주지 않으면서 소비자의 _____를 극대화하려는 목적을 갖는다.",
                highlight: "소비자의 (합리적 판단 / 심리적 효과)를 극대화하려는 목적을 갖는다",
                options: ["합리적 판단", "심리적 효과"],
                correct: 1
            },
            {
                id: 11,
                text: "'이중 정보 처리 이론'은 인간의 사고 체계를 무의식적으로 빠르게 반응하는 '_____'과 의식적으로 심사숙고하는 '_____'으로 구분한다.",
                highlight: "무의식적으로 빠르게 반응하는 '(빠른 직관 / 느린 이성)'과 의식적으로 심사숙고하는 '(빠른 직관 / 느린 이성)'으로 구분한다",
                options: ["빠른 직관, 빠른 직관", "빠른 직관, 느린 이성"],
                correct: 1
            },
            {
                id: 12,
                text: "**빠른 직관**: 인지적 부담이 _____ 즉각적인 반응을 보이지만, 종종 부정확한 판단을 내릴 수 있다.",
                highlight: "인지적 부담이 (크고 / 적고) 즉각적인 반응을 보이지만",
                options: ["크고", "적고"],
                correct: 1
            },
            {
                id: 13,
                text: "**느린 이성**: 인지적 노력이 필요하고 시간이 걸리지만, 판단의 오류를 _____ 수 있다는 장점이 있다.",
                highlight: "판단의 오류를 (최소화 / 극대화)할 수 있다는 장점이 있다",
                options: ["최소화", "극대화"],
                correct: 0
            },
            {
                id: 14,
                text: "인간의 정보 처리 능력에는 한계가 있으므로, 두 사고 체계의 _____을 통해 의사 결정을 효율적으로 처리하고자 한다.",
                highlight: "두 사고 체계의 (경쟁 / 협응)을 통해 의사 결정을 효율적으로 처리하고자 한다",
                options: ["경쟁", "협응"],
                correct: 1
            },
            {
                id: 15,
                text: "인간은 일상 속에서 반응 속도가 빠른 '_____'을 주로 활성화하여 인지 과정의 수고를 줄이려 한다.",
                highlight: "반응 속도가 빠른 '(빠른 직관 / 느린 이성)'을 주로 활성화하여 인지 과정의 수고를 줄이려 한다",
                options: ["빠른 직관", "느린 이성"],
                correct: 0
            },
            {
                id: 16,
                text: "이러한 경향은 시간 제약이나 복잡한 계산과 같은 _____에 직면했을 때 더욱 강화된다.",
                highlight: "(익숙한 상황 / 어려운 상황)에 직면했을 때 더욱 강화된다",
                options: ["익숙한 상황", "어려운 상황"],
                correct: 1
            },
            {
                id: 17,
                text: "여행지에서 외화로 물건을 살 때, 정확한 환율 계산보다 액면가를 기준으로 어림짐작하는 것이 이와 _____ 사례에 해당한다.",
                highlight: "이와 (유사한 / 상반된) 사례에 해당한다",
                options: ["유사한", "상반된"],
                correct: 0
            },
            {
                id: 18,
                text: "결국, 자릿수를 줄인 가격 표기는 소비자의 인지적 부담을 덜어주어 '_____'의 영향을 강화시킨다.",
                highlight: "'(빠른 직관 / 느린 이성)'의 영향을 강화시킨다",
                options: ["빠른 직관", "느린 이성"],
                correct: 0
            },
            {
                id: 19,
                text: "그 결과 소비자는 실제 가치와는 무관하게 표시된 숫자가 작다는 이유만으로 상품이 _____ 판단할 확률이 높아진다.",
                highlight: "상품이 (저렴하다고 / 비싸다고) 판단할 확률이 높아진다",
                options: ["저렴하다고", "비싸다고"],
                correct: 0
            },
            // 라이트 버전 2지 선다 문제들 (괄호만 정확히 매칭)
            {
                id: 20,
                text: "혹시 '리디노미네이션'이라는 말을 _____ 있나요?",
                highlight: "(들어본 적 / 처음 듣는)",
                options: ["들어본 적", "처음 듣는"],
                correct: 0
            },
            {
                id: 21,
                text: "조금 _____ 들릴 수 있지만, 사실 우리 생활과 아주 가까운 이야기랍니다.",
                highlight: "(어렵게 / 쉽게)",
                options: ["어렵게", "쉽게"],
                correct: 0
            },
            {
                id: 22,
                text: "사실 우리 생활과 아주 _____ 이야기랍니다.",
                highlight: "(먼 / 가까운)",
                options: ["먼", "가까운"],
                correct: 1
            },
            {
                id: 23,
                text: "우리나라 돈의 단위가 너무 _____ 생기는 불편함,",
                highlight: "(커져서 / 작아져서)",
                options: ["커져서", "작아져서"],
                correct: 0
            },
            {
                id: 24,
                text: "가게에서 물건값을 교묘하게 _____ 표시하는 이유에 대해 함께 알아볼까요?",
                highlight: "(똑같이 / 다르게)",
                options: ["똑같이", "다르게"],
                correct: 1
            },
            {
                id: 25,
                text: "'리디노미네이션'은 아주 _____ 말해 '화폐 단위 바꾸기'예요.",
                highlight: "(복잡하게 / 간단하게)",
                options: ["복잡하게", "간단하게"],
                correct: 1
            },
            {
                id: 26,
                text: "지금 우리가 쓰는 1,000원을 새로운 _____ 으로 바꾸는 거죠.",
                highlight: "(1원 / 100원)",
                options: ["1원", "100원"],
                correct: 0
            },
            {
                id: 27,
                text: "물론 돈의 실제 가치는 _____ .",
                highlight: "(바뀌어야 해요 / 그대로여야 해요)",
                options: ["바뀌어야 해요", "그대로여야 해요"],
                correct: 1
            },
            {
                id: 28,
                text: "1,000원으로 사 먹던 과자는 새로운 1원으로 _____ 사 먹을 수 있어야 해요.",
                highlight: "(다르게 / 똑같이)",
                options: ["다르게", "똑같이"],
                correct: 1
            },
            {
                id: 29,
                text: "그럼 이걸 _____ 할까요?",
                highlight: "(왜 / 어떻게)",
                options: ["왜", "어떻게"],
                correct: 0
            },
            {
                id: 30,
                text: "우리나라가 경제적으로 크게 _____ 물건값이 아주 비싸졌어요.",
                highlight: "(성장하면서 / 후퇴하면서)",
                options: ["성장하면서", "후퇴하면서"],
                correct: 0
            },
            {
                id: 31,
                text: "밥 한 끼에 _____ 하고, 집 한 채는 몇억 원씩 하죠.",
                highlight: "(몇백 원 / 몇만 원)",
                options: ["몇백 원", "몇만 원"],
                correct: 1
            },
            {
                id: 32,
                text: "이렇게 돈의 자릿수(0의 개수)가 너무 _____ 여러 가지 불편한 점이 생겨요.",
                highlight: "(적어지면 / 많아지면)",
                options: ["적어지면", "많아지면"],
                correct: 1
            },
            {
                id: 33,
                text: "7,500원짜리 커피는 _____ 이 되고 50,000원짜리 피자는 50원이 되겠죠?",
                highlight: "(7.5원 / 75원)",
                options: ["7.5원", "75원"],
                correct: 0
            },
            {
                id: 34,
                text: "이렇게 되면 가게에서 장부를 쓰거나 우리가 계산할 때 훨씬 _____ .",
                highlight: "(편리해져요 / 불편해져요)",
                options: ["편리해져요", "불편해져요"],
                correct: 0
            },
            {
                id: 35,
                text: "다른 나라와 무역을 할 때도 편하고, 우리나라 돈의 위상도 _____ 보일 수 있어요.",
                highlight: "(높아 / 낮아)",
                options: ["높아", "낮아"],
                correct: 0
            },
            {
                id: 36,
                text: "하지만 _____ 도 만만치 않아요.",
                highlight: "(단점 / 장점)",
                options: ["단점", "장점"],
                correct: 0
            },
            {
                id: 37,
                text: "전국의 모든 돈을 새로 찍어내야 하고, 현금인출기(ATM)나 컴퓨터 프로그램도 전부 _____ 어마어마한 돈이 들어요.",
                highlight: "(그대로 둬도 되니 / 바꿔야 하니)",
                options: ["그대로 둬도 되니", "바꿔야 하니"],
                correct: 1
            },
            {
                id: 38,
                text: "더 큰 문제는 물가 _____ , 즉 인플레이션이 생길 수 있다는 거예요.",
                highlight: "(상승 / 하락)",
                options: ["상승", "하락"],
                correct: 0
            },
            {
                id: 39,
                text: "예를 들어 _____ 짜리 과자가 있다고 해봐요.",
                highlight: "(1,900원 / 19,000원)",
                options: ["1,900원", "19,000원"],
                correct: 0
            },
            {
                id: 40,
                text: "이걸 1.9원으로 바꾸면 계산하기 _____ 가게 주인이 은근슬쩍 2.0원으로 올려 받을 수 있어요.",
                highlight: "(복잡하니까 / 편리하니까)",
                options: ["복잡하니까", "편리하니까"],
                correct: 0
            },
            {
                id: 41,
                text: "가게 주인이 은근슬쩍 2.0원으로 _____ 받을 수 있어요.",
                highlight: "(내려 / 올려)",
                options: ["내려", "올려"],
                correct: 1
            },
            {
                id: 42,
                text: "우리 입장에서는 고작 0.1원이 오른 것처럼 보여서 \"에이, 그 정도야 뭐.\" 하고 _____ 사게 되죠.",
                highlight: "(쉽게 / 망설이다)",
                options: ["쉽게", "망설이다"],
                correct: 0
            },
            {
                id: 43,
                text: "하지만 실제로는 _____ 이 오른 셈이에요!",
                highlight: "(100원 / 10원)",
                options: ["100원", "10원"],
                correct: 0
            },
            {
                id: 44,
                text: "이런 일이 여기저기서 일어나면 전체 물가가 크게 _____ 수 있고,",
                highlight: "(오를 / 내릴)",
                options: ["오를", "내릴"],
                correct: 0
            },
            {
                id: 45,
                text: "사람들은 돈의 가치를 _____ 불안해하며 부동산 같은 실물 자산을 사려고 할 수도 있어요.",
                highlight: "(신뢰해서 / 믿지 못해서)",
                options: ["신뢰해서", "믿지 못해서"],
                correct: 1
            },
            {
                id: 46,
                text: "요즘 카페나 음식점에서 '10.0' (10,000원), '5.5' (5,500원)처럼 가격을 표시하는 걸 _____ ?",
                highlight: "(본 적 없나요 / 본 적 있나요)",
                options: ["본 적 없나요", "본 적 있나요"],
                correct: 1
            },
            {
                id: 47,
                text: "이것도 일종의 리디노미네이션 표기인데, 사실 우리 _____ 속이는 아주 재미있는 심리 전략이랍니다.",
                highlight: "(뇌를 / 몸을)",
                options: ["뇌를", "몸을"],
                correct: 0
            },
            {
                id: 48,
                text: "이것도 일종의 리디노미네이션 표기인데, 사실 우리 뇌를 속이는 아주 재미있는 _____ 전략이랍니다.",
                highlight: "(심리 / 물리)",
                options: ["심리", "물리"],
                correct: 0
            },
            {
                id: 49,
                text: "_____ '이중 정보 처리 이론'이라는 게 있어요.",
                highlight: "(심리학에는 / 경제학에는)",
                options: ["심리학에는", "경제학에는"],
                correct: 0
            },
            {
                id: 50,
                text: "우리 머릿속에는 _____ 의 일꾼이 살고 있다고 생각하면 쉬워요.",
                highlight: "(한 명 / 두 명)",
                options: ["한 명", "두 명"],
                correct: 1
            },
            {
                id: 51,
                text: "빠른 직관은 아무 생각 없이 _____ 빠르게 결정하는 일꾼이에요.",
                highlight: "(본능적으로 / 이성적으로)",
                options: ["본능적으로", "이성적으로"],
                correct: 0
            },
            {
                id: 52,
                text: "\"어, 이거 _____ !\" 하고 바로 반응하죠.",
                highlight: "(싸다 / 비싸다)",
                options: ["싸다", "비싸다"],
                correct: 0
            },
            {
                id: 53,
                text: "힘이 별로 _____ 편하지만, 가끔 실수도 해요.",
                highlight: "(안 들어서 / 많이 들어서)",
                options: ["안 들어서", "많이 들어서"],
                correct: 0
            },
            {
                id: 54,
                text: "힘이 별로 안 들어서 편하지만, 가끔 _____ .",
                highlight: "(절대 실수 안 해요 / 실수도 해요)",
                options: ["절대 실수 안 해요", "실수도 해요"],
                correct: 1
            },
            {
                id: 55,
                text: "느린 이성은 아주 _____ 꼼꼼하게 따져보는 일꾼이에요.",
                highlight: "(신중하고 / 충동적이고)",
                options: ["신중하고", "충동적이고"],
                correct: 0
            },
            {
                id: 56,
                text: "\"이게 정말 싼 게 맞을까?\" 하고 _____ 생각하죠.",
                highlight: "(천천히 / 빨리)",
                options: ["천천히", "빨리"],
                correct: 0
            },
            {
                id: 57,
                text: "_____ 머리를 많이 써야 해서 피곤해요.",
                highlight: "(정확하지만 / 부정확하지만)",
                options: ["정확하지만", "부정확하지만"],
                correct: 0
            },
            {
                id: 58,
                text: "우리는 보통 피곤한 걸 _____ 대부분의 일을 '빠른 직관'에게 맡겨요.",
                highlight: "(싫어해서 / 좋아해서)",
                options: ["싫어해서", "좋아해서"],
                correct: 0
            },
            {
                id: 59,
                text: "우리는 보통 피곤한 걸 싫어해서 대부분의 일을 ' _____ '에게 맡겨요.",
                highlight: "'(빠른 직관 / 느린 이성)'",
                options: ["빠른 직관", "느린 이성"],
                correct: 0
            },
            {
                id: 60,
                text: "가게 주인들은 바로 이 점을 _____ 거예요!",
                highlight: "(이용하는 / 무시하는)",
                options: ["이용하는", "무시하는"],
                correct: 0
            },
            {
                id: 61,
                text: "'10,000원'이라고 쓰인 걸 보면 ' _____ '이 \"음, 만 원이군.\" 하고 생각하지만,",
                highlight: "'(느린 이성 / 빠른 직관)'",
                options: ["느린 이성", "빠른 직관"],
                correct: 0
            },
            {
                id: 62,
                text: "'10.0'이라고 쓰인 걸 보면 '빠른 직관'이 \"어? 숫자 10이네? _____ !\" 하고 순간적으로 착각하게 만드는 거죠.",
                highlight: "어? 숫자 10이네? (싸다 / 비싸다)",
                options: ["싸다", "비싸다"],
                correct: 0
            },
            {
                id: 63,
                text: "순간적으로 _____ 만드는 거죠.",
                highlight: "(착각하게 / 이해하게)",
                options: ["착각하게", "이해하게"],
                correct: 0
            },
            {
                id: 64,
                text: "숫자의 자릿수를 _____ 표기 방식은 우리의 인지적 부담을 덜어주어 '빠른 직관'을 더 활발하게 만들고,",
                highlight: "(줄이는 / 늘리는)",
                options: ["줄이는", "늘리는"],
                correct: 0
            },
            {
                id: 65,
                text: "숫자의 자릿수를 줄이는 표기 방식은 우리의 인지적 부담을 _____ '빠른 직관'을 더 활발하게 만들고,",
                highlight: "(덜어주어 / 더해주어)",
                options: ["덜어주어", "더해주어"],
                correct: 0
            },
            {
                id: 66,
                text: "'빠른 직관'을 더 _____ 만들고,",
                highlight: "(활발하게 / 둔하게)",
                options: ["활발하게", "둔하게"],
                correct: 0
            },
            {
                id: 67,
                text: "그 결과 소비자는 실제 가치와는 무관하게 표시된 숫자가 작다는 이유만으로 상품이 _____ 판단할 확률이 높아져 쉽게 지갑을 열게 될 수 있답니다.",
                highlight: "상품이 (저렴하다고 / 비싸다고) 판단할 확률이 높아져",
                options: ["저렴하다고", "비싸다고"],
                correct: 0
            }
        ];

        // 0단계 전용 변수 (지문 독해 사고 과정 가이드)
        let stage0Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 문장 독해 데이터
        const sentenceData = [
            // 문장 1 - 정의된 개념 바꿔 읽기
            {
                sentence: "리디노미네이션은 통용되는 모든 지폐나 동전에 대한 **실질 가치는 그대로 둔 채 액면을 특정 비율을 적용하여 낮은 숫자로 변경**하거나 그와 더불어 새로운 화폐 단위를 지정하는 방법을 통해 실행된다.",
                question: "위 문장에서 정의된 '리디노미네이션'의 개념을 더 쉬운 말로 바꾸어 완성하세요: 즉, 국가 차원의 리디노미네이션은 ____________는 것이다.",
                correctAnswer: "돈의 실제 가치는 유지하면서 화폐 단위(액면가)만 낮추는 것",
                distractors: ["화폐의 실질 가치를 변화시키면서 액면가도 함께 조정하는 것", "새로운 화폐를 만들어서 경제 시스템 전체를 활성화시키는 것", "물가 안정을 위해 화폐 단위를 완전히 새롭게 바꾸는 것"]
            },
            // 문장 2 - 가리키는 말(대용 표현) 바꿔 읽기
            {
                sentence: "...화폐의 자릿수를 줄여 국제 무역에서 편의를 도모해야 하며 **그것**이 자국 통화의 대외적 위상을 제고하는 일이라는 의견도 있다.",
                question: "'그것'이 가리키는 내용을 문장 안에서 찾아 완성하세요: 즉, ____________이/가 자국 통화의 위상을 높이는 일이라는 의미이다.",
                correctAnswer: "화폐의 자릿수를 줄여 국제 무역에서 편의를 도모하는 것",
                distractors: ["자국 통화의 대외적 위상을 높여서 경제 발전을 이루는 것", "국제 무역에서 발생하는 손해를 최소화하고 이익을 보는 것", "다른 선진국의 화폐 제도를 참고하여 따라하는 것"]
            },
            // 문장 3 - 서술어 중심 호응 찾기 / 숨은 말 찾아 읽기
            {
                sentence: "국가 차원의 리디노미네이션이 실행되면 모든 상점에서 화폐의 자릿수를 줄여 표기하게 되므로 계산과 지급상의 편의가 확보된다는 장점이 있지만, 새로운 화폐에 대한 제작 비용과 더불어 화폐 관련 기계나 프로그램 등을 교체하고 수정하는 데 들어갈 사회적 비용도 고려해야 한다.",
                question: "위 문장의 핵심 구조를 파악하고, 생략된 주어를 찾아 완성하세요: (누가?) ________은/는 리디노미네이션의 장점뿐만 아니라 사회적 비용이라는 단점도 (어찌해야 한다?) ________.",
                correctAnswer: "정부(또는 국가) / 신중하게 검토하거나 고려해야 한다",
                distractors: ["국민(또는 소비자) / 인내심을 가지고 부담해야 한다", "은행(또는 금융기관) / 정확하게 계산하고 준비해야 한다", "상점 주인(또는 상인) / 미리 충분히 준비해야 한다"]
            },
            // 문장 4 - 관계/공식에 숫자 넣어 읽기
            {
                sentence: "원화 단위를 그대로 유지하는 1,000분의 1 리디노미네이션이 우리나라에서 실행된다면 상인은 기존의 19,000원짜리 물건을 19원이 아니라 20원으로 올려서 판매할 가능성이 크다.",
                question: "위 문장의 관계를 바탕으로 완성하세요: 만약 3,800원짜리 음료수가 있다면, 리디노미네이션 이후 상인은 ____원이 아니라 ____원으로 가격을 매길 것이다. 소비자가 느끼는 인상액은 ____원이지만, 실제로는 ____원이 오른 셈이다.",
                correctAnswer: "3.8원 / 4.0원 / 0.2원 / 200원",
                distractors: ["3.8원 / 3.9원 / 0.1원 / 100원 (반올림 최소화)", "38원 / 40원 / 2원 / 2,000원 (1/100 단위)", "3.8원 / 5.0원 / 1.2원 / 1,200원 (과도한 인상)"]
            },
            // 문장 5 - 설명과 예시 짝지어 읽기
            {
                sentence: "심리학자 에플리와 길로비치는 유사한 사례로 여행지에서 외화로 제품을 구매하는 경우 사람들은 정확한 환율 계산을 통해 구매를 결정하기보다는 표기된 액면가를 확인하고는 그것을 기준으로 삼아 불완전한 어림짐작으로 구매를 결정하는 경향이 있다는 연구 결과를 발표했다.",
                question: "위 문장의 예시가 설명하는 일반적인 원리를 완성하세요: **[일반적 원리]** 인간은 ____________과 같은 어려운 상황에 직면하면, 정확한 계산(느린 이성)보다 불완전하더라도 즉각적인 판단(빠른 직관)에 의존하려는 경향이 있다.",
                correctAnswer: "복잡한 환율 계산이나 시간 제약",
                distractors: ["충분한 정보가 제공되고 검토할 시간이 있는 상황", "익숙하고 편안하여 신중하게 생각할 수 있는 환경", "천천히 생각할 수 있는 시간적 여유가 충분한 상황"]
            }
        ];

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage0: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            if (currentStage === 0) {
                // Stage 0 초기화 (지문 독해 사고 과정 가이드)
                stage0Data.startTime = Date.now();
                timeRemaining = stage0Data.timeRemaining;
                maxTime = stage0Data.maxTime;

                // 헤더 업데이트
                document.querySelector('.subtitle').textContent = '0단계: 지문 독해 사고 과정 가이드';

                renderPassage();
                updateQuestionCounter();
                updateTimerBar();
                startTimer();
                setupModalDrag();
            } else if (currentStage === 1) {
                // Stage 1 초기화
                stage1Data.startTime = Date.now();
                timeRemaining = stage1Data.timeRemaining;
                maxTime = stage1Data.maxTime;

                renderPassage();
                updateQuestionCounter();
                updateTimerBar();
                startTimer();
                setupModalDrag();
            }
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html;
            let currentQuestions;

            // Stage에 따라 다른 텍스트와 질문 배열 사용
            if (currentStage === 0) {
                html = stage0OriginalText;
                currentQuestions = learningData.questions;
            } else if (currentStage === 1) {
                html = learningData.fullText;
                currentQuestions = stage1Questions;
            } else {
                html = learningData.fullText; // 기본값
                currentQuestions = learningData.questions;
            }

            // Stage 1의 경우 섹션별로 하이라이트 처리
            if (currentStage === 1) {
                // fullText를 두 섹션으로 분리
                const section1Marker = '## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**';
                const section2Marker = '## **2️⃣ 지문 라이트 버전 / 작품 미리보기 📝**';

                const section2Start = html.indexOf(section2Marker);
                let section1Html = html.substring(0, section2Start);
                let section2Html = html.substring(section2Start);

                // 섹션 1 (딥리서치): 1-19번 문제만 하이라이트
                for (let i = 0; i < 19 && i < stage1Questions.length; i++) {
                    const q = stage1Questions[i];
                    const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escapedHighlight);
                    const highlightHTML = `<span class="highlight" data-question="${i}">${q.highlight}</span>`;
                    section1Html = section1Html.replace(regex, highlightHTML);
                }

                // 섹션 2 (라이트 버전): 20-67번 문제만 하이라이트
                for (let i = 19; i < stage1Questions.length; i++) {
                    const q = stage1Questions[i];
                    const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escapedHighlight);
                    const highlightHTML = `<span class="highlight" data-question="${i}">${q.highlight}</span>`;
                    section2Html = section2Html.replace(regex, highlightHTML);
                }

                // 두 섹션 합치기
                html = section1Html + section2Html;
            } else {
                // 다른 Stage는 기존 방식대로
                currentQuestions.forEach((q, index) => {
                    const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escapedHighlight);
                    const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                    html = html.replace(regex, highlightHTML);
                });
            }

            // 마크다운 처리
            // ## 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2 style="margin-top: 30px; margin-bottom: 15px; font-size: 1.5em; color: #2c3e50;">$1</h2>');

            // ### 제목 처리
            html = html.replace(/^###\s+(.+)$/gm, '<h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.3em; color: #34495e;">$1</h3>');

            // ■ 제목 처리
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (간단한 마크다운 테이블)
            html = html.replace(/\|(.+)\|/g, function(match) {
                // 테이블 헤더 구분선 (| :---- | :---- |)
                if (match.includes(':----')) {
                    return '<tr style="border-bottom: 2px solid #ddd;"></tr>';
                }
                // 일반 테이블 행
                const cells = match.split('|').filter(cell => cell.trim());
                const cellTags = cells.map(cell => `<td style="padding: 8px; border: 1px solid #ddd;">${cell.trim()}</td>`).join('');
                return `<tr>${cellTags}</tr>`;
            });

            // 테이블을 <table> 태그로 감싸기
            html = html.replace(/(<tr>[\s\S]*?<\/tr>)/g, function(match) {
                if (!match.includes('<table')) {
                    return '<table style="width: 100%; border-collapse: collapse; margin: 20px 0;">' + match + '</table>';
                }
                return match;
            });

            // 볼드 처리 (하이라이트 span 태그 내부는 제외)
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+)$/gm, function(match, num, text) {
                if (match.includes('<span class="highlight"')) return match; // 이미 하이라이트 처리된 것은 건드리지 않음
                if (match.includes('<h')) return match; // 이미 제목 태그면 건드리지 않음
                return `<div style="margin-top: 15px; margin-bottom: 10px;"><strong>${num}. ${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                if (match.includes('<span class="highlight"')) return match;
                return `<div class="subsection" style="margin-left: 20px; margin-top: 5px;">• ${content}</div>`;
            });

            // <br> 태그 처리는 이미 HTML이므로 그대로 둠

            // 줄바꿈 처리
            html = html.replace(/\n\n/g, '<br><br>');

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음 (현재 Stage에 따라 다른 데이터 확인)
            if (currentStage === 0) {
                if (stage0Data.answeredQuestions.has(index)) return;
            } else if (currentStage === 1) {
                if (stage1Data.answeredQuestions.has(index)) return;
            }

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            // Stage에 따라 적절한 questions 배열 선택
            const currentQuestions = (currentStage === 0) ? learningData.questions : stage1Questions;
            const question = currentQuestions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            // 현재 Stage에 따라 다른 데이터 사용
            const currentData = (currentStage === 0) ? stage0Data : stage1Data;

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                currentData.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                currentData.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            currentData.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (currentData.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 0) {
                    stage0Data.timeRemaining = timeRemaining;
                } else if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 0) {
                        completeStage();
                    } else if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 0) {
                stage0Data.timeRemaining = timeRemaining;
            } else if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 0) {
                stage0Data.timeRemaining = timeRemaining;
            } else if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 0) {
                document.getElementById('current-question').textContent = stage0Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = stage1Questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            // 모달 닫기
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('active');
            }

            const endTime = Date.now();
            let elapsedTime, totalAnswered, progress, accuracy, correctAnswers, wrongAnswers, stageTitle, stageName;

            if (currentStage === 0) {
                elapsedTime = Math.floor((endTime - stage0Data.startTime) / 1000);
                totalAnswered = stage0Data.correctAnswers + stage0Data.wrongAnswers;
                progress = Math.round((stage0Data.answeredQuestions.size / learningData.questions.length) * 100);
                accuracy = totalAnswered > 0 ? Math.round((stage0Data.correctAnswers / totalAnswered) * 100) : 0;
                correctAnswers = stage0Data.correctAnswers;
                wrongAnswers = stage0Data.wrongAnswers;
                stageTitle = '0단계 학습 완료!';
                stageName = '지문 독해 사고 과정 가이드';

                // 결과 저장
                const score = (accuracy / 100) * 10;
                stageResults.stage0 = {
                    correct: correctAnswers,
                    wrong: wrongAnswers,
                    score: score,
                    elapsedTime: elapsedTime,
                    wrongQuestions: []
                };
            } else if (currentStage === 1) {
                elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);
                totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
                progress = Math.round((stage1Data.answeredQuestions.size / stage1Questions.length) * 100);
                accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;
                correctAnswers = stage1Data.correctAnswers;
                wrongAnswers = stage1Data.wrongAnswers;
                stageTitle = '1단계 학습 완료!';
                stageName = '딥리서치';

                // 결과 저장
                const score = (accuracy / 100) * 10;
                stageResults.stage1 = {
                    correct: correctAnswers,
                    wrong: wrongAnswers,
                    score: score,
                    elapsedTime: elapsedTime,
                    wrongQuestions: []
                };
            }

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = stageTitle;

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = correctAnswers;
            document.getElementById('wrong-stat').textContent = wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                // Stage에 따라 총 질문 개수 결정
                const totalQuestions = (currentStage === 0) ? learningData.questions.length : stage1Questions.length;

                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: currentStage,
                    stageName: stageName,
                    accuracy: accuracy,
                    correctAnswers: correctAnswers,
                    wrongAnswers: wrongAnswers,
                    totalQuestions: totalQuestions,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            currentStage++;

            if (currentStage === 1) {
                // 1단계: 딥리서치 - Stage 0에서 사용한 것과 동일한 하이라이트 질문 방식
                // 이전 타이머 정리
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }

                // Stage 1 데이터 초기화
                stage1Data.currentQuestionIndex = 0;
                stage1Data.answeredQuestions.clear();
                stage1Data.correctAnswers = 0;
                stage1Data.wrongAnswers = 0;
                stage1Data.startTime = Date.now();
                stage1Data.timeRemaining = 180;

                // 타이머 설정
                timeRemaining = 180;
                maxTime = 180;

                // UI 업데이트
                document.getElementById('result-screen').classList.remove('active');
                document.getElementById('main-content').style.display = 'block';
                document.querySelector('.subtitle').textContent = '1단계: 딥리서치';

                // Stage 1 렌더링 및 시작
                renderPassage();
                updateQuestionCounter();
                updateTimerBar();
                startTimer();
                setupModalDrag();
            } else if (currentStage === 2) {
                initStage2();
            } else if (currentStage === 3) {
                initStage3();
            } else if (currentStage === 4) {
                initStage4();
            } else if (currentStage === 5) {
                initStage5();
            }
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // 단어 → 뜻 문제
                const wordToMeaning = {
                    type: 'word-to-meaning',
                    question: `"${vocab.word}"의 의미는?`,
                    correct: vocab.meaning,
                    word: vocab.word,
                    options: shuffleArray([
                        vocab.meaning,
                        ...vocab.confusors.meaning.slice(0, 3)
                    ])
                };

                // 뜻 → 단어 문제
                const meaningToWord = {
                    type: 'meaning-to-word',
                    question: `"${vocab.meaning}"를 나타내는 용어는?`,
                    correct: vocab.word,
                    meaning: vocab.meaning,
                    options: shuffleArray([
                        vocab.word,
                        ...vocab.confusors.word.slice(0, 3)
                    ])
                };

                stage2Data.questions.push(wordToMeaning, meaningToWord);
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            // 모달 닫기
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('active');
            }

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 마크다운 처리 함수
            function processMarkdown(text) {
                let html = text;
                // 볼드 처리
                html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                // 이탤릭 처리
                html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                // 줄바꿈 처리
                html = html.replace(/\n/g, '<br>');
                return html;
            }

            // 문장과 질문 표시 (마크다운 렌더링)
            document.getElementById('sentence-text').innerHTML = processMarkdown(question.sentence);
            document.getElementById('sentence-question').innerHTML = processMarkdown(`Q. ${question.question}`);

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            // 모달 닫기
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('active');
            }

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }

        // ================== 4단계: OX퀴즈 ==================
        const stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],  // 틀린 문제 저장
            startTime: null,
            timeRemaining: 120
        };

        // OX퀴즈 데이터
        const oxQuizData = [
            { question: "리디노미네이션은 화폐의 실질 가치를 변경하여 액면가를 조정하는 화폐 개혁이다.", answer: false, explanation: "실질 가치는 '그대로 둔 채' 액면가만 변경하는 것이 리디노미네이션입니다." },
            { question: "리디노미네이션을 실행하면 기업의 장부 기재상 편의를 줄일 수 있다.", answer: false, explanation: "편의를 '확보'하거나 '증대'시킬 수 있습니다. 줄이는 것이 아닙니다." },
            { question: "우리나라는 1962년 이후 지속적인 경제 성장으로 물가가 꾸준히 상승해 왔다.", answer: true, explanation: "" },
            { question: "국가 차원의 리디노미네이션은 자국 통화의 대외적 위상을 떨어뜨릴 수 있다는 우려가 있다.", answer: false, explanation: "위상을 '제고'(높임)하는 효과를 기대할 수 있다는 의견이 있습니다." },
            { question: "리디노미네이션의 장점 중 하나는 계산과 지급상의 편의가 확보된다는 점이다.", answer: true, explanation: "" },
            { question: "화폐 관련 프로그램을 수정하는 비용은 리디노미네이션의 사회적 비용에 포함되지 않는다.", answer: false, explanation: "화폐 제작, 기계 및 프로그램 교체 등 모두 사회적 비용에 포함됩니다." },
            { question: "리디노미네이션 실행 시 발생할 수 있는 물가 상승 현상을 인플레이션이라고 한다.", answer: true, explanation: "" },
            { question: "소비자들은 리디노미네이션 이후의 소액 인상에 대해 민감하게 반응할 것으로 예상된다.", answer: false, explanation: "소비자는 소액 인상에 대해 '관대한' 입장을 보일 가능성이 큽니다." },
            { question: "물가 상승으로 인한 불안은 화폐 가치의 불확실성을 키워 실물 자산에 대한 수요를 높일 수 있다.", answer: true, explanation: "" },
            { question: "일부 소매점의 리디노미네이션 표기는 상품의 실제 경제적 가치에 영향을 주기 위한 것이다.", answer: false, explanation: "실제 가치에는 영향을 주지 않으면서 소비자의 '심리적 효과'를 극대화하려는 목적입니다." },
            { question: "이중 정보 처리 이론은 인간의 사고 체계를 '빠른 직관'과 '느린 이성'으로 구분한다.", answer: true, explanation: "" },
            { question: "'빠른 직관'은 심사숙고하는 사고 체계로, 판단의 오류를 최소화할 수 있다.", answer: false, explanation: "그것은 '느린 이성'의 특징입니다. '빠른 직관'은 무의식적으로 빠르게 반응합니다." },
            { question: "'느린 이성'은 무의식과 직관에 의해 작동하며 인지적 부담을 줄여 준다.", answer: false, explanation: "그것은 '빠른 직관'의 특징입니다. '느린 이성'은 의식적이고 인지적 노력이 필요합니다." },
            { question: "인간은 정보 처리 능력이 무한하므로 두 사고 체계를 경쟁적으로 사용한다.", answer: false, explanation: "정보 처리 능력에 '한계'가 있으므로 두 체계의 '협응'을 통해 효율적으로 처리합니다." },
            { question: "'빠른 직관'은 인지 과정의 수고를 줄이지만 종종 부정확한 판단을 내리기도 한다.", answer: true, explanation: "" },
            { question: "인간은 반응 속도가 느린 '느린 이성'을 일상 속에서 주로 활성화하고자 한다.", answer: false, explanation: "반응 속도가 빠른 '빠른 직관'을 주로 활성화하여 인지 과정의 수고를 줄이려 합니다." },
            { question: "복잡한 계산에 직면한 상황에서는 '느린 이성'에 의존하는 경향이 강화된다.", answer: false, explanation: "어려운 상황에서는 오히려 '빠른 직관'에 의존하는 경향이 강화됩니다." },
            { question: "여행지에서 액면가 기준으로 어림짐작하여 물건을 사는 것은 '느린 이성'이 작동한 결과이다.", answer: false, explanation: "정확한 환율 계산 대신 불완전한 어림짐작을 하는 것은 '빠른 직관'의 작동입니다." },
            { question: "리디노미네이션 표기 방식은 소비자가 가격 정보를 처리할 때 '느린 이성'의 영향을 강화한다.", answer: false, explanation: "인지적 부담을 덜어주어 '빠른 직관'의 영향을 강화시킵니다." },
            { question: "자릿수가 감소된 가격 표기는 소비자에게 상품이 실제보다 저렴하다고 여기게 만들 수 있다.", answer: true, explanation: "" }
        ];

        // 4단계 초기화
        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '리디노미네이션';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 4';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 리디노미네이션 원문 표시
            const originalText = stage0OriginalText;

            

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            // 모달 닫기
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('active');
            }

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
            {
                id: 1,
                question: "[조건형] 국가 차원의 리디노미네이션이 실행될 경우, '인플레이션'이 발생할 수 있는 원인을 상인의 판매 방식과 소비자의 심리적 반응을 중심으로 서술하시오.",
                correctAnswer: "리디노미네이션 실행 시, 상인들은 1,900원을 1.9원이 아닌 2.0원으로 올림(Rounding)하여 가격을 책정할 가능성이 크다. 소비자는 0.1원(실제 100원)의 인상에 대해 관대한 입장을 보여 쉽게 수용하게 되고, 이러한 가격 인상이 여러 상품에서 누적되면 전반적인 물가가 상승하는 인플레이션이 발생할 수 있다.",
                correctParts: ["리디노미네이션 실행 시, 상인들은 1,900원을 1.9원이 아닌 2.0원으로 올림(Rounding)하여 가격을 책정할 가능성이 크다.", "소비자는 0.1원(실제 100원)의 인상에 대해 관대한 입장을 보여 쉽게 수용하게 되고,", "이러한 가격 인상이 여러 상품에서 누적되면 전반적인 물가가 상승하는 인플레이션이 발생할 수 있다."],
                distractors: ["리디노미네이션 실행 시에는 화폐 단위 변경으로 인해 오히려 물가가 하락하는 경향이 나타나며, 상인들도 가격을 낮추려는 경쟁이 발생하여 디플레이션이 우려된다.", "소비자는 화폐 단위가 바뀌더라도 모든 가격 변화에 대해 매우 민감하게 반응하며, 0.1원의 인상도 즉시 감지하여 구매를 거부하므로 가격 인상이 불가능하다.", "상인들은 리디노미네이션 실행 시 사회적 책임감을 느껴서 1,900원을 2.0원이 아닌 1.9원으로 정확히 책정하며, 오히려 가격을 내리는 경향을 보인다."]
            },
            {
                id: 2,
                question: "[비교형] '이중 정보 처리 이론'에 제시된 '빠른 직관'과 '느린 이성'의 특징을 정보 처리 방식, 인지적 부담, 판단의 정확성이라는 세 가지 기준을 모두 사용하여 비교하여 서술하시오.",
                correctAnswer: "'빠른 직관'은 무의식적으로 빠르게 반응하는 정보 처리 방식으로, 인지적 부담이 적지만 종종 부정확한 판단을 내릴 수 있다. 반면 '느린 이성'은 의식적으로 심사숙고하는 정보 처리 방식으로, 인지적 노력이 필요하고 시간이 걸리지만 판단의 오류를 최소화할 수 있다.",
                correctParts: ["'빠른 직관'은 무의식적으로 빠르게 반응하는 정보 처리 방식으로, 인지적 부담이 적지만 종종 부정확한 판단을 내릴 수 있다.", "반면 '느린 이성'은 의식적으로 심사숙고하는 정보 처리 방식으로,", "인지적 노력이 필요하고 시간이 걸리지만 판단의 오류를 최소화할 수 있다."],
                distractors: ["'빠른 직관'은 의식적으로 천천히 정보를 처리하는 방식으로, 인지적 노력이 많이 필요하지만 항상 정확한 판단을 내릴 수 있어 신뢰할 수 있는 체계이다.", "'느린 이성'은 무의식적으로 즉각적인 반응을 보이는 정보 처리 방식으로, 인지적 부담이 전혀 없으며 빠르고 부정확한 판단을 내리는 특징을 가진다.", "두 체계는 정보 처리 방식, 인지적 부담, 판단의 정확성 측면에서 완전히 동일한 특징을 가지며, 실제로는 구분할 수 없는 하나의 통합된 체계로 작동한다."]
            },
            {
                id: 3,
                question: "[사례 적용 <보기>형] <보기>의 상황을 윗글의 '이중 정보 처리 이론'을 바탕으로 분석하여, B가 A의 제안을 받아들일 가능성이 높은 이유를 서술하시오.\n\n<보기> A와 B는 중고 물품 거래 앱으로 스피커를 판매하려고 한다. A는 B에게 \"가격을 '2만 5천 원'이라고 올리는 것보다 '25.0'이라고 올리는 게 더 잘 팔릴 거야.\"라고 조언했다.",
                correctAnswer: "자릿수를 줄인 가격 표기('25.0')는 소비자의 인지적 부담을 덜어주어 '빠른 직관'을 더 활발하게 작동시킨다. 소비자는 표시된 숫자가 작다는 이유만으로 실제 가치와 무관하게 상품이 저렴하다고 판단할 가능성이 높아지므로, B가 이 제안을 받아들일 가능성이 높다.",
                correctParts: ["자릿수를 줄인 가격 표기('25.0')는 소비자의 인지적 부담을 덜어주어 '빠른 직관'을 더 활발하게 작동시킨다.", "소비자는 표시된 숫자가 작다는 이유만으로 실제 가치와 무관하게 상품이 저렴하다고 판단할 가능성이 높아지므로,", "B가 이 제안을 받아들일 가능성이 높다."],
                distractors: ["가격 표기 방식은 소비자의 구매 결정과 판매 성과에 전혀 영향을 주지 않으며, '2만 5천 원'이든 '25.0'이든 동일한 판매 효과를 가져오므로 B는 제안을 받아들이지 않을 것이다.", "소비자는 중고 물품을 구매할 때 가격 표기와 무관하게 항상 정확한 시장 가치를 계산하고 비교하므로, 자릿수를 줄인 표기는 아무런 효과가 없어 B가 제안을 거부할 것이다.", "중고 거래에서는 '느린 이성'이 주로 작동하여 소비자가 가격을 정확히 비교 분석하므로, 숫자 표기 방식의 차이는 구매 결정에 영향을 미치지 않아 B가 수용하지 않을 것이다."]
            },
            {
                id: 4,
                question: "[논리 사고력] 윗글에서 설명하는, '물가 상승'이 '실물 자산에 대한 수요 증가'로 이어지는 과정을 단계적으로 서술하시오.",
                correctAnswer: "리디노미네이션으로 인한 올림 현상이 발생하면 전반적인 물가가 상승(인플레이션)한다. 물가 상승은 화폐 가치에 대한 불확실성을 키우고, 사람들은 화폐보다 안정적인 가치를 지닌 부동산과 같은 실물 자산에 대한 수요를 높이게 된다.",
                correctParts: ["리디노미네이션으로 인한 올림 현상이 발생하면 전반적인 물가가 상승(인플레이션)한다.", "물가 상승은 화폐 가치에 대한 불확실성을 키우고,", "사람들은 화폐보다 안정적인 가치를 지닌 부동산과 같은 실물 자산에 대한 수요를 높이게 된다."],
                distractors: ["리디노미네이션 실행 시 물가가 하락하는 디플레이션이 발생하면, 화폐 가치가 상승하여 사람들은 실물 자산 대신 화폐를 보유하려 하므로 실물 자산 수요가 오히려 증가한다.", "화폐 가치가 매우 안정되고 물가 변동이 없는 상황에서 사람들은 불확실성을 느끼게 되어, 안정적인 화폐 대신 변동성이 큰 실물 자산을 적극적으로 찾게 된다.", "물가 상승과 실물 자산에 대한 수요는 서로 완전히 독립적인 별개의 경제 현상이므로, 인플레이션이 발생하더라도 부동산 같은 자산의 수요와는 아무런 관련이 없다."]
            },
            {
                id: 5,
                question: "[조건형] 일부 소매점에서 가격을 '10.0'과 같이 표기하는 목적은 무엇이며, 이러한 표기 방식이 소비자의 의사 결정에 어떤 영향을 미치는지 '빠른 직관'의 개념을 활용하여 서술하시오.",
                correctAnswer: "소매점이 '10.0'으로 표기하는 목적은 실제 가치에 영향을 주지 않으면서 소비자의 심리적 효과를 극대화하기 위함이다. 자릿수가 줄어든 가격 표기는 소비자의 인지적 부담을 덜어주어 '빠른 직관'의 영향을 강화시키고, 소비자는 표시된 숫자가 작다는 이유만으로 상품이 저렴하다고 판단하여 구매할 가능성이 높아진다.",
                correctParts: ["소매점이 '10.0'으로 표기하는 목적은 실제 가치에 영향을 주지 않으면서 소비자의 심리적 효과를 극대화하기 위함이다.", "자릿수가 줄어든 가격 표기는 소비자의 인지적 부담을 덜어주어 '빠른 직관'의 영향을 강화시키고,", "소비자는 표시된 숫자가 작다는 이유만으로 상품이 저렴하다고 판단하여 구매할 가능성이 높아진다."],
                distractors: ["소매점의 가격 표기 방식은 소비자의 구매 판단이나 의사 결정 과정에 전혀 영향을 주지 않으며, '10.0'이든 '10,000원'이든 소비자는 동일하게 인식하여 구매 행동에 차이가 없다.", "소비자는 가격을 볼 때 표기 방식과 무관하게 항상 정확한 가격 계산을 수행하므로, 자릿수를 줄인 표기는 의미가 없고 오히려 혼란만 가중시켜 판매에 부정적 영향을 미친다.", "가격을 '10.0'으로 표기하면 소비자의 '느린 이성'이 더욱 강화되어 더 신중하고 합리적인 판단을 하게 되므로, 충동구매가 감소하고 매출이 오히려 하락한다."]
            },
            {
                id: 6,
                question: "[추론형] 윗글의 내용으로 미루어 볼 때, 정부가 성공적인 리디노미네이션을 추진하기 위해 경제적 측면 외에 반드시 고려해야 할 점은 무엇일지 소비자의 정보 처리 특성과 관련지어 서술하시오.",
                correctAnswer: "정부는 소비자가 '빠른 직관'에 의존하여 가격을 부정확하게 인식하는 경향이 있음을 고려해야 한다. 리디노미네이션 실행 시 소비자 교육을 통해 '느린 이성'을 활성화시켜 정확한 가치 판단을 할 수 있도록 유도하고, 상인들의 부당한 가격 인상(올림 현상)을 방지하는 제도적 장치를 마련해야 한다.",
                correctParts: ["정부는 소비자가 '빠른 직관'에 의존하여 가격을 부정확하게 인식하는 경향이 있음을 고려해야 한다.", "리디노미네이션 실행 시 소비자 교육을 통해 '느린 이성'을 활성화시켜 정확한 가치 판단을 할 수 있도록 유도하고,", "상인들의 부당한 가격 인상(올림 현상)을 방지하는 제도적 장치를 마련해야 한다."],
                distractors: ["정부는 경제적 측면인 화폐 제작 비용과 기계 교체 비용만 충분히 고려하면 되며, 소비자의 심리적 요인이나 정보 처리 방식은 리디노미네이션 성공과 무관하므로 고려할 필요가 없다.", "소비자 심리와 정보 처리 특성은 개인차가 크고 예측 불가능하므로 정책 수립 시 중요하지 않으며, 오직 제도적 경제적 측면만 집중하면 성공적인 리디노미네이션이 가능하다.", "리디노미네이션 실행 시 소비자의 '빠른 직관'이나 '느린 이성' 같은 정보 처리 특성은 무시해도 되며, 단순히 법률로 가격 표시를 강제하면 모든 문제가 해결된다."]
            },
            {
                id: 7,
                question: "[구조 독해력] 이 글은 크게 '국가 차원의 리디노미네이션'과 '소매점의 리디노미네이션 표기'라는 두 부분으로 나눌 수 있습니다. 글쓴이가 이 두 가지 현상을 연결하여 설명하기 위해 '이중 정보 처리 이론'을 활용한 이유가 무엇인지 서술하시오.",
                correctAnswer: "글쓴이는 두 현상 모두 소비자의 정보 처리 방식, 특히 '빠른 직관'에 의존하는 경향 때문에 발생한다는 공통점을 설명하기 위해 '이중 정보 처리 이론'을 활용했다. 이 이론을 통해 국가의 리디노미네이션이든 소매점의 가격 표기든, 자릿수가 줄어든 숫자는 인지적 부담을 덜어주고 빠른 직관을 활성화시켜 소비자가 실제 가치와 다르게 판단하게 만드는 공통된 기제를 설명할 수 있다.",
                correctParts: ["글쓴이는 두 현상 모두 소비자의 정보 처리 방식, 특히 '빠른 직관'에 의존하는 경향 때문에 발생한다는 공통점을 설명하기 위해 '이중 정보 처리 이론'을 활용했다.", "이 이론을 통해 국가의 리디노미네이션이든 소매점의 가격 표기든,", "자릿수가 줄어든 숫자는 인지적 부담을 덜어주고 빠른 직관을 활성화시켜 소비자가 실제 가치와 다르게 판단하게 만드는 공통된 기제를 설명할 수 있다."],
                distractors: ["국가 차원의 리디노미네이션과 소매점의 가격 표기는 완전히 다른 원리로 작동하는 별개의 현상이므로, 이중 정보 처리 이론은 이 둘을 연결하는 데 적합하지 않고 각각 독립적으로 설명해야 한다.", "'이중 정보 처리 이론'은 소매점의 가격 표기라는 한 가지 현상만 설명할 수 있는 제한적인 이론이므로, 국가 차원의 리디노미네이션까지 포괄하여 설명하려는 시도는 이론의 적용 범위를 벗어난다.", "글쓴이는 두 현상을 의도적으로 연결하려는 시도 없이 단순히 나열했을 뿐이며, 이중 정보 처리 이론은 부수적으로 언급된 것에 불과하여 두 현상의 연결과는 무관하다."]
            },
            {
                id: 8,
                question: "[사례 적용] 지문에 제시된 '여행지에서 외화로 제품을 구매하는' 사례가 '빠른 직관'에 의존하는 경향을 보여주는 이유를 '정확한 계산'과 '어림짐작'이라는 말을 사용하여 서술하시오.",
                correctAnswer: "여행지에서 사람들은 정확한 환율 계산을 통해 구매를 결정하기보다는, 표기된 액면가를 확인하고 그것을 기준으로 불완전한 어림짐작으로 구매를 결정한다. 이는 복잡한 환율 계산이라는 어려운 상황에서 '느린 이성'보다 '빠른 직관'에 의존하는 경향이 강화되는 사례이다.",
                correctParts: ["여행지에서 사람들은 정확한 환율 계산을 통해 구매를 결정하기보다는,", "표기된 액면가를 확인하고 그것을 기준으로 불완전한 어림짐작으로 구매를 결정한다.", "이는 복잡한 환율 계산이라는 어려운 상황에서 '느린 이성'보다 '빠른 직관'에 의존하는 경향이 강화되는 사례이다."],
                distractors: ["여행지에서 외화로 제품을 구매할 때 사람들은 복잡한 환율이나 시간 제약과 무관하게 항상 정확한 계산을 수행하며, '빠른 직관'보다는 '느린 이성'에 주로 의존한다.", "불완전한 어림짐작은 '빠른 직관'이 아닌 '느린 이성'의 결과이며, 충분한 시간을 들여 신중하게 계산한 결과물이므로 정확한 판단으로 이어지는 경향이 있다.", "여행지에서의 환율 계산은 매우 쉬운 상황이므로 '빠른 직관'을 작동시킬 필요가 없으며, 모든 여행자가 정확한 환율 계산을 즉시 수행할 수 있어 어림짐작이 발생하지 않는다."]
            },
            {
                id: 9,
                question: "[보충 심화 <보기>형] <보기>는 '앵커링 효과'에 대한 설명이다. 윗글의 내용을 바탕으로, 소매점의 리디노미네이션 표기가 어떻게 '앵커링 효과'를 유발할 수 있는지 서술하시오.\n\n<보기> 앵커링 효과(Anchoring Effect)란, 배가 닻(anchor)을 내리면 그 주변에 머물게 되듯이, 인간의 판단이 처음에 제시된 특정 숫자나 정보에 크게 영향을 받아 그 주변에서 벗어나지 못하는 심리적 현상을 말한다.",
                correctAnswer: "소매점이 '10.0'과 같이 자릿수를 줄인 가격을 표기하면, 소비자는 처음 본 '10'이라는 작은 숫자에 닻을 내리게 된다. '빠른 직관'이 작동하여 이 작은 숫자를 기준점으로 삼게 되고, 실제로는 10,000원임에도 불구하고 숫자 10 주변에서 가격을 인식하게 되어 저렴하다고 판단하는 앵커링 효과가 발생한다.",
                correctParts: ["소매점이 '10.0'과 같이 자릿수를 줄인 가격을 표기하면, 소비자는 처음 본 '10'이라는 작은 숫자에 닻을 내리게 된다.", "'빠른 직관'이 작동하여 이 작은 숫자를 기준점으로 삼게 되고,", "실제로는 10,000원임에도 불구하고 숫자 10 주변에서 가격을 인식하게 되어 저렴하다고 판단하는 앵커링 효과가 발생한다."],
                distractors: ["소매점이 가격을 '10.0'으로 표기하더라도 소비자는 즉시 실제 가격이 10,000원임을 인식하므로 앵커링 효과는 전혀 발생하지 않으며, 작은 숫자에 닻을 내리는 현상은 나타나지 않는다.", "소비자는 가격 표기의 숫자 크기나 자릿수에 전혀 영향받지 않고 항상 객관적인 가치 판단을 하므로, '10' 같은 작은 숫자를 보더라도 심리적 기준점이 형성되지 않는다.", "처음 본 정보나 숫자는 인간의 판단 과정에 영향을 주지 않으며, 소비자는 '10.0'이라는 표기를 본 후에도 이 숫자를 기준점으로 삼지 않고 완전히 독립적인 가치 판단을 수행한다."]
            },
            {
                id: 10,
                question: "[주제형] 윗글의 핵심 내용을 바탕으로, '실질 가치의 변화 없는 액면가의 조정'이 인간의 경제 활동에 미치는 영향을 한 문장으로 요약하여 서술하시오.",
                correctAnswer: "실질 가치의 변화 없이 액면가만 조정하는 리디노미네이션은 인간의 정보 처리 특성, 특히 '빠른 직관'에 의존하는 경향을 이용하여 물가 상승이나 소비 심리 변화와 같은 실질적인 경제적 영향을 초래할 수 있다.",
                correctParts: ["실질 가치의 변화 없이 액면가만 조정하는 리디노미네이션은", "인간의 정보 처리 특성, 특히 '빠른 직관'에 의존하는 경향을 이용하여", "물가 상승이나 소비 심리 변화와 같은 실질적인 경제적 영향을 초래할 수 있다."],
                distractors: ["실질 가치의 변화 없이 액면가만 조정하는 리디노미네이션은 인간의 경제 활동에 전혀 영향을 주지 않으며, 소비자 행동이나 물가에 아무런 변화도 초래하지 않는 단순한 화폐 단위 변경일 뿐이다.", "리디노미네이션에서 중요한 것은 오직 실질 가치의 유지이며, 액면가 조정이나 소비자의 정보 처리 특성은 경제적으로 의미가 없고 물가나 소비 심리에 영향을 미치지 않는다.", "인간의 심리적 특성이나 '빠른 직관' 같은 정보 처리 방식은 경제 활동과 완전히 무관한 별개의 영역이므로, 액면가 조정이 경제에 미치는 영향을 설명할 때 고려할 필요가 없다."]
            }
        ];

        // 5단계 초기화
        function initStage5() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '리디노미네이션';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            // 모달 닫기
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('active');
            }

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
        // 학습 완료 시스템을 위한 데이터 export
        window.learningResultData = {
            totalStages: totalStages || 5,
            totalCorrect: totalCorrect || 0,
            totalWrong: totalWrong || 0,
            totalAccuracy: totalAccuracy || 0,
            totalScore: totalScore || 0,
            totalElapsedTime: totalElapsedTime || (Date.now() - globalStartTime),
            stagesDetail: stageResults || {}
        };
        console.log('학습 데이터 export:', window.learningResultData);

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
            // 학습 완료 버튼 추가
            if (typeof addCompleteLearningButton === 'function') {
                setTimeout(() => addCompleteLearningButton(), 500);
            }
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stageResults,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장 (모바일 최적화)
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 모바일 기기 감지
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isAndroid = /Android/.test(navigator.userAgent);
            const isMobile = isIOS || isAndroid;

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: isMobile ? 3 : 2,  // 모바일은 더 높은 해상도
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `리디노미네이션_워크북_최종결과_${timestamp}.png`;

                    // iOS Safari 대응
                    if (isIOS) {
                        // iOS에서는 새 탭으로 이미지를 열어서 사용자가 직접 저장하도록 유도
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const newWindow = window.open();
                            if (newWindow) {
                                newWindow.document.write(`
                                    <html>
                                        <head>
                                            <title>${filename}</title>
                                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                            <style>
                                                body { margin: 0; padding: 20px; text-align: center; background: #f5f7fa; }
                                                img { max-width: 100%; height: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
                                                .info { margin-top: 20px; padding: 15px; background: white; border-radius: 8px; }
                                            </style>
                                        </head>
                                        <body>
                                            <div class="info">
                                                <p><strong>이미지를 길게 눌러서 "이미지 저장"을 선택하세요</strong></p>
                                                <p style="font-size: 14px; color: #666;">파일명: ${filename}</p>
                                            </div>
                                            <img src="${e.target.result}" alt="학습 결과">
                                        </body>
                                    </html>
                                `);
                                newWindow.document.close();
                            } else {
                                alert('팝업이 차단되었습니다. 브라우저 설정에서 팝업을 허용해주세요.');
                            }
                        };
                        reader.readAsDataURL(blob);
                    }
                    // Android 및 데스크톱 대응
                    else {
                        const link = document.createElement('a');
                        link.download = filename;
                        link.href = URL.createObjectURL(blob);

                        // Android Chrome에서 더 안정적인 다운로드
                        if (isAndroid) {
                            link.target = '_blank';
                        }

                        // 실제 DOM에 추가하여 클릭 이벤트가 제대로 작동하도록
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        // Blob URL 정리
                        setTimeout(() => {
                            URL.revokeObjectURL(link.href);
                        }, 100);

                        // 성공 메시지
                        if (isMobile) {
                            setTimeout(() => {
                                alert('이미지가 다운로드 폴더에 저장되었습니다!');
                            }, 500);
                        }
                    }
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>