<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>김유정 &lt;봄봄&gt; 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">김유정 &lt;봄봄&gt;</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                {
                    id: 1,
                    text: "이 작품은 1930년대 일제강점기 _____을 배경으로 하는 단편 소설이다.",
                    highlight: "(서울 / 강원도 산골 마을)",
                    options: ["서울", "강원도 산골 마을"],
                    correct: 1
                },
                {
                    id: 2,
                    text: "이 작품은 농촌의 현실을 다룬 _____입니다.",
                    highlight: "(도시 소설 / 농촌 소설)",
                    options: ["도시 소설", "농촌 소설"],
                    correct: 1
                },
                {
                    id: 3,
                    text: "작품의 전반적인 분위기는 독자에게 웃음을 유발한다는 점에서 _____이다.",
                    highlight: "(비극적 / 해학적)",
                    options: ["비극적", "해학적"],
                    correct: 1
                },
                {
                    id: 4,
                    text: "작품은 당대 사회의 모순을 날카롭게 꼬집는다는 점에서 _____이다.",
                    highlight: "(서정적 / 풍자적)",
                    options: ["서정적", "풍자적"],
                    correct: 1
                },
                {
                    id: 5,
                    text: "토속적인 언어를 생생하게 사용하여 _____ 성격을 띤다.",
                    highlight: "(도시적 / 향토적)",
                    options: ["도시적", "향토적"],
                    correct: 1
                },
                {
                    id: 6,
                    text: "핵심 주제는 장인과 '나'의 갈등을 통해 당시 농촌의 _____을 드러낸다.",
                    highlight: "(수탈 구조 / 풍요로운 모습)",
                    options: ["수탈 구조", "풍요로운 모습"],
                    correct: 0
                },
                {
                    id: 7,
                    text: "소설은 '나'의 시점에서 이야기가 전개되는 _____ 시점이다.",
                    highlight: "(1인칭 주인공 / 3인칭 관찰자)",
                    options: ["1인칭 주인공", "3인칭 관찰자"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "'나'의 _____ 내면 심리가 독자에게 그대로 전달되어 웃음을 유발한다.",
                    highlight: "(교활한 / 어리숙한)",
                    options: ["교활한", "어리숙한"],
                    correct: 1
                },
                {
                    id: 9,
                    text: "독자가 주인공에게 _____을 느끼며 쉽게 공감하게 만든다.",
                    highlight: "(거리감 / 친근감)",
                    options: ["거리감", "친근감"],
                    correct: 1
                },
                {
                    id: 10,
                    text: "이 작품은 현재의 싸움에서 시작하여 과거 사건들을 회상하는 _____ 구성을 취한다.",
                    highlight: "(역순행적 / 순행적)",
                    options: ["역순행적", "순행적"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "이러한 구성 방식은 갈등의 원인을 _____ 설명하는 효과를 가진다.",
                    highlight: "(직설적 / 자연스럽게)",
                    options: ["직설적", "자연스럽게"],
                    correct: 1
                },
                {
                    id: 12,
                    text: "결말 부분의 일부를 작품 중간에 미리 보여주는 _____ 구성을 통해 긴장감을 더한다.",
                    highlight: "(편집적 / 교차적)",
                    options: ["편집적", "교차적"],
                    correct: 0
                },
                {
                    id: 13,
                    text: "앞으로의 갈등이 어떻게 전개될지 암시하며 _____과 긴장감을 더한다.",
                    highlight: "(비극성 / 희극성)",
                    options: ["비극성", "희극성"],
                    correct: 1
                },
                {
                    id: 14,
                    text: "이 소설의 서술 순서는 _____ 방식이다.",
                    highlight: "(시간의 흐름에 따른 / 현재와 과거를 오가는)",
                    options: ["시간의 흐름에 따른", "현재와 과거를 오가는"],
                    correct: 1
                },
                {
                    id: 15,
                    text: "3년 7개월 전: '나'가 점순이네 집에 _____로 들어옴",
                    highlight: "(품팔이를 하러 / 데릴사위로)",
                    options: ["품팔이를 하러", "데릴사위로"],
                    correct: 1
                },
                {
                    id: 16,
                    text: "작년 봄: 장인이 돌멩이를 던지고 _____에 성례를 시켜주겠다고 약속함",
                    highlight: "(가을 / 이듬해 봄)",
                    options: ["가을", "이듬해 봄"],
                    correct: 0
                },
                {
                    id: 17,
                    text: "며칠 전 점심: 점순이가 _____ '나'를 충동질함",
                    highlight: "(직접적으로 말하며 / 혼잣말을 하는 척하며)",
                    options: ["직접적으로 말하며", "혼잣말을 하는 척하며"],
                    correct: 1
                },
                {
                    id: 18,
                    text: "어제: '나'가 꾀병을 부리고 _____ 뭉태네 집에 마실을 감",
                    highlight: "(장인과 담판을 짓기 위해 / 구장에게 판정을 요청하기 위해)",
                    options: ["장인과 담판을 짓기 위해", "구장에게 판정을 요청하기 위해"],
                    correct: 1
                },
                {
                    id: 19,
                    text: "오늘 아침: 점순이가 '나'를 _____ '바보'라고 질책함",
                    highlight: "(일을 게을리해서 / 구장에게 다녀온 뒤에도 상황을 바꾸지 못해서)",
                    options: ["일을 게을리해서", "구장에게 다녀온 뒤에도 상황을 바꾸지 못해서"],
                    correct: 1
                },
                {
                    id: 20,
                    text: "오늘 낮: '나'가 다시 꾀병을 부리자 장인과 _____이 시작됨",
                    highlight: "(말다툼 / 몸싸움)",
                    options: ["말다툼", "몸싸움"],
                    correct: 1
                },
                {
                    id: 21,
                    text: "몸싸움 중: 장모와 점순이는 _____ 편을 듦",
                    highlight: "(내 편 / 장인 편)",
                    options: ["내 편", "장인 편"],
                    correct: 1
                },
                {
                    id: 22,
                    text: "싸움 직후: 장인이 터진 머리를 치료해주고 _____에 성례를 다시 약속함",
                    highlight: "(내년 / 올 가을)",
                    options: ["내년", "올 가을"],
                    correct: 1
                },
                {
                    id: 23,
                    text: "결말: '나'가 _____ 다시 지게를 지고 일터로 나감",
                    highlight: "(장인의 약속을 또다시 믿고 / 모든 것을 포기하고)",
                    options: ["장인의 약속을 또다시 믿고", "모든 것을 포기하고"],
                    correct: 0
                },
                {
                    id: 24,
                    text: "이 작품의 주인공은 _____입니다.",
                    highlight: "('나' / '장인')",
                    options: ["'나'", "'장인'"],
                    correct: 0
                },
                {
                    id: 25,
                    text: "'나'는 _____ 어리숙한 데릴사위입니다.",
                    highlight: "(계산적이고 영리하지만 / 우직하고 순박하지만)",
                    options: ["계산적이고 영리하지만", "우직하고 순박하지만"],
                    correct: 1
                },
                {
                    id: 26,
                    text: "'나'는 장인의 교활한 속셈을 _____ 성례 약속만 믿고 일합니다.",
                    highlight: "(알면서도 속아주지만 / 제대로 알지 못하고)",
                    options: ["알면서도 속아주지만", "제대로 알지 못하고"],
                    correct: 1
                },
                {
                    id: 27,
                    text: "'나'는 점순이와의 혼례를 간절히 원하지만 실제 행동은 _____ 편입니다.",
                    highlight: "(적극적 / 소극적)",
                    options: ["적극적", "소극적"],
                    correct: 1
                },
                {
                    id: 28,
                    text: "'나'의 행동은 독자로 하여금 비판보다는 _____을 느끼게 합니다.",
                    highlight: "(연민과 애정 / 경멸과 무시)",
                    options: ["연민과 애정", "경멸과 무시"],
                    correct: 0
                },
                {
                    id: 29,
                    text: "'나'의 장인의 이름은 _____이다.",
                    highlight: "(봉필 / 뭉태)",
                    options: ["봉필", "뭉태"],
                    correct: 0
                },
                {
                    id: 30,
                    text: "장인은 _____ 성격의 소유자입니다.",
                    highlight: "(인정이 많고 정직한 / 교활하고 의뭉스러운)",
                    options: ["인정이 많고 정직한", "교활하고 의뭉스러운"],
                    correct: 1
                },
                {
                    id: 31,
                    text: "장인은 '나'의 노동력을 _____ 합니다.",
                    highlight: "(정당하게 구매 / 무상으로 착취)",
                    options: ["정당하게 구매", "무상으로 착취"],
                    correct: 1
                },
                {
                    id: 32,
                    text: "장인은 지주를 대신해 소작농을 관리하는 _____입니다.",
                    highlight: "(지주 / 마름)",
                    options: ["지주", "마름"],
                    correct: 1
                },
                {
                    id: 33,
                    text: "장인은 당시 농촌의 _____ 수탈 구조를 상징적으로 보여주는 인물입니다.",
                    highlight: "(평등한 / 불평등한)",
                    options: ["평등한", "불평등한"],
                    correct: 1
                },
                {
                    id: 34,
                    text: "점순은 _____ 성격의 열여섯 살 소녀입니다.",
                    highlight: "(소극적이고 순종적인 / 당돌하고 능동적인)",
                    options: ["소극적이고 순종적인", "당돌하고 능동적인"],
                    correct: 1
                },
                {
                    id: 35,
                    text: "점순은 '나'와 장인 사이의 갈등을 _____ 핵심적인 인물입니다.",
                    highlight: "(중재하고 완화시키는 / 유발하고 심화시키는)",
                    options: ["중재하고 완화시키는", "유발하고 심화시키는"],
                    correct: 1
                },
                {
                    id: 36,
                    text: "점순은 '나'를 부추겨 장인에게 저항하도록 만드는 _____ 모습을 보입니다.",
                    highlight: "(소극적 / 적극적)",
                    options: ["소극적", "적극적"],
                    correct: 1
                },
                {
                    id: 37,
                    text: "싸움이 격해지는 순간 점순은 _____의 편을 드는 이중적인 태도를 보입니다.",
                    highlight: "(장인 / '나')",
                    options: ["장인", "'나'"],
                    correct: 0
                },
                {
                    id: 38,
                    text: "장모, 구장, 뭉태와 같은 인물들은 갈등을 _____ 보조적인 역할을 합니다.",
                    highlight: "(중재하거나 / 격화시키는)",
                    options: ["중재하거나", "격화시키는"],
                    correct: 1
                },
                {
                    id: 39,
                    text: "구장의 압박은 당시 농촌의 _____ 권력 관계를 보여줍니다.",
                    highlight: "(수평적인 / 수직적인)",
                    options: ["수평적인", "수직적인"],
                    correct: 1
                },
                {
                    id: 40,
                    text: "이 소설의 중심 갈등은 _____를 둘러싸고 벌어집니다.",
                    highlight: "(성례 문제 / 토지 소유권 문제)",
                    options: ["성례 문제", "토지 소유권 문제"],
                    correct: 0
                },
                {
                    id: 41,
                    text: "장인은 점순이의 _____을 핑계로 성례를 계속 미룹니다.",
                    highlight: "(성품 / 키)",
                    options: ["성품", "키"],
                    correct: 1
                },
                {
                    id: 42,
                    text: "'나'는 점순이의 부추김에 _____ 방식으로 저항하기 시작합니다.",
                    highlight: "(꾀병을 부리거나 / 구장에게 하소연하는)",
                    options: ["꾀병을 부리거나", "구장에게 하소연하는"],
                    correct: 0
                },
                {
                    id: 43,
                    text: "'나'와 장인의 갈등은 결국 지게 막대기를 동원한 _____으로 폭발합니다.",
                    highlight: "(말다툼 / 몸싸움)",
                    options: ["말다툼", "몸싸움"],
                    correct: 1
                },
                {
                    id: 44,
                    text: "싸움 장면은 서로의 바짓가랑이를 붙잡고 늘어지는 등 매우 _____이고 과장되게 묘사됩니다.",
                    highlight: "(비극적 / 희극적)",
                    options: ["비극적", "희극적"],
                    correct: 1
                },
                {
                    id: 45,
                    text: "이러한 장면을 _____이라고도 합니다.",
                    highlight: "(비극적 결투 / 해학적 활극)",
                    options: ["비극적 결투", "해학적 활극"],
                    correct: 1
                },
                {
                    id: 46,
                    text: "작품의 웃음은 대상에 대한 _____을 동반하는 웃음입니다.",
                    highlight: "(경멸 / 연민)",
                    options: ["경멸", "연민"],
                    correct: 1
                },
                {
                    id: 47,
                    text: "해학성은 _____ 인물들의 행동과 생각에서 비롯됩니다.",
                    highlight: "(완벽하고 이성적인 / 어딘가 모자라고 어리숙한)",
                    options: ["완벽하고 이성적인", "어딘가 모자라고 어리숙한"],
                    correct: 1
                },
                {
                    id: 48,
                    text: "심각한 갈등을 _____ 싸움으로 풀어내는 희극적 상황 설정도 해학성의 원천입니다.",
                    highlight: "(과장되고 우스꽝스러운 / 진지하고 심각한)",
                    options: ["과장되고 우스꽝스러운", "진지하고 심각한"],
                    correct: 0
                },
                {
                    id: 49,
                    text: "강원도 사투리, 비속어 등 _____ 언어 사용이 해학성을 더합니다.",
                    highlight: "(표준어 / 토속적)",
                    options: ["표준어", "토속적"],
                    correct: 1
                },
                {
                    id: 50,
                    text: "싸움 후 '나'는 장인의 회유에 또다시 속아 넘어가며, 갈등이 _____ 가능성을 암시합니다.",
                    highlight: "(완전히 해결되지 않고 앞으로도 반복될 / 완벽하게 해소될)",
                    options: ["완전히 해결되지 않고 앞으로도 반복될", "완벽하게 해소될"],
                    correct: 0
                },
                {
                    id: 51,
                    text: "순박한 농민이 계속 착취당하는 당대 농촌의 현실을 보여주는 _____ 결말입니다.",
                    highlight: "(순환 구조 / 비극적)",
                    options: ["순환 구조", "비극적"],
                    correct: 0
                },
                {
                    id: 52,
                    text: "강원도 방언과 토속적인 표현, 비속어의 사용은 작품에 _____을 더해줍니다.",
                    highlight: "(사실감과 해학성 / 이질감과 심각성)",
                    options: ["사실감과 해학성", "이질감과 심각성"],
                    correct: 0
                },
                {
                    id: 53,
                    text: "\"뒤통수를 긁고\", \"침을 뱉고\"와 같은 _____ 표현인 몸짓과 행동 묘사가 사용됩니다.",
                    highlight: "(비언어적 / 반언어적)",
                    options: ["비언어적", "반언어적"],
                    correct: 0
                },
                {
                    id: 54,
                    text: "인물의 억양이나 말투 같은 _____ 표현을 통해 감정과 상황을 효과적으로 전달합니다.",
                    highlight: "(비언어적 / 반언어적)",
                    options: ["비언어적", "반언어적"],
                    correct: 1
                },
                {
                    id: 55,
                    text: "짧고 생동감 있는 _____ 문장과 대화 중심의 서술이 해학적 분위기를 조성합니다.",
                    highlight: "(문어체 / 구어체)",
                    options: ["문어체", "구어체"],
                    correct: 1
                },
                {
                    id: 56,
                    text: "대화 중심의 서술은 독자와의 거리를 _____줍니다.",
                    highlight: "(좁혀 / 넓혀)",
                    options: ["좁혀", "넓혀"],
                    correct: 0
                },
                {
                    id: 57,
                    text: "이 작품의 배경인 1930년대는 일제의 _____ 등으로 농촌 수탈이 극심했던 시기입니다.",
                    highlight: "(토지조사사업 / 산미증식계획)",
                    options: ["토지조사사업", "산미증식계획"],
                    correct: 1
                },
                {
                    id: 58,
                    text: "마름은 중간에서 농민들을 _____며 경제적으로 예속시켰습니다.",
                    highlight: "(보호하며 / 착취하며)",
                    options: ["보호하며", "착취하며"],
                    correct: 1
                },
                {
                    id: 59,
                    text: "해학적인 웃음 속에는 데릴사위 제도의 모순과 같은 _____과 구조적 문제 비판이 담겨 있습니다.",
                    highlight: "(봉건적 악습 / 근대적 계약)",
                    options: ["봉건적 악습", "근대적 계약"],
                    correct: 0
                },
                {
                    id: 60,
                    text: "힘 있는 자가 순박한 사람을 착취하는 사회의 구조적 문제를 비판하는 날카로운 _____가 담겨 있습니다.",
                    highlight: "(해학 / 풍자)",
                    options: ["해학", "풍자"],
                    correct: 1
                },
                {
                    id: 61,
                    text: "혼인에 대해 소극적인 '나'와 적극적으로 '나'를 부추기는 '점순'의 모습은 당시의 _____ 남녀 역할을 보여줍니다.",
                    highlight: "(전통적인 / 전도된)",
                    options: ["전통적인", "전도된"],
                    correct: 1
                },
                {
                    id: 62,
                    text: "성례는 단순한 결혼을 넘어, 노동에 대한 _____이자 인간적인 대우를 의미합니다.",
                    highlight: "(정당한 대가 / 추가적인 보상)",
                    options: ["정당한 대가", "추가적인 보상"],
                    correct: 0
                },
                {
                    id: 63,
                    text: "점순이의 키는 장인이 '나'를 착취하기 위한 _____ 핑계이자 모든 갈등의 표면적인 원인입니다.",
                    highlight: "(합리적인 / 비논리적인)",
                    options: ["합리적인", "비논리적인"],
                    correct: 1
                },
                {
                    id: 64,
                    text: "계절적 배경인 '봄'은 '나'와 점순이의 _____과 성례에 대한 기대를 불러일으키는 분위기를 조성합니다.",
                    highlight: "(순수한 사랑 / 성적인 욕망)",
                    options: ["순수한 사랑", "성적인 욕망"],
                    correct: 1
                },
                {
                    id: 65,
                    text: "주인공 '나'는 점순이와 혼례를 치르기 위해 _____ 동안 장인 밑에서 데릴사위로 일하고 있습니다.",
                    highlight: "(3년 7개월 / 1년)",
                    options: ["3년 7개월", "1년"],
                    correct: 0
                },
                {
                    id: 66,
                    text: "장인은 점순이의 _____를 핑계를 대며 계속해서 혼례를 미룹니다.",
                    highlight: "(키가 작다는 / 나이가 어리다는)",
                    options: ["키가 작다는", "나이가 어리다는"],
                    correct: 0
                },
                {
                    id: 67,
                    text: "점순이는 '나'에게 _____고 부추깁니다.",
                    highlight: "(일을 더 열심히 하라고 / 성례를 시켜달라고 조르라고)",
                    options: ["일을 더 열심히 하라고", "성례를 시켜달라고 조르라고"],
                    correct: 1
                },
                {
                    id: 68,
                    text: "점순이의 충동질에 넘어간 '나'는 _____ 등의 소극적인 저항을 시작합니다.",
                    highlight: "(꾀병을 부리거나 / 구장님에게 찾아가는)",
                    options: ["꾀병을 부리거나", "구장님에게 찾아가는"],
                    correct: 0
                },
                {
                    id: 69,
                    text: "'나'의 저항에도 장인이 꿈쩍도 않자, 점순이는 '나'를 _____더욱 강하게 자극합니다.",
                    highlight: "('바보'라고 부르며 / 위로하며)",
                    options: ["'바보'라고 부르며", "위로하며"],
                    correct: 0
                },
                {
                    id: 70,
                    text: "이에 화가 난 '나'는 장인에게 _____ 대들기 시작하며 갈등은 최고조에 이릅니다.",
                    highlight: "(적극적으로 / 소극적으로)",
                    options: ["적극적으로", "소극적으로"],
                    correct: 0
                },
                {
                    id: 71,
                    text: "결국 '나'와 장인은 지게 막대기를 들고 우스꽝스러운 _____을 벌입니다.",
                    highlight: "(말다툼 / 몸싸움)",
                    options: ["말다툼", "몸싸움"],
                    correct: 1
                },
                {
                    id: 72,
                    text: "'나'가 장인을 밀치고 제압하려는 결정적인 순간, 점순이는 의외로 _____을 들며 '나'를 공격합니다.",
                    highlight: "(내 편 / 아버지 편)",
                    options: ["내 편", "아버지 편"],
                    correct: 1
                },
                {
                    id: 73,
                    text: "싸움이 끝난 후, 장인은 다친 '나'를 치료해주며 _____에는 꼭 성례를 시켜주겠다고 다시 한번 약속합니다.",
                    highlight: "(내년 봄 / 올 가을)",
                    options: ["내년 봄", "올 가을"],
                    correct: 1
                },
                {
                    id: 74,
                    text: "'나'는 장인의 말을 _____ 다시 일을 하러 나갑니다.",
                    highlight: "(의심 없이 믿고 / 거짓말이라고 생각하고)",
                    options: ["의심 없이 믿고", "거짓말이라고 생각하고"],
                    correct: 0
                },
                {
                    id: 75,
                    text: "갈등은 봉합되었지만, 이 문제가 _____을 암시하며 이야기는 끝납니다.",
                    highlight: "(완전히 해결된 것은 아님 / 완전히 해결되었음)",
                    options: ["완전히 해결된 것은 아님", "완전히 해결되었음"],
                    correct: 0
                }
            ],
            fullText: `## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**

본격적인 작품 분석에 앞서, 김유정의 <봄봄>이 어떤 작품인지 핵심적인 특징들을 먼저 알아봅시다. 다음 설명에서 괄호 안의 두 선택지 중 더 적절한 것을 골라보며 내용을 파악해 보세요.

### **1. 작품 개관: 어떤 이야기인가?**

이 작품은 1930년대 일제강점기 (서울 / 강원도 산골 마을)을 배경으로 하는 단편 소설이자, 농촌의 현실을 다룬 (도시 소설 / 농촌 소설)입니다. 작품의 전반적인 분위기는 독자에게 웃음을 유발한다는 점에서 (비극적 / 해학적)이며, 당대 사회의 모순을 날카롭게 꼬집는다는 점에서 (서정적 / 풍자적)이고, 그리고 토속적인 언어를 생생하게 사용하여 (도시적 / 향토적) 성격을 띱니다. 핵심 주제는 혼례를 빌미로 데릴사위를 부려먹는 장인과 순박한 '나'의 갈등을 통해 당시 농촌의 (수탈 구조 / 풍요로운 모습)을 드러내는 것입니다.

### **2. 서술 및 구성 방식: 어떻게 이야기하는가?**

* **시점:** 소설은 어리숙하고 순박한 데릴사위인 '나'의 시점에서 이야기가 전개되는 (1인칭 주인공 / 3인칭 관찰자) 시점입니다. 이를 통해 '나'의 (교활한 / 어리숙한) 내면 심리가 독자에게 그대로 전달되어 웃음을 유발하고, 독자가 주인공에게 (거리감 / 친근감)을 느끼며 쉽게 공감하게 만듭니다.
* **구성:** 이 작품은 사건이 시간 순서대로 진행되지 않습니다. 현재에 벌어진 '나'와 장인의 싸움에서 시작하여, 그 원인이 되는 과거의 사건들을 회상하는 (역순행적 / 순행적) 구성을 취하고 있습니다. 이러한 구성 방식은 독자의 궁금증을 유발하고, 갈등의 원인을 (직설적 / 자연스럽게) 설명하는 효과를 가집니다. 특히, 싸움이 끝난 후 장인이 '나'를 회유하는 결말 부분의 일부를 작품 중간에 미리 보여주는 (편집적 / 교차적) 구성을 통해, 앞으로의 갈등이 어떻게 전개될지 암시하며 (비극성 / 희극성)과 긴장감을 더합니다.
* **작품 속 실제 사건 순서:** 이 소설의 서술 순서는 (시간의 흐름에 따른 / 현재와 과거를 오가는) 방식이지만, 작품 속 실제 사건들을 시간 순으로 재구성하면 다음과 같습니다.
  1. 3년 7개월 전: '나'가 점순이네 집에 (품팔이를 하러 / 데릴사위로) 들어옴
  2. 작년 봄: 장인이 돌멩이를 던지고 (가을 / 이듬해 봄)에 성례를 시켜주겠다고 약속함
  3. 며칠 전 점심: 점순이가 (직접적으로 말하며 / 혼잣말을 하는 척하며) '나'를 충동질함
  4. 어제: '나'가 꾀병을 부리고 (장인과 담판을 짓기 위해 / 구장에게 판정을 요청하기 위해) 뭉태네 집에 마실을 감
  5. 오늘 아침: 점순이가 '나'를 (일을 게을리해서 / 구장에게 다녀온 뒤에도 상황을 바꾸지 못해서) '바보'라고 질책함
  6. 오늘 낮: '나'가 다시 꾀병을 부리자 장인과 (말다툼 / 몸싸움)이 시작됨
  7. 몸싸움 중: '나'가 장인을 굴리고 서로 바짓가랑이를 잡고 대치하자, 장모와 점순이는 (내 편 / 장인 편)을 듦
  8. 싸움 직후: 장인이 터진 머리를 치료해주고 (내년 / 올 가을)에 성례를 다시 약속함
  9. 결말: '나'가 (장인의 약속을 또다시 믿고 / 모든 것을 포기하고) 다시 지게를 지고 일터로 나감

### **3. 등장인물 심층 분석: 어떤 사람들이 나오는가?**

* **'나'**: 이 작품의 주인공인 ('나' / '장인')는 (계산적이고 영리하지만 / 우직하고 순박하지만) 어리숙한 데릴사위입니다. 장인의 교활한 속셈을 (알면서도 속아주지만 / 제대로 알지 못하고) 성례 약속만 믿고 3년 7개월간 우직하게 일합니다. 정서적으로는 점순이와의 혼례를 간절히 원하지만 실제 행동은 (적극적 / 소극적)인 편입니다. 그의 행동은 상황 판단이 느리고 다소 모자라 보이지만, 이는 독자로 하여금 비판보다는 (연민과 애정 / 경멸과 무시)을 느끼게 합니다.
* **장인**: '나'의 장인이자 이름이 (봉필 / 뭉태)인 인물은 (인정이 많고 정직한 / 교활하고 의뭉스러운) 성격의 소유자입니다. 점순이의 키가 작다는 핑계로 혼례를 계속 미루며 '나'의 노동력을 (정당하게 구매 / 무상으로 착취)합니다. 그는 지주를 대신해 소작농을 관리하며 이익을 챙기는 (지주 / 마름)으로서, 당시 농촌의 (평등한 / 불평등한) 수탈 구조를 상징적으로 보여주는 인물입니다.
* **점순:** (소극적이고 순종적인 / 당돌하고 능동적인) 성격의 열여섯 살 소녀입니다. '나'와 장인 사이의 갈등을 (중재하고 완화시키는 / 유발하고 심화시키는) 핵심적인 인물입니다. 성례를 하고 싶은 마음에 '나'를 부추겨 장인에게 저항하도록 만드는 (소극적 / 적극적)이고 당돌한 모습을 보입니다. 하지만 '나'와 장인의 싸움이 격해지는 결정적인 순간에는 자신의 아버지인 (장인 / '나')의 편을 드는 이중적인 태도를 보여 상황을 더욱 우스꽝스럽게 만듭니다.
* **주변 인물:** 장모, 구장, 뭉태와 같은 인물들은 갈등을 (중재하거나 / 격화시키는) 보조적인 역할을 합니다. 특히 구장은 "일 안 하면 징역 간다"며 '나'를 압박하는데, 이는 당시 농촌의 (수평적인 / 수직적인) 권력 관계를 보여줍니다.

### **4. 갈등의 전개와 해학성: 왜 웃음이 나는가?**

* **갈등의 원인:** 이 소설의 중심 갈등은 (성례 문제 / 토지 소유권 문제)를 둘러싸고 벌어집니다. '나'는 약속된 성례를 원하지만, 장인은 점순이의 (성품 / 키)를 핑계로 이를 계속 미룹니다.
* **갈등의 심화:** 처음에는 소극적으로 불만을 품던 '나'는, 점순이의 부추김에 (꾀병을 부리거나 / 구장에게 하소연하는) 방식으로 저항하기 시작합니다.
* **갈등의 절정:** '나'와 장인의 갈등은 결국 지게 막대기를 동원한 (말다툼 / 몸싸움)으로 폭발합니다. 그러나 이 장면은 심각하고 폭력적이기보다는, 서로의 바짓가랑이를 붙잡고 늘어지는 등 매우 (비극적 / 희극적)이고 과장되게 묘사됩니다. 이러한 장면을 (비극적 결투 / 해학적 활극)이라고도 합니다.
* **해학성의 원천:** 이 작품의 웃음, 즉 해학성은 여러 요소에서 비롯됩니다. 이는 대상에 대한 (경멸 / 연민)을 동반하는 웃음이라는 특징이 있습니다.
  * 인물: (완벽하고 이성적인 / 어딘가 모자라고 어리숙한) 인물들의 행동과 생각
  * 상황: 심각한 갈등을 (과장되고 우스꽝스러운 / 진지하고 심각한) 싸움으로 풀어내는 희극적 상황 설정
  * 언어: 강원도 사투리, 비속어 등 (표준어 / 토속적) 언어 사용을 통한 생동감과 친근감
* **결말의 아이러니:** 싸움이 끝난 후 '나'는 장인의 회유에 또다시 속아 넘어갑니다. 이는 갈등이 (완전히 해결되지 않고 앞으로도 반복될 / 완벽하게 해소될) 가능성을 암시하며, 순박한 농민이 계속 착취당하는 당대 농촌의 현실을 보여주는 (순환 구조 / 비극적) 결말입니다.

### **5. 표현 방식과 언어적 특징: 어떻게 실감 나게 표현하는가?**

* **토속어와 비속어:** "짜장", "움물길"과 같은 강원도 방언과 토속적인 표현, 그리고 다양한 비속어의 사용은 작품에 (사실감과 해학성 / 이질감과 심각성)을 더해줍니다.
* **비언어적/반언어적 표현:** "뒤통수를 긁고", "침을 뱉고" 와 같은 (비언어적 / 반언어적) 표현인 몸짓과 행동 묘사, 그리고 인물의 억양이나 말투 같은 (비언어적 / 반언어적) 표현을 통해 인물의 감정과 상황을 효과적으로 전달합니다.
* **구어체와 대화:** 짧고 생동감 있는 (문어체 / 구어체) 문장과 대화 중심의 서술은 해학적 분위기를 조성하고 독자와의 거리를 (좁혀 / 넓혀) 줍니다.

### **6. 시대적 배경과 풍자: 웃음 속에 담긴 의미는?**

* **역사적 현실:** 이 작품의 배경인 1930년대는 일제의 (토지조사사업 / 산미증식계획) 등으로 농촌 수탈이 극심했던 시기입니다. 지주를 대신해 소작농을 관리하던 마름은 중간에서 농민들을 (보호하며 / 착취하며) 경제적으로 예속시켰습니다.
* **풍자의 대상:** 이 작품의 해학적인 웃음은 단순히 재미만을 위한 것이 아닙니다. 그 속에는 데릴사위 제도의 모순과 같은 (봉건적 악습 / 근대적 계약)과, 힘 있는 자가 순박한 사람을 착취하는 당대 농촌 사회의 구조적 문제를 비판하는 날카로운 (해학 / 풍자)가 담겨 있습니다.
* **성 역할의 전도:** 혼인에 대해 소극적인 '나'와 적극적으로 '나'를 부추기는 '점순'의 모습은 당시의 (전통적인 / 전도된) 남녀 역할을 보여주며 웃음을 유발합니다.
* **상징적 의미:**
  * **성례:** 단순한 결혼을 넘어, 노동에 대한 (정당한 대가 / 추가적인 보상)이자 인간적인 대우를 의미합니다.
  * **점순이의 키:** 장인이 '나'를 착취하기 위한 (합리적인 / 비논리적인) 핑계이자, 모든 갈등의 표면적인 원인입니다.
  * **봄:** 계절적 배경인 '봄'은 만물이 성장하고 생동하는 계절로, '나'와 점순이의 (순수한 사랑 / 성적인 욕망)과 성례에 대한 기대를 불러일으키는 분위기를 조성합니다.

## **2️⃣ 작품 미리보기: 전체 줄거리 훑어보기 📝**

본격적으로 작품을 읽기 전에, <봄봄>의 전체 줄거리를 따라가 봅시다. '나'와 장인, 그리고 점순이 사이에서 어떤 일이 벌어지는지 선택지를 고르며 확인해 보세요.

* **발단:** 주인공 '나'는 점순이와 혼례를 치르기 위해 (3년 7개월 / 1년) 동안 장인 밑에서 데릴사위로 일하고 있습니다. 하지만 장인은 점순이의 (키가 작다는 / 나이가 어리다는) 핑계를 대며 계속해서 혼례를 미룹니다.
* **전개:** '나'는 장인의 약속만 믿고 우직하게 일하지만, 점순이는 '나'에게 (일을 더 열심히 하라고 / 성례를 시켜달라고 조르라고) 부추깁니다. 점순이의 충동질에 넘어간 '나'는 (꾀병을 부리거나 / 구장님에게 찾아가는) 등의 소극적인 저항을 시작합니다.
* **위기:** '나'의 저항에도 장인이 꿈쩍도 않자, 점순이는 '나'를 ('바보'라고 부르며 / 위로하며) 더욱 강하게 자극합니다. 이에 화가 난 '나'는 장인에게 (적극적으로 / 소극적으로) 대들기 시작하며 갈등은 최고조에 이릅니다.
* **절정:** 결국 '나'와 장인은 지게 막대기를 들고 우스꽝스러운 (말다툼 / 몸싸움)을 벌입니다. '나'가 장인을 밀치고 제압하려는 결정적인 순간, 점순이는 의외로 (내 편 / 아버지 편)을 들며 '나'를 공격합니다.
* **결말:** 싸움이 끝난 후, 장인은 다친 '나'를 치료해주며 (내년 봄 / 올 가을)에는 꼭 성례를 시켜주겠다고 다시 한번 약속합니다. '나'는 장인의 말을 (의심 없이 믿고 / 거짓말이라고 생각하고) 다시 일을 하러 나갑니다. 갈등은 봉합되었지만, 이 문제가 (완전히 해결된 것은 아님 / 완전히 해결되었음)을 암시하며 이야기는 끝납니다.`
        };

        // 2단계 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "성례",
                meaning: "혼인 예식",
                type: "한자어",
                confusors: {
                    word: ["혼례", "혼사", "혼배"],
                    meaning: ["장례 의식", "제사 의식", "성인식"]
                }
            },
            {
                word: "데릴사위",
                meaning: "처가에서 살면서 일을 해주는 조건으로 혼인하는 사위",
                type: "개념",
                confusors: {
                    word: ["머슴", "소작농", "품팔이"],
                    meaning: ["처가에서 살지 않고 일만 하는 사람", "결혼 전제 없이 일만 하는 사람", "시집에서 일하는 며느리"]
                }
            },
            {
                word: "마름",
                meaning: "지주를 대신해서 소작지를 관리하며 소작인들을 감독하고 소작료를 징수하던 중간 관리인",
                type: "개념",
                confusors: {
                    word: ["소작인", "지주", "관리인"],
                    meaning: ["땅을 직접 소유한 사람", "땅을 빌려 경작하는 사람", "단순히 땅을 관리만 하는 사람"]
                }
            },
            {
                word: "사경",
                meaning: "머슴이 주인에게서 한 해 동안 일한 대가로 받는 돈이나 물건",
                type: "개념",
                confusors: {
                    word: ["품삯", "일당", "월급"],
                    meaning: ["하루 일한 대가", "한 달 일한 대가", "결혼 지참금"]
                }
            },
            {
                word: "짜장",
                meaning: "과연, 정말로, 진짜라는 뜻의 강원도 방언",
                type: "방언",
                confusors: {
                    word: ["자장", "정말", "진짜"],
                    meaning: ["아니다, 거짓이라는 뜻의 방언", "조금, 약간이라는 뜻의 방언", "아마도, 혹시라는 뜻의 방언"]
                }
            },
            {
                word: "내외",
                meaning: "남녀 사이에 서로 얼굴을 마주 대하지 않고 피하는 유교적 관습",
                type: "개념",
                confusors: {
                    word: ["예절", "격식", "체면"],
                    meaning: ["남녀가 자유롭게 만나는 풍습", "부부 사이의 애정 표현", "손님을 대접하는 관습"]
                }
            },
            {
                word: "서낭당",
                meaning: "마을의 평화를 지켜준다고 믿는 신을 모시는 신당",
                type: "개념",
                confusors: {
                    word: ["사당", "사찰", "교회"],
                    meaning: ["재앙을 가져온다고 믿는 신을 모시는 곳", "조상의 위패를 모신 곳", "불교 사원"]
                }
            },
            {
                word: "치성",
                meaning: "신이나 부처에게 정성을 다해 비는 행위",
                type: "한자어",
                confusors: {
                    word: ["기도", "제사", "예배"],
                    meaning: ["가볍게 빌어보는 행위", "장난스럽게 빌어보는 행위", "신에게 감사하는 행위"]
                }
            },
            {
                word: "골김",
                meaning: "비위에 거슬리거나 마음이 언짢아서 성이 나는 기분",
                type: "방언",
                confusors: {
                    word: ["화", "짜증", "분노"],
                    meaning: ["즐겁고 기쁜 기분", "만족스러운 기분", "평온한 기분"]
                }
            },
            {
                word: "관격",
                meaning: "급하게 체하여 생기는 위급한 증상",
                type: "한자어",
                confusors: {
                    word: ["체증", "소화불량", "복통"],
                    meaning: ["만성적인 질병", "가벼운 소화 불량", "정신적 스트레스"]
                }
            },
            {
                word: "계제",
                meaning: "어떤 일을 하기에 알맞게 된 상황이나 기회",
                type: "한자어",
                confusors: {
                    word: ["기회", "시기", "때"],
                    meaning: ["부적절한 상황이나 시기", "정해진 시간이나 장소", "우연한 사건"]
                }
            }
        ];

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 문장 독해 데이터
        const sentenceData = [
            // 문장 (1), (2) 분석 - 서술자의 예측 파악하기
            {
                sentence: "(1) 나의 생각에 장모님은 제 남편이니까 역성을 할는지도 모른다. (2) 그러나 점순이는 내 편을 들어서 속으로 고소해서 하겠지 ---",
                question: "'나'는 장모님이 누구의 편을 들 것이라고 예상하고 있나요?",
                correctAnswer: "남편인 장인의 편",
                distractors: ["자신의 편", "점순이의 편", "중립적인 입장"]
            },
            {
                sentence: "(1) 나의 생각에 장모님은 제 남편이니까 역성을 할는지도 모른다. (2) 그러나 점순이는 내 편을 들어서 속으로 고소해서 하겠지 ---",
                question: "'나'는 점순이가 누구의 편을 들 것이라고 기대하고 있나요?",
                correctAnswer: "'나'의 편",
                distractors: ["장인의 편", "장모님의 편", "어느 쪽도 들지 않을 것"]
            },
            // 문장 (3), (4), (5) 분석 - 인물 지칭어 및 행동 주체 파악하기
            {
                sentence: "(3) 대체 이게 웬 속인지 아버질 혼내 주기는 제가 내래 놓고 이제 와서는 달려들며,",
                question: "아버질 혼내 주기를 부추겼던 '제가' 가리키는 인물은?",
                correctAnswer: "점순이 자신",
                distractors: ["장인", "'나'", "장모님"]
            },
            {
                sentence: "(4) \"에그머니! 이 망할 게 아버지 죽이네!\"",
                question: "점순이가 소리친 '이 망할 게'가 가리키는 대상은?",
                correctAnswer: "'나'",
                distractors: ["장인", "장모님", "지게 막대기"]
            },
            {
                sentence: "(5) 하고 내 귀를 뒤로 잡아당기며 마냥 우는 것이 아니냐.",
                question: "'나'의 귀를 잡아당기며 운 사람은?",
                correctAnswer: "점순이",
                distractors: ["장모님", "장인", "뭉태"]
            },
            // 문장 (6) 분석 - 서술자의 심리 변화 추론하기
            {
                sentence: "(6) 그만 여기에 기운이 탁 꺾이어 나는 얼빠진 등신이 되고 말았다.",
                question: "'나'가 '기운이 탁 꺾인' 가장 큰 이유는?",
                correctAnswer: "믿었던 점순이가 자신을 공격해서",
                distractors: ["장모님이 장인 편을 들어서", "장인이 지게 막대기로 때려서", "구장이 장인 편을 들어서"]
            },
            {
                sentence: "(6) 그만 여기에 기운이 탁 꺾이어 나는 얼빠진 등신이 되고 말았다.",
                question: "스스로를 '얼빠진 등신'이라고 생각하는 것에서 '나'의 어떤 심정을 알 수 있나요?",
                correctAnswer: "당황스럽고 허탈한",
                distractors: ["분하고 억울한", "기쁘고 즐거운", "후회하고 반성하는"]
            },
            // 문장 (7), (8) 분석 - 상황 파악하기
            {
                sentence: "(7) 장모님도 덤벼들어 한쪽 귀마저 뒤로 잡아 채면서 또 우는 것이다.",
                question: "장모님까지 가세하여 '나'는 양쪽 귀를 잡혀 어떤 상태가 되었나요?",
                correctAnswer: "반격할 수 없는",
                distractors: ["도망갈 수 없는", "공격할 수 있는", "자유롭게 움직일 수 있는"]
            },
            {
                sentence: "(8) 이렇게 꼼짝도 못하게 해놓고 장인님은 지게 막대기를 들어서 사뭇 내려조겼다.",
                question: "이 상황에서 장인님은 어떻게 '나'를 공격했나요?",
                correctAnswer: "지게 막대기를 사용하여",
                distractors: ["대화를 시도하며", "주먹으로 때리며", "발로 차며"]
            },
            // 문장 (9), (10) 분석 - 서술자의 마지막 태도 이해하기
            {
                sentence: "(9) 그러나 나는 구태여 피하려지도 않고 암만해도 그 속 알 수 없는 점순이의 얼굴만 멀거니 들여다보았다.",
                question: "'나'가 장인의 공격을 피하지 않은 이유는?",
                correctAnswer: "점순이의 행동을 이해할 수 없었기 때문에",
                distractors: ["너무 아파서 움직일 수 없었기 때문에", "장인을 이길 자신이 있었기 때문에", "모든 것을 포기했기 때문에"]
            }
        ];

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            renderPassage();
            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 모든 하이라이트 텍스트를 순차적으로 교체 (첫 번째 매칭만)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // 'g' 플래그 제거 - 첫 번째 매칭만 교체
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            // 마크다운 처리
            // 제목 처리
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 볼드 처리 (하이라이트 span 태그 내부는 제외)
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                if (match.includes('<span class="highlight"')) return match; // 이미 하이라이트 처리된 것은 건드리지 않음
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                if (match.includes('<span class="highlight"')) return match;
                return `<div class="subsection">• ${content}</div>`;
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            // 2단계 어휘 학습으로 전환
            currentStage = 2;
            initStage2();
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // 단어 → 뜻 문제
                const wordToMeaning = {
                    type: 'word-to-meaning',
                    question: `"${vocab.word}"의 의미는?`,
                    correct: vocab.meaning,
                    word: vocab.word,
                    options: shuffleArray([
                        vocab.meaning,
                        ...vocab.confusors.meaning.slice(0, 3)
                    ])
                };

                // 뜻 → 단어 문제
                const meaningToWord = {
                    type: 'meaning-to-word',
                    question: `"${vocab.meaning}"를 나타내는 용어는?`,
                    correct: vocab.word,
                    meaning: vocab.meaning,
                    options: shuffleArray([
                        vocab.word,
                        ...vocab.confusors.word.slice(0, 3)
                    ])
                };

                stage2Data.questions.push(wordToMeaning, meaningToWord);
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장과 질문 표시
            document.getElementById('sentence-text').textContent = question.sentence;
            document.getElementById('sentence-question').textContent = `Q. ${question.question}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }

        // ================== 4단계: OX퀴즈 ==================
        const stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],  // 틀린 문제 저장
            startTime: null,
            timeRemaining: 120
        };

        // OX퀴즈 데이터
        const oxQuizData = [
            { question: "이 소설은 '나'가 겪는 사건을 서술자가 멀리서 관찰하여 전달하는 3인칭 관찰자 시점으로 되어 있다.", answer: false, explanation: "문학 선택지 패턴 'A vs B (비교 대상 혼동)'. 이 작품은 서술자인 '나'가 직접 자신의 이야기를 하는 (1인칭 주인공 시점 / 3인칭 주인공 시점)입니다. 선택지는 1인칭 시점을 3인칭 시점으로 잘못 설명했습니다." },
            { question: "'나'는 점순이와 성례를 하기 위해 3년 7개월 동안 돈 한 푼 받지 않고 장인 밑에서 일했다.", answer: true, explanation: "" },
            { question: "\"이 자식아! 성례구 뭐구 미처 자라야지!\"라는 장인의 말은, '나'의 키가 아직 덜 자랐다는 것을 의미한다.", answer: false, explanation: "문학 선택지 패턴 '③ Who/Whose/Whom (주체/객체 왜곡)'. 장인이 키가 자라야 한다고 말한 대상은 '나'가 아니라 (점순이 / '나')입니다." },
            { question: "'나'는 점순이의 키를 재 보기 위해 자를 가지고 직접 재 보려 했으나, 장인님이 내외해야 한다고 해서 실패했다.", answer: true, explanation: "" },
            { question: "'나'는 점순이의 키가 크지 않는 이유가 물동이를 너무 자주 이어서라고 생각하여, 대신 물을 길어다 주기도 했다.", answer: true, explanation: "" },
            { question: "'나'가 꾀병을 부리며 일을 하지 않자, 장인은 '나'의 뺨을 때리며 화를 냈다.", answer: true, explanation: "" },
            { question: "장인은 마을 사람들에게 인심을 잃었지만, '나'에게는 사위라는 이유로 함부로 대하지 못했다.", answer: false, explanation: "문학 선택지 패턴 '① Good vs Bad (긍정/부정 왜곡)'. 지문에서 장인은 '나'에게도 \"이 자식, 저 자식\"하며 욕을 하고 뺨을 때리는 등 (함부로 대했습니다 / 존중해주었습니다). 선택지는 장인의 태도를 사실과 다르게 긍정적으로 왜곡했습니다." },
            { question: "작년에 '나'가 꾀병을 부렸을 때, 장인은 \"올 갈에 벼 잘 되면 너 장가들지 않니.\"라며 '나'를 달랜 적이 있다.", answer: true, explanation: "" },
            { question: "장인은 작년에 약속한 대로 가을이 되자 '나'와 점순이의 성례를 치러 주었다.", answer: false, explanation: "문학 선택지 패턴 '⑧ 했냐 안 했냐 (사실 왜곡)'. 장인은 약속을 하고 '나'를 회유했지만, 정작 가을이 되자 점순이 키 핑계를 대며 약속을 (지키지 않았습니다 / 지켰습니다)." },
            { question: "'나'는 점순이가 예쁘지는 않지만 밥술이나 톡톡히 먹음직하게 생긴 것을 마음에 들어 한다.", answer: true, explanation: "" },
            { question: "점순이는 \"밤낮 일만 하다 말 텐가!\"라고 혼잣말을 하며, '나'가 계속해서 묵묵히 일하기를 바라는 마음을 드러냈다.", answer: false, explanation: "문학 선택지 패턴 '⑤ 의도/목적 왜곡'. 이 말은 '나'가 계속 일하기를 바라는 것이 아니라, 왜 성례를 요구하지 않고 일만 하냐고 (답답해하며 / 만족하며) '나'의 행동을 촉구하는 의도입니다." },
            { question: "점순이의 충동질에 '나'는 성례 문제로 장인과 담판을 짓기 위해 구장님을 찾아갔다.", answer: true, explanation: "" },
            { question: "구장님은 '나'의 편을 들어 장인에게 성례를 시켜주라고 강하게 말했지만, 장인은 점순이가 미처 자라지 않았다는 이유로 거절했다.", answer: false, explanation: "문학 선택지 패턴 '① Good vs Bad (긍정/부정 왜곡)'. 구장님은 처음에는 '나'의 편을 드는 척했지만, 장인이 반박하자 금세 \"그것두 그래!\"라며 (장인의 편을 들었습니다 / 자신의 주장을 유지했습니다)." },
            { question: "구장님은 '나'에게 성년이 되는 스물하나가 되어야 법적으로 결혼할 수 있으니 조금 더 기다리라고 조언했다.", answer: true, explanation: "" },
            { question: "뭉태는 장인이 데릴사위를 여러 번 갈아치운 사실을 알려주며 '나'가 장인에게 적극적으로 저항하도록 부추겼다.", answer: true, explanation: "" },
            { question: "뭉태가 '나'를 부추긴 이유는 장인이 자신에게 땅을 떼어 주지 않은 것에 대한 개인적인 앙심 때문이었다.", answer: true, explanation: "" },
            { question: "점순이는 \"쇰을 잡아 채지 그냥 둬, 이 바보야!\"라고 말하며, '나'의 소극적인 태도를 칭찬했다.", answer: false, explanation: "문학 선택지 패턴 '① Good vs Bad (긍정/부정 왜곡)'. 점순이는 '나'의 소극적인 태도를 (질책하고 / 칭찬하고) 있습니다. 선택지는 점순이의 부정적 반응을 긍정적으로 왜곡했습니다." },
            { question: "'나'가 장인의 수염을 잡아챈 이유는 장인에게 맞은 것이 아파서가 아니라, 점순이가 그 모습을 보고 있었기 때문이다.", answer: true, explanation: "" },
            { question: "'나'와 장인의 싸움이 커지자, 점순이는 \"이 망할 게 아버지 죽이네!\"라고 소리치며 장인의 편에 섰다.", answer: true, explanation: "" },
            { question: "점순이와 장모가 자신을 공격하자, '나'는 기운이 꺾여 장인의 매를 피하지 않고 점순이의 얼굴만 바라보았다.", answer: true, explanation: "" },
            { question: "싸움이 끝난 후, 장인은 '나'를 내쫓지 않고 머리를 치료해주며 올 가을에 성례를 시켜주겠다고 다시 약속했다.", answer: true, explanation: "" },
            { question: "장인의 약속을 들은 '나'는 장인의 진심을 깨닫고 눈물을 흘리며 다시는 그러지 않겠다고 맹세했다.", answer: true, explanation: "" }
        ];

        // 4단계 초기화
        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '김유정 <봄봄>';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 4';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 진짜 원문 표시
            const originalText = `"장인님! 인제 저……"
내가 이렇게 뒤통수를 긁고, 나이가 찼으니 성례를 시켜줘야 하지 않겠느냐고 하면 대답이 늘,
"이자식아! 성례구 뭐구 미처 자라야지!"하고 만다.
이 자라야 한다는 것은 내가 아니라 내 아내가 될 점순이의 키 말이다.
내가 여기에 와서 돈 한푼 안 받고 일하기를 삼 년하고 꼬바기 일곱 달 동안을 했다. 그런데도 미처 못 자랐다니까 이 키는 언제야 자라는 겐지 짜장 영문 모른다. 일을 좀더 잘해야 한다든지, 혹은 밥을 많이 먹는다고 노상 걱정이니까 좀 덜 먹어야 한다든지 하면 나도 얼마든지 할말이 많다. 허지만 점순이가 아직 어리니까 더 자라야 한다는 여기에는 어째 볼 수 없이 고만 빙빙하고 만다.
이래서 나는 애최 계약이 잘못된 걸 알았다. 이태면 이태, 삼년이면 삼년, 기한을 딱 작정하고 일을 해야 원 할 것이다. 덮어놓고 딸이 자라는 대로 성례를 시켜 주마, 했으니 누가 늘 지키고 섰는 것도 아니고, 그 키가 언제 자라는지 알 수 있는가. 그리고 난 사람의 키가 무럭무럭 자라는 줄만 알았지 붙배기 키에 모로만 벌어지는 몸도 있는 것을 누가 알았으랴. 때가 되면 장인님이 어련하랴 싶어서 군소리없이 꾸벅꾸벅 일만 해왔다. 그럼 말이다. 장인님이 제가 다 알아 채서,
"어참, 너 일 많이 했다. 고만 장가들어라." 하고 살림도 내주고 해야 나도 좋을 것이 아니냐. 시치미를 딱 떼고 도리어 그런 소리가 나올까봐서 지레 펄펄뛰고 이야단이다. 명색이 좋아 데릴사위지 일하기에 싱겁기도 할 뿐더러 이건 참 아무것도 아니다.
숙맥이 그걸 모르고 점순이의 키 자라기만 까맣게 기다리지 않았나.
언젠가는 하도 갑갑해서 자를 가지고 덤벼들어서 그 키를 한번 재볼까 했다. 마는 우리는 장인님이 내외를 해야 한다고 해서 마주 서 이야기도 한마디하는 법 없다.
우물길에서 언제나 마주칠 적이면 겨우 눈어림으로 재보고 하는 것인데 그럴 적마다 나는 저만침 가서 '제에미 키두!'하고 논둑에다 침을 퉤, 뱉는다. 아무리 잘 봐야 내 겨드랑(다른 사람보다 좀 크긴 하지만) 밑에서 넘을락말락 밤낮 요모양이다.
개 돼지는 푹푹 크는데 왜 이리도 사람은 안 크는지, 한동안 머리가 아프도록 궁리도 해보았다. 아하, 물동이를 자꾸 이니까 뼉다귀가 움츠라드나보다, 하고 내가 넌즛넌즈시 그 물을 대신 길어도 주었다. 뿐만 아니라 나무를 하러 가면 서낭당에 돌을 올려 놓고 '점순이의 키 좀 크게 해줍소사. 그러면 담엔 떡 갖다 놓고 고사드립죠니까.' 하고 치성도 한두 번 드린 것이 아니다. 어떻게 되먹은 킨지 이래도 막무가내니…….
그래 내 어저께 싸운 것이지 결코 장인님이 밉다든가 해서가 아니다.
모를 붓다가 가만히 생각을 해보니까 또 싱겁다. 이 벼가 자라서 점순이가 먹고 좀 큰다면 모르지만 그렇지도 못한 걸 내 심어서 뭘하는 거냐. 해마다 앞으로 축 불거지는 장인님의 아랫배(가 너무 먹는 걸 모르고 냇병이라나, 그 배)를 불리기 위하여 심곤 조금도 싶지 않다.
"아이구 배야!"
난 몰 붓다 말고 배를 쓰다듬으면서도 그대루 논둑으로 기어올랐다. 그리고 겨드랑에 꼈던 벼 담긴 키를 그냥 땅바닥에 털썩 떨어치며 나도 털썩 주저앉았다. 일이 암만 바빠도 나 배 아프면 고만이니까. 아픈 사람이 누가 일을 하느냐. 파릇파릇 돋아오른 풀 한숲을 뜯어 들고 다리의 거머리를 쑥쑥 문대며 장인님의 얼굴을 쳐다보았다.
논 가운데서 장인님도 이상한 눈을 해가지고 한참 날 노려보더니,
"넌 이자식, 왜 또 이래 응?"
"배가 좀 아파서유!"하고 풀 위에 슬며시 쓰러지니까 장인님은 약이 올랐다. 저도 논에서 철벙철벙 둑으로 올라오더니 잡은참 내 멱살을 움켜잡고 뺨을 치는 것이 아닌가……
"이자식아. 일 허다 말면 누굴 망해놀 속셈이냐. 이 대가릴 까놀자식?"
우리 장인님은 약이 오르면 이렇게 손버릇이 아주 못됐다. 또 사위에게 이자식 저자식 하는 이놈의 장인님은 어디 있느냐. 오죽해야 우리 동리에서 누굴 물론하고 그에게 욕을 안 먹는 사람은 명이 짜르다 한다. 조그만 아이들까지도 그를 돌아세놓고 욕필이(본 이름이 봉필이니까) 욕필이, 하고 손가락질을 할 만치 두루 인심을 잃었다. 허나 인심을 정말 잃었다면 욕보다 읍의 배참봉댁 마름으로 더 잃었다. 번히 마름이란 욕 잘하고, 사람 잘 치고, 그리고 생김생기길 호박개같애야 쓰는 거지만 장인님은 외양이 똑 됐다. 장인에게 닭마리나 좀 보내지 않는다든가 애벌논 때 품을 좀 안 준다든가 하면 그해 가을에는 영락없이 땅이 뚝뚝 떨어진다. 그러면 미리부터 돈도 먹고 술도 먹이고 안달재신으로 돌아치던 놈이 그 땅을 슬쩍 돌라 안는다. 이바람에 장인님집 외양간에는 눈깔 커다란 황소 한놈이 절로 엉금엉금 기어들고, 동리 사람들은 그 욕을 다 먹어가면서도 그래도 굽실굽실 하는 게 아닌가……
그러나 내겐 장인님이 감히 큰소리할 계제가 못된다.
뒷생각은 못하고 뺨 한 개를 딱 때려놓고는 장인님은 무색해서 덤덤히 쓴 침만 삼킨다. 난 그속을 퍽 잘 안다.
조금 있으면 갈도 꺾어야 하고 모도 내야 하고, 한참 바쁜 때인데 나 일 안하고 우리집으로 그냥 가면 고만이니까.
작년 이맘때도 트집을 좀 하니까 늦잠잔다구 돌멩이를 집어던져서 자는 놈의 발목을 삐게 해놨다. 사날씩이나 건숭 끙끙, 앓았더니 종당에는 거반 울상이 되지 않았는가……
"예, 그만 일어나 일 좀 해라. 그래야 올 갈에 벼 잘되면 너 장가 들지 않니."
그래 귀가 번쩍 띄어서 그날로 일어나서 남이 이틀 품들일 논을 혼자 삶아 놓으니까 장인님도 눈깔이 커다랗게 놀랐다. 그럼 정말로 가을에 와서 혼인을 시켜 줘야온 경우가 옳지 않겠나, 볏섬을 척척 들여쌓아도 다른 소리는 없고 물동이를 이고 들어오는 점순이를 담배통으로 가리키며,
"이 자식아, 미처 커야지 조걸 무슨 혼인을 한다구 그러니 원!"하고 남 낯짝만 붉혀 주고 고만이다.
골김에 그저 이놈의 장인님, 하고 댓돌에다 메꼰코 우리 고향으로 내뺄까 하다가 꾹꾹 참고 말았다.
참말이지 난 이꼴하고는 집으로 차마 못 간다. 장가를 들러갔다가 오죽 못났어야 그대로 쫓겨왔느냐고 손가락질을 받을 테니까…….
논둑에서 벌떡 일어나 한풀 죽은 장인님 앞으로 다가서며,
"난 갈 테야유. 그동안 사경 쳐내슈."
"너 사위로 왔지 어디 머슴살러 왔니?"
"그러면 얼찐 성례를 해줘야 안하지유. 밤낮 부려만 먹구 해준다, 해준다……"
"글쎄, 내가 안하는 거냐, 그년이 안 크니까."하고 어름어름 담배만 담으면서 늘 하는 소리를 또 늘어놓는다.
이렇게 따져나가면 언제든지 늘 나만 밑지고 만다. 이번엔 안 된다, 하고 대뜸 구장님한테로 판단 가자고 소맷자락을 내끌었다.
"아, 이자식이 왜 이래 어른을."
안 간다구 뻗디디구 이렇게 호령은 제맘대로 하지만 장인님 제가 내 기운은 못 당한다. 막 부려먹고 딸은 안 주고, 게다 땅땅 치는 건 다 뭐야…….
그러나 내 사실 참 장인님이 미워서 그런 것은 아니다. 그 전날, 왜 내가 새고 개 맞은 봉우리 화전밭을 혼자 갈고 있지 않았느냐. 밭가생이로 돌 적마다 야릇한 꽃내가 물컥물컥 코를 찌르고 머리 위에서 벌들은 가끔 붕, 붕, 소리를 친다. 바위 틈에서 샘물 소리밖에 안 들리는 산골짜기니까 맑은 하늘의 봄볕은 이불 속같이 따스하고 꼭 꿈꾸는 것 같다. 나는 몸이 나른하고 몸살(병을 아직 모르지만)이 날려구 그러는지 가슴이 울렁울렁하고 이랬다.
"어러이! 말이! 맘 마 마……"
이렇게 노래를 하며 소를 부리면 여느때 같으면 어깨가 으쓱으쓱한다. 웬일인지 밭을 반도 갈지 않아서 온몸이 맥이 풀리고 대구 짜증만 난다. 공연히 소만 들입다 두들기며……
"안야! 안야! 이 망할 자식의 소(장인님의 소니까) 대리를 꺾어들라."
그러나 내 속은 정말 안야 때문이 아니라 점심을 이고 온 점순이의 키를 보고 울화가 났던 것이다.
점순이는 뭐 그리 썩 예쁜 계집애는 못된다. 그렇다구 또 개떡이냐 하면 그런 것도 아니고, 꼭 내 아내가 돼야 할 만치 그저 툽툽하게 생긴 얼굴이다. 나보다 십년이 아래니까 올해 열여섯인데 몸은 남보다 두 살이나 덜 자랐다. 남은 잘도 훤칠히들 크건만 이건 위아래가 뭉툭한 것이 내 눈에는 헐없이 감참외 같다. 참외 중에는 감 참외가 제일 맛좋고 예쁘니까 말이다. 둥글고 커다란 눈은 서글서글하니 좋고 좀 지쳐 찢어졌지만 입은 밥술이나 톡톡히 먹음직하니 좋다. 아따, 밥만 많이 먹게 되면 팔자는 고만 아니냐. 헌데 한 가지 과가 있다면 가끔가다 몸이(장인님이 이걸 채신이 없이 들까분다고 하지만)너무 빨리빨리 논다. 그래서 밥을 나르다가 때없이 풀밭에서 깨빡을 쳐서 흙투성이 밥을 곧잘 먹인다. 안 먹으면 무안해 할까봐서 이걸 씹고 앉았느라면 으적으적 소리만 나고 돌을 먹는 겐지 밥을 먹는 겐지……,
그러나 이날은 웬일인지 성한 밥채루 밭머리에 곱게 내려 놓았다. 그리고 또 내외를 해야 하니까 저만큼 떨어져 이쪽으로 등을 향하고 웅크리고 앉아서 그릇나기를 기다린다.
내가 다 먹고 물러섰을 때, 그릇을 챙기는데 난 깜짝 놀라지 않았느냐. 고개를 푹 숙이고 밥함지에 그릇을 포개면서 날더러 들으라는지, 혹은 제 소린지,
"밤낮 일만 하다 말 텐가!"
하고 혼자서 쫑알거린다. 고대 잘 내외하다가 이게 무슨 소린가, 하고 난 정신이 얼떨떨했다. 그러면서도 한편 무슨 좋은 수가 있나 없는가 싶어서 나도 공중을 대고 혼잣말로,
"그럼 어떡해?"
하니까,
"성례시켜 달라지 뭘 어떡해."
하고 되알지게 쏘아붙이고 얼굴이 빨개져서 산으로 그저 도망친다.
나는 잠시 동안 어떻게 되는 심판인지 맥을 몰라서 그 뒷모양만 덤덤히 바라보았다.
봄이 되면 온갖 초목이 물이 오르고 싹이 트고 한다. 사람도 아마 그런가 보다, 하고 며칠내에 부쩍 (속으로) 자란 듯싶은 점순이가 여간 반가운 것이 아니다. 이런 걸 멀쩡하게 아직 어리다구 하니까…….
우리가 구장님을 찾아갔을 때 그는 싸리문 밖에 있는 돼지우리에서 죽을 퍼주고 있었다. 서울엘 좀 갔다오더니 사람은 점잖아야 한다구 웃쇰이(얼른 보면 지붕 위에 앉은 제비꼬랑지 같다) 양쪽으로 뾰죽히 삐치고 그걸 애헴, 하고 늘 쓰담는 손버릇이 있다.
우리를 멀뚱히 쳐다보고 미리 알아챘는지,
"왜 일들 허다 말구 그래?"하더니 손을 올려서 그 애헴을 한번 후딱 했다.
"구장님! 우리 장인님과 츰에 계약하기를……"
먼저 덤비는 장인님을 뒤로 떠다밀고 내가 허둥지둥 달려들다가 가만히 생각하고, '아니 우리 빙장님과 츰에.'하고 첫번부터 다시 말을 고쳤다. 장인님은 빙장님, 해야 좋아하고 밖에 나와서 장인님, 하면 괜스리 골을 내려고 든다. 뱀두 뱀이래야 좋으냐구 창피스러우니 남 듣는 데는 제발 빙장님, 빙모님, 하라구 일상 당조심을 받아 오면서 난 그것두 자꾸 잊는다.
당장두 장인님, 하나 옆에서 내 발등을 꾹 밟고 곁눈질을 흘기는 바람에야 겨우 알았지만……
구장님도 내 이야기를 자세히 듣더니 퍽 딱한 모양이었다. 하기야 구장님뿐만 아니라 누구든지 다 그럴 게다.
길게 길러둔 새끼손톱으로 코를 후벼서 저리 탁 튀기며,
"그럼 봉필씨! 얼른 성례를 시켜 주구려, 그렇게까지 제가 하구싶다는 걸……"
하고 내 짐작대로 말했다. 그러나 이말에 장인님이 삿대질로 눈을 부라리고,
"아 성례구 뭐구 계집애년이 미처 자라야 할 게 아닌가?"
하니까 고만 멀쑤룩해져서 입맛만 쩍쩍 다실 뿐이 아닌가.
"그것두 그래!"
"그래, 거진 사년 동안에도 안 자랐더니 그 킨 은제 자라지유"다 그만두구 사경 내슈……"
"글쎄, 이자식아! 내가 크질 말라구 그랬니. 왜 날 보구 떼냐?"
"빙모님은 참새만한 것이 그럼 어떻게 앨 낳지유?(사실 빙모님은점순이보다도 귓 배기가 작다)"
장인님은 이말을 듣고 껄껄 웃더니(그러나 암만 해두 돌 씹은 상이다) 코를 푸는 척하고 날 은근히 곯리려고 팔꿈치로 옆 갈비께를 퍽 치는 것이다.
더럽다. 나두 종아리의 파리를 쫓는 척하고 허리를 구부리며 그 궁둥이를 콱 떼밀었다. 장인님은 앞으로 우찔근하고 싸리문께로 쓰러질 듯하다 몸을 바로 고치더니 눈총을 몹시 쏘았다. 이런 쌍년의 자식, 하곤 싶으나 남의 앞이라니 차마 못하고 섰는 그 꼴이 보기에 퍽 쟁그러웠다.
그러나 이밖에는 별반 신통한 귀정을 얻지 못하고 도로 논으로 돌아와서 모를 부었다. 왜냐면 장인님이 뭐라구 귓속말로 수군수군하고 간 뒤다. 구장님이 날 위해서 조용히 데리고 아래와 같이 일러주었기 때문이다(뭉태의 말은 구장님이 장인님에게 땅 두 마지기 얻어부치니까 그래 꾀엿다고 하지만 난 그렇게 생각 않는다)
"자네 말두 하기야 옳지, 암 나이 찼으니 아들이 급하다는 게 잘못된 말은 아니야.
허지만 농사가 한층 바쁜 때 일을 안한다든가집으로 달아 난다든가 하면 손해죄루 그것두 징역을 가거든!(여기에 그만 정신이 번쩍 났다) 왜 요전에 삼포말서 산에 불 좀 놓았다구 징역간 거 못 봤나. 제 산에 불을 놓아도 징역을 가는 이땐데 남의 농사를 버려두니 죄가 얼마나 더 중한가. 그리고 자넨 정장을(사경 받으러 정장 가겠다 했다) 간대지만 그러면 괜스리 죄를 들쓰고 들어가는 걸세. 또 결혼두 그렇지. 법률에 성년이란 게 있는데 스물하나가 돼야지 비로소 결혼을 할 수가 있는걸세. 자넨 물론 아들이 늦을 걸 염려하지만 점순이루 말하면 이제 겨우 열여섯이 아닌가. 그렇지만 아까 빙장님의 말씀이 올 갈에는 열일을 제치고라두 성례를 시켜주겠다 하시니 좀 고마울겐가. 빨리 가서 모붓든 거나 마저 붓게, 군소리 말구 어서 가."
그래서 오늘 아침까지 끽소리 없이 왔다.
장인님과 내가 싸운 것은 지금 생각하면 전혀 뜻밖의 일이라 안할 수 없다.
장인님으로 말하면 요즈막 작인들에게 행세를 좀 하고 싶다고 해서,
"돈 있으면 양반이지 별게 있느냐!"
하고 일부러 아랫배를 쑥 내밀고 걸음도 뒤틀리게 걷고 하는 이판이다. 이까진 나쯤 두들기다 남의 땅을 가지고 모처럼 닦아놓았던 가문을 망친다든가 할 어른이 아니다. 또 나로 논지면 아무쪼록 잘 봬서 점순이에게 얼른 장가를 들어야 하지 않느냐… 이렇게 말하자면 결국 어젯밤 뭉태네 집에 마슬간 것이 썩 나빴다. 낮에 구장님 앞에서 장인님과 내가 싸운 것을 어떻게 알았는지 대구 빈정거리는 것이 아닌가.
"그래 맞구두 그걸 가만 둬?"
"그럼 어떡허니?"
"임마, 봉필일 모판에다 거꾸로 박아놓지 뭘 어떡해?"하고 괜히 내 대신 화를 내가지고 주먹질을 하다 등잔까지 쳤다. 놈이 번히 괄괄은 하지만 그래놓고 날더러 석유값을 물라구 막 찌다우를 붙는다. 난 어안이 벙벙해서 잠자코 앉았으니까 저만 연신 지껄이는 소리가,
"밤낮 일만 해주구 있을 테냐?"
"영득이는 일년을 살구두 장갈 들었는데 넌 사년이나 살구두 더살아야 해?"
"네가 세번째 사윈줄이나 아니? 세번째 사위"
"남의 일이라두 분하다. 이자식아, 우물에 가 빠져 죽어."
나중에는 겨우 손톱으로 목을 따라고까지 하고, 제 아들같이 함부로 훅닥이었다.
별의별 소리를 다해서 그대로 옮길 수는 없으나 그 줄거리는 이렇다…….
우리 장인님 딸이 셋이 있는데 맏딸은 재작년 가을에 시집을 갔다. 정말은 시집을 간 것이 아니라 그 딸도 데릴사위를 해가지고 있다가 내보냈다. 그런데 딸이 열 살 때부터 열아홉 즉 십년 동안에 데릴사위를 갈아들이기를, 동리에선 사위부자라고 이름이 났지마는 열네 놈이란 참 너무 많다. 장인님이 아들은 없고 딸만 있는 고로 그 담 딸을 데릴사위를 해올 때까지는 부려먹지 않으면 안된다. 물론 머슴을 두면 좋지만 그건 돈이 드니까, 일 잘하는 놈을 고르느라고 연방 바꿔들였다. 또 한편 놈들이 욕만 줄창 퍼붓고 심히도 부려먹으니까 밸이 상해서 달아나기도 했겠지, 점순이는 둘째딸인데 내가 일테면 그 세번째 데릴사위로 들어온 셈이다. 내 담으로 네번째 놈이 들어올 것을 내가 일도 잘하고 그리고 사람이 좀 어수록하니까 장인님이 잔뜩 붙들고 놓질 않는다. 세째딸이 인제 여섯살, 적어두 열 살은 돼야 데릴사위를 할 테므로 그 동안은 죽도록 부려먹어야 된다. 그러니 인제는 속 좀 채리고 장가를 들여달라구 떼를 쓰고 나자빠져라, 이것이다.
나는 겉으로 엉, 엉, 하며 귓등으로 들었다. 뭉태는 땅을 얻어부치다가 떨어진 뒤로는 장인님만 보면 공연히 못 먹어서 으릉거린다. 그것도 장인님이 저 달라고 할 적에 제 집에서 위한다는 그 감투(예전에 원님이 쓰던 것이라나, 옆구리에 뽕뽕 좀 먹은 걸레)를 선뜻 주었더면 그럴 리도 없었던 걸…….
그러나 나는 뭉태란 놈의 말을 전수히 곧이듣지 않았다. 꼭 곧이들었다면 간밤에 와서 장인님과 싸웠지 무사히 있었을 리가 없지 않은가. 그러면 딸에게까지 인심을 잃은 장인님이 혼자 나빴다.
실토이지 나는 점순이가 아침상을 가지고 나올 때까지는 오늘은 또 얼마나 밥을 담았나, 하고 이것만 생각했다. 상에는 된장찌개하고 간장 한 종지, 조밥 한 그릇, 그리고 밥보다 더 수부룩하게 담은 산나물이 한 대접, 이렇다. 나물은 점순이가 틈틈이 해오니까 두 대접이고 네 대접이고 멋대로 먹어도 좋으나 밥은 장인님이 한 사발 외엔 더 주지 말라고 해서 안된다. 그런데 점순이가 그 상을 내 앞에 내려 놓으며 제 말로 지껄이는 소리가,
"구장님한테 갔다 그냥 온담 그래!"하고 엊그제 산에서와 같이 되우 쫑알거린다.
딴은 내가 더 단단히 덤비지 않고 만 것이 좀 어리석었다, 속으로 그랬다.
나도 저쪽 벽을 향하여 외면하면서 내 말로,
"안된다는 걸 그럼 어떡헌담!"하니까,
"쇰을 잡아채지 그냥 둬, 이 바보야!"
하고 또 얼굴이 빨개지면서 성을 내며 안으로 샐죽하니 튀들어가지 않느냐, 이때 아무도 본 사람이 없었게 망정이지 보았다면 내 얼굴이 에미 잃은 황새새끼처럼 가여웁다 했을 것이다.
사실 이때만치 슬펐던 일이 또 있었는지 모른다. 다른 사람은 암만 못생겼다 해두 괜찮지만 내 아내 될 점순이가 병신으로 본다면 참 신세는 따분하다. 밥을 먹은 뒤지게를 지고 일터로 갈려 하다 도로 벗어던지고 바깥 마당 공석 위에 드러누워서 나는 차라리 죽느니만 같지 못하다 생각했다.
내가 일 안하면 장인님 저는 나이가 먹어 못하고 결국 농사 못 짓고 만다. 뒷짐으로 트림을 꿀꺽하고 대문 밖으로 나오다 날 보고서,
"이자식아, 왜 또 이러니."
"관격이 났어유, 아이구 배야!"
"기껀 밥 처먹구 무슨 관격이야, 남의 농사 버려주면 이자식아징역간다 봐라!"
"가두 좋아유, 아이구 배야!"
참말 난 일 안해서 징역 가도 좋다 생각했다. 일후 아들을 낳아도 그 앞에서 바보, 바보, 이렇게 별명을 들을 테니까 오늘은 열쪽이 난대도 결정을 내고 싶었다. 장인님이 일어나라고 해도 내가 안 일어나니까 눈에 독이 올라서 저편으로 힝하게 가더니 지게막대기를 들고 왔다. 그리고 그걸로 내 허리를 마치 돌 떠넘기듯이 쿡 찍어서 넘기고 넘기고 했다. 밥을 잔뜩 먹어 딱딱한 배가 그럴 적마다 퉁겨지면서 밸창이 꼿꼿한 것이 여간 켕기지 않았다. 그래도 안 일어나니까 이번에는 배를 지게 막대기로 위에서 쿡쿡 찌르고 발길로 옆구리를 차고 했다. 장인님은 원체 심청이 궂어서 그러지만 나도 저만 못하지 않게 배를 채었다. 아픈 것을 눈을 꽉 감고 넌 해라 난 재밌단 듯이 있었으나 볼기짝을 후려갈길 적에는 나도 모르는 결에 벌떡 일어나서 그 수염을 잡아챘다. 마는 내 골이 난 것이 아니라 정말은 아까부터 벽 뒤 울타리 구멍으로 점순이가 우리들의 꼴을 몰래 엿보고 있었기 때문이다.
가뜩이나 말 한마디 톡톡히 못한다고 바라보는데 매까지 잠자코 맞는 걸 보면 짜장 바보로 알 게 아닌가. 또 점순이도 미워하는 이까짓 놈의 장인님하곤 아무것도 안되니까 막 때려도 좋지만 사정 보아서 수염만 채고(제 원대로 했으니까 이때 점순이는 퍽 기뻤겠지) 저기까지 잘 들리도록 '이걸 까셀라부다!'하고 소리를 쳤다.
장인님은 더 약이 바짝 올라서 잡은 참 지게막대기로 내 어깨를 그냥 내려갈겼다. 정신이 다 아찔하다. 다시 고개를 들었을 때 그때엔 나도 온몸에 약이 올랐다. 이녀석의 장인님을, 하고 눈에서 불이 퍽 나서 그 아래 밭 있는 넝알로 그대로 떠밀어 굴려버렸다.
"부려만 먹구 왜 성례 안하지유!"
나는 이렇게 호령했다. 허지만 장인님이 선뜻 오냐 낼이라두 성례시켜 주마, 했으면 나도 성가신 걸 그만두었을지 모른다. 나야 이러면 때린 건 아니니까 나중에 장인 쳤다는 누명도 안 들을 터이고 얼마든지 해도 좋다.
한번은 장인님이 헐떡헐떡 기어서 올라오더니 내 바짓가랭이를 요렇게 노리고서 단박 움켜잡고 매달렸다. 악, 소리를 치고 나는 그만 세상이 다 팽그르 도는 것이,
"빙장님! 빙장님! 빙장님!"
"이자식! 잡아먹어라, 잡아먹어!"
"아! 아! 할아버지! 살려줍쇼, 할아버지!"하고 두팔을 허둥지둥 내절 적에는 이마에 진땀이 쭉 내솟고 인젠 참으로 죽나보다 했다. 그래두 장인님은 놓질 않더니 내가 기어이 땅바닥에 쓰러져서 거진 까무러치게 되니까 놓는다. 더럽다, 더럽다. 이게 장인님인가? 나는 한참을 못 일어나고 쩔쩔맸다. 그러나 얼굴을 드니(눈엔 참 아무 것도 보이지 않았다)사지가 부르르 떨리면서 나도 엉금엉금 기어가 장인님의 바짓가랭이를 꽉 움키고 잡아나꿨다.
내가 머리가 터지도록 매를 얻어맞은 것이 이 때문이다. 그러나 여기가 또한 우리 장인님이 유달리 착한 곳이다.
여느 사람이면 사경을 주어서라도 당장 내어쫓았지, 터진 머리를 볼솜으로 손수 지져 주고, 호주머니에 희연 한 봉을 넣어 주고 그리고,
"올 갈엔 꼭 성례를 시켜 주마. 암만 말구 가서 뒷골의 콩밭이나얼른 갈아라."
하고 등을 뚜덕여 줄 사람이 누구냐. 나는 장인님이 너무나 고마워서 어느덧 눈물까지 났다.
점순이를 남기고 인젠 내쫓기려니 하다 뜻밖의 말을 듣고,
"빙장님! 인제 다시는 안그러겠어유!"
이렇게 맹세를 하며 부랴부랴 지게를 지고 일터로 갔다. 그러나 이때는 그걸 모르고 장인님을 원수로만 여겨서 잔뜩 잡아당겼다.
"아! 아! 이놈아! 놔라, 놔."
장인님은 헷손질을 하며 솔개미에 챈 닭의 소리를 연해 질렀다. 놓긴 왜, 이왕이면 호되게 혼을 내주리라 생각하고 짖궂이 더 댕겼다. 마는 장인님이 땅에 쓰러져서 눈에 눈물이 피잉 도는 것을 알고 좀 겁도 났다.
"할아버지! 놔라, 놔, 놔, 놔, 놔라."
그래도 안되니까,
"애 점순아! 점순아!"
이 악장에 안에 있었던 장모님과 점순이가 헐레벌떡하고 단숨에 뛰어 나왔다. 나의 생각에 장모님은 제 남편이니까 역성을 할는지도 모른다. 그러나 점순이는 내 편을 들어서 속으로 고수해 하겠지---. 대체 이게 웬 속인지(지금까지도 난 영문을 모른다) 아버질 혼내 주기는 제가 내래 놓고 이제 와서는 달겨들며,
"에그머니! 이 망할 게 아버지 죽이네!"
하고, 귀를 뒤로 잡아댕기며 마냥 우는 것이 아니냐. 그만 여기에 기운이 탁 꺾이어 나는 얼빠진 등신이 되고 말았다. 장모님도 덤벼들어 한쪽 귀마저 뒤로 잡아채면서 또 우는 것이다. 이렇게 꼼짝도 못하게 해놓고 장인님은 지게막대기를 들어서 사뭇 내려조졌다. 그러나 나는 구태여 피하려지도 않고 암만해도 그 속 알 수 없는 점순이의 얼굴만 멀거니 들여다보았다.
"이자식! 장인 입에서 할아버지 소리가 나오도록 해?"`;

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
            {
                id: 1,
                question: "이 소설에서 장인이 점순이의 성례를 미루는 표면적인 이유와 진짜 이유(내면적 의도)는 각각 무엇인지 서술하시오.",
                correctAnswer: "장인이 점순이의 성례를 미루는 표면적인 이유는 '점순이의 키가 아직 다 자라지 않아서'이다. 하지만 진짜 이유는 아들을 두지 못해 일손이 부족한 상황에서, 데릴사위인 '나'에게 일을 시키며 노동력을 착취하기 위해서이다.",
                correctParts: ["장인이 점순이의 성례를 미루는 표면적인 이유는 '점순이의 키가 아직 다 자라지 않아서'이다.", "하지만 진짜 이유는 아들을 두지 못해 일손이 부족한 상황에서, 데릴사위인 '나'에게 일을 시키며 노동력을 착취하기 위해서이다."],
                distractors: ["장인이 점순이의 성례를 미루는 표면적인 이유는 '나'의 나이가 아직 충분하지 않아서이다.", "하지만 진짜 이유는 점순이가 성례를 원하지 않기 때문이다.", "장인이 점순이의 성례를 서두르는 이유는 '나'가 일을 잘해서이다."]
            },
            {
                id: 2,
                question: "주인공 '나'와 '장인'의 성격을 비교하고, 두 인물의 성격 차이가 갈등을 어떻게 유발하고 심화시키는지 서술하시오.",
                correctAnswer: "주인공 '나'는 순박하고 우직하지만 다소 어리숙하고 소극적인 성격의 인물이다. 반면, 장인은 자신의 이익을 위해서는 수단과 방법을 가리지 않는 교활하고 계산적인 성격이다. 이러한 두 인물의 성격 차이는 갈등을 지속시킨다. '나'는 장인의 의도를 제대로 파악하지 못하고 계속 속아 넘어가고, 장인은 그런 '나'의 순박함을 이용하여 계속해서 노동력을 착취하며 성례 약속을 지키지 않기 때문에 갈등이 해소되지 않고 반복된다.",
                correctParts: ["주인공 '나'는 순박하고 우직하지만 다소 어리숙하고 소극적인 성격의 인물이다.", "반면, 장인은 자신의 이익을 위해서는 수단과 방법을 가리지 않는 교활하고 계산적인 성격이다.", "이러한 두 인물의 성격 차이는 갈등을 지속시킨다.", "'나'는 장인의 의도를 제대로 파악하지 못하고 계속 속아 넘어가고, 장인은 그런 '나'의 순박함을 이용하여 계속해서 노동력을 착취하며 성례 약속을 지키지 않기 때문에 갈등이 해소되지 않고 반복된다."],
                distractors: ["주인공 '나'는 교활하고 계산적인 성격의 인물이다.", "반면, 장인은 순박하고 우직한 성격이다.", "이러한 성격은 갈등을 해소한다."]
            },
            {
                id: 3,
                question: "점순이는 '나'에게 장인과 싸우라고 부추기다가도, 막상 싸움이 커지자 아버지 편을 듭니다. 이러한 점순이의 이중적인 행동에 담긴 심리는 무엇일지 추측하여 서술하시오.",
                correctAnswer: "점순이의 이중적인 행동에는 복합적인 심리가 담겨 있다. 먼저 '나'를 부추긴 것은 성례를 하고 싶은 마음과 '나'의 소극적인 태도에 대한 답답함 때문이다. 하지만 막상 싸움이 커져 아버지가 맞는 상황이 되자, 딸로서 아버지를 걱정하는 마음과 당시의 가부장적 사회 분위기 속에서 아버지의 권위에 순응하는 모습을 보이는 것이다. 결국 점순이는 자신의 욕망과 현실적인 제약 사이에서 갈등하는 인물로 볼 수 있다.",
                correctParts: ["점순이의 이중적인 행동에는 복합적인 심리가 담겨 있다.", "먼저 '나'를 부추긴 것은 성례를 하고 싶은 마음과 '나'의 소극적인 태도에 대한 답답함 때문이다.", "하지만 막상 싸움이 커져 아버지가 맞는 상황이 되자, 딸로서 아버지를 걱정하는 마음과 당시의 가부장적 사회 분위기 속에서 아버지의 권위에 순응하는 모습을 보이는 것이다.", "결국 점순이는 자신의 욕망과 현실적인 제약 사이에서 갈등하는 인물로 볼 수 있다."],
                distractors: ["점순이의 일관된 행동은 단순한 심리를 드러낸다.", "점순이는 성례에 전혀 관심이 없다.", "점순이는 아버지보다 '나'를 더 중요하게 생각한다."]
            },
            {
                id: 4,
                question: "이 소설의 배경인 '봄'이라는 계절이 작품의 전반적인 분위기와 사건 전개에 어떤 영향을 미치는지 서술하시오.",
                correctAnswer: "이 소설의 배경인 '봄'이라는 계절은 만물이 소생하고 생명력이 넘치는 계절이다. 이러한 분위기는 주인공 '나'와 점순이의 성례에 대한 기대감과 설렘을 고조시키는 역할을 한다. 또한, '봄'은 '나'와 장인의 갈등이 본격적으로 시작되고 폭발하는 계절적 배경으로 작용하여, 작품의 해학적이고 생동감 넘치는 분위기를 형성하는 데 기여한다.",
                correctParts: ["이 소설의 배경인 '봄'이라는 계절은 만물이 소생하고 생명력이 넘치는 계절이다.", "이러한 분위기는 주인공 '나'와 점순이의 성례에 대한 기대감과 설렘을 고조시키는 역할을 한다.", "또한, '봄'은 '나'와 장인의 갈등이 본격적으로 시작되고 폭발하는 계절적 배경으로 작용하여, 작품의 해학적이고 생동감 넘치는 분위기를 형성하는 데 기여한다."],
                distractors: ["'봄'은 추운 계절이다.", "'봄'은 갈등을 해소하는 배경이다.", "'봄'은 비극적인 분위기를 만든다."]
            },
            {
                id: 5,
                question: "이 소설은 가난한 데릴사위의 노동력 착취라는 비극적인 내용을 다루면서도 독자에게 웃음을 유발합니다. 작가가 이러한 '해학적' 방식을 사용한 의도는 무엇일지 서술하시오.",
                correctAnswer: "작가는 노동력 착취라는 비극적 현실을 해학적으로 그려냄으로써, 그 비극성을 더욱 강조하고 독자가 웃음 속에서 현실의 모순을 날카롭게 인식하도록 유도한다. 만약 이 상황을 심각하게만 그렸다면 독자는 무거운 부담감을 느꼈을 것이다. 하지만 해학을 통해 독자는 인물들에게 연민을 느끼며 웃을 수 있고, 그 웃음 뒤에 숨겨진 당대 농촌 사회의 구조적 문제점을 더욱 효과적으로 비판하고 풍자하는 것이다.",
                correctParts: ["작가는 노동력 착취라는 비극적 현실을 해학적으로 그려냄으로써, 그 비극성을 더욱 강조하고 독자가 웃음 속에서 현실의 모순을 날카롭게 인식하도록 유도한다.", "만약 이 상황을 심각하게만 그렸다면 독자는 무거운 부담감을 느꼈을 것이다.", "하지만 해학을 통해 독자는 인물들에게 연민을 느끼며 웃을 수 있고, 그 웃음 뒤에 숨겨진 당대 농촌 사회의 구조적 문제점을 더욱 효과적으로 비판하고 풍자하는 것이다."],
                distractors: ["작가는 노동력 착취를 긍정적으로 그린다.", "해학은 비극을 약화시킨다.", "웃음은 사회 비판과 무관하다."]
            },
            {
                id: 6,
                question: "소설의 마지막에서 '나'는 장인의 약속을 또다시 믿고 일터로 나갑니다. 이러한 결말은 갈등이 해소되지 않고 반복될 것임을 암시합니다. 이러한 '순환 구조'의 결말이 작품의 주제를 어떻게 효과적으로 드러내는지 서술하시오.",
                correctAnswer: "이 소설의 순환 구조적 결말은 '나'와 장인의 갈등이 일시적으로 봉합될 뿐, 근본적으로 해결되지 않았음을 보여준다. 이는 어리숙하고 순박한 농민('나')이 교활한 지배 계층('장인')에게 계속해서 착취당할 수밖에 없는 1930년대 농촌의 구조적 모순과 암담한 현실을 상징적으로 드러낸다. 갈등이 해결되지 않고 반복될 것을 암시함으로써, 작품의 현실 비판적 주제 의식을 더욱 강화하는 효과를 가진다.",
                correctParts: ["이 소설의 순환 구조적 결말은 '나'와 장인의 갈등이 일시적으로 봉합될 뿐, 근본적으로 해결되지 않았음을 보여준다.", "이는 어리숙하고 순박한 농민('나')이 교활한 지배 계층('장인')에게 계속해서 착취당할 수밖에 없는 1930년대 농촌의 구조적 모순과 암담한 현실을 상징적으로 드러낸다.", "갈등이 해결되지 않고 반복될 것을 암시함으로써, 작품의 현실 비판적 주제 의식을 더욱 강화하는 효과를 가진다."],
                distractors: ["순환 구조는 갈등이 완전히 해결되었음을 보여준다.", "결말은 희망적인 미래를 암시한다.", "순환 구조는 주제와 무관하다."]
            },
            {
                id: 7,
                question: "소설 속에서 '나'의 저항 방식은 점순이의 충고를 계기로 소극적인 방식에서 적극적인 방식으로 변화합니다. '나'의 저항 방식이 어떻게 변화했는지 구체적인 예를 들어 비교하고, 그 의미를 서술하시오.",
                correctAnswer: "점순이의 충고를 받기 전, '나'의 저항 방식은 일을 하다 말고 꾀병을 부리는 등 매우 소극적이고 간접적인 방식이었다. 하지만 점순이가 '바보'라며 질책한 후, '나'는 장인의 수염을 잡아채고, 장인을 언덕 아래로 굴리는 등 훨씬 적극적이고 직접적인 방식으로 저항하게 된다. 이러한 변화는 점순이와의 성례에 대한 '나'의 간절함이 커졌음을 의미하며, 그의 순박한 성품 속에 숨겨진 저항 의지를 보여준다.",
                correctParts: ["점순이의 충고를 받기 전, '나'의 저항 방식은 일을 하다 말고 꾀병을 부리는 등 매우 소극적이고 간접적인 방식이었다.", "하지만 점순이가 '바보'라며 질책한 후, '나'는 장인의 수염을 잡아채고, 장인을 언덕 아래로 굴리는 등 훨씬 적극적이고 직접적인 방식으로 저항하게 된다.", "이러한 변화는 점순이와의 성례에 대한 '나'의 간절함이 커졌음을 의미하며, 그의 순박한 성품 속에 숨겨진 저항 의지를 보여준다."],
                distractors: ["'나'의 저항은 계속 소극적이었다.", "'나'는 점순이의 충고를 무시했다.", "저항 방식의 변화는 의미가 없다."]
            },
            {
                id: 8,
                question: "뭉태는 '나'에게 장인의 과거 행적을 알려주며 갈등을 부추기는 역할을 합니다. 작품 전체에서 뭉태라는 인물이 하는 기능은 무엇인지 서술하시오.",
                correctAnswer: "뭉태는 '나'에게 장인의 과거 행적을 알려주며 갈등을 심화시키는 촉매제 역할을 한다. 그는 장인에게 개인적인 원한을 품고 있기에 그의 말이 모두 객관적인 사실은 아닐 수 있지만, 그의 말을 통해 독자들은 장인의 교활한 성격을 다시 한번 확인하고, '나'가 처한 상황이 구조적인 문제임을 암시하는 기능을 수행한다.",
                correctParts: ["뭉태는 '나'에게 장인의 과거 행적을 알려주며 갈등을 심화시키는 촉매제 역할을 한다.", "그는 장인에게 개인적인 원한을 품고 있기에 그의 말이 모두 객관적인 사실은 아닐 수 있지만, 그의 말을 통해 독자들은 장인의 교활한 성격을 다시 한번 확인하고, '나'가 처한 상황이 구조적인 문제임을 암시하는 기능을 수행한다."],
                distractors: ["뭉태는 '나'와 장인의 갈등을 해소하는 역할을 한다.", "뭉태는 객관적인 정보만 제공한다.", "뭉태는 작품에서 중요하지 않은 인물이다."]
            },
            {
                id: 9,
                question: "다음 <보기>의 관점을 바탕으로, 이 작품의 서술자인 '나'가 '신뢰할 수 없는 서술자'의 특징을 가지고 있는지 판단하고, 그 근거를 본문에서 찾아 서술하시오.\n\n<보기>\n'신뢰할 수 없는 서술자'란 지식이나 경험이 부족하거나, 개인적인 편견에 사로잡혀 사건의 전모를 정확하게 파악하지 못하고 독자에게 왜곡된 정보를 전달하는 서술자를 말한다. 독자는 서술자의 말을 곧이곧대로 믿기보다, 서술자가 파악하지 못하는 행간의 의미나 아이러니를 읽어내며 작품을 더 깊이 이해하게 된다.",
                correctAnswer: "'나'는 <보기>의 '신뢰할 수 없는 서술자'의 특징을 가지고 있다. 그 근거로, '나'는 장인의 교활한 의도를 제대로 파악하지 못하고 \"점순이의 키가 자라지 않아서\" 성례를 못 한다는 말을 곧이곧대로 믿는 등 상황을 주관적으로 인식하는 모습을 보인다. 또한 점순이가 싸움에서 장인 편을 들었을 때 \"대체 이게 웬 속인지\"라며 상황의 본질을 이해하지 못하고, 장인이 마지막에 다시 약속하자 \"너무나 고마워서 눈물까지 났다\"고 서술하는 등, 독자는 '나'의 서술을 통해 역설적으로 장인의 교활함과 '나'의 어리숙함을 파악하게 된다. 따라서 독자는 '나'의 서술 너머에 있는 진실을 읽어내며 작품의 해학성과 비판 의식을 더 깊이 이해할 수 있다.",
                correctParts: ["'나'는 <보기>의 '신뢰할 수 없는 서술자'의 특징을 가지고 있다.", "그 근거로, '나'는 장인의 교활한 의도를 제대로 파악하지 못하고 \"점순이의 키가 자라지 않아서\" 성례를 못 한다는 말을 곧이곧대로 믿는 등 상황을 주관적으로 인식하는 모습을 보인다.", "또한 점순이가 싸움에서 장인 편을 들었을 때 \"대체 이게 웬 속인지\"라며 상황의 본질을 이해하지 못하고, 장인이 마지막에 다시 약속하자 \"너무나 고마워서 눈물까지 났다\"고 서술하는 등, 독자는 '나'의 서술을 통해 역설적으로 장인의 교활함과 '나'의 어리숙함을 파악하게 된다.", "따라서 독자는 '나'의 서술 너머에 있는 진실을 읽어내며 작품의 해학성과 비판 의식을 더 깊이 이해할 수 있다."],
                distractors: ["'나'는 신뢰할 수 있는 서술자이다.", "'나'는 상황을 정확히 파악한다.", "독자는 '나'의 말을 그대로 믿어야 한다."]
            },
            {
                id: 10,
                question: "이 작품에 나타난 '나'와 '장인'의 개인적인 갈등이 1930년대 농촌 사회의 어떤 구조적인 문제점을 상징적으로 보여주는지, 장인의 직업인 마름의 역할과 관련지어 종합적으로 서술하시오.",
                correctAnswer: "이 작품에 나타난 '나'와 '장인'의 개인적인 갈등은 1930년대 일제강점기 농촌 사회의 구조적인 모순을 상징적으로 보여준다. 장인은 지주를 대신해 소작농을 관리하는 마름으로서, 지주-마름-소작농으로 이어지는 수직적 수탈 구조의 중간 착취자 역할을 한다. 그는 데릴사위라는 봉건적 제도를 악용하여 '나'의 노동력을 무상으로 착취하는데, 이는 당시 마름이 소작농을 상대로 행했던 부당한 착취와 그 맥을 같이 한다. 결국, 순박한 농민인 '나'가 교활한 장인에게 계속해서 속고 착취당하는 모습은, 개인의 어리숙함 때문만이 아니라 당시 농민들이 사회 구조적으로 착취당할 수밖에 없었던 암담한 현실을 집약적으로 보여주는 것이다.",
                correctParts: ["이 작품에 나타난 '나'와 '장인'의 개인적인 갈등은 1930년대 일제강점기 농촌 사회의 구조적인 모순을 상징적으로 보여준다.", "장인은 지주를 대신해 소작농을 관리하는 마름으로서, 지주-마름-소작농으로 이어지는 수직적 수탈 구조의 중간 착취자 역할을 한다.", "그는 데릴사위라는 봉건적 제도를 악용하여 '나'의 노동력을 무상으로 착취하는데, 이는 당시 마름이 소작농을 상대로 행했던 부당한 착취와 그 맥을 같이 한다.", "결국, 순박한 농민인 '나'가 교활한 장인에게 계속해서 속고 착취당하는 모습은, 개인의 어리숙함 때문만이 아니라 당시 농민들이 사회 구조적으로 착취당할 수밖에 없었던 암담한 현실을 집약적으로 보여주는 것이다."],
                distractors: ["갈등은 개인적인 문제일 뿐이다.", "장인은 마름이 아니다.", "작품은 사회 구조를 비판하지 않는다."]
            }
        ];

        // 5단계 초기화
        function initStage5() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '김유정 <봄봄>';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
        // 학습 완료 시스템을 위한 데이터 export
        window.learningResultData = {
            totalStages: totalStages || 5,
            totalCorrect: totalCorrect || 0,
            totalWrong: totalWrong || 0,
            totalAccuracy: totalAccuracy || 0,
            totalScore: totalScore || 0,
            totalElapsedTime: totalElapsedTime || (Date.now() - globalStartTime),
            stagesDetail: stageResults || {}
        };
        console.log('학습 데이터 export:', window.learningResultData);

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
            // 학습 완료 버튼 추가
            if (typeof addCompleteLearningButton === 'function') {
                setTimeout(() => addCompleteLearningButton(), 500);
            }
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stageResults,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `봄봄_워크북_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>