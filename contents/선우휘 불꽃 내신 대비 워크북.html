<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>선우휘 &lt;불꽃&gt; 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">선우휘 &lt;불꽃&gt;</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                {
                    id: 1,
                    text: "이 작품은 ( 3·1 운동 / 6.25 전쟁 )부터 한국 전쟁까지 한국 근현대사의 비극을 배경으로 하고 있습니다.",
                    highlight: "( 3·1 운동 / 6.25 전쟁 )",
                    options: ["3·1 운동", "6.25 전쟁"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "주인공 '고현'은 한 인물이 ( 적극적이고 / 소극적이고 ) 허무주의적인 태도에서 벗어나 현실에 ( 맞서 싸우려는 / 순응하려는 ) 의지를 다지게 되는 과정을 그리고 있습니다.",
                    highlight: "( 소극적이고 / 적극적이고 )",
                    options: ["소극적이고", "적극적이고"],
                    correct: 0
                },
                {
                    id: 3,
                    text: "주인공 '고현'의 ( 성장 / 퇴보 )을 통해 ( 개인주의적 / 역사 참여적 ) 삶의 가치와 진정한 ( 생명의 / 물질의 ) 의미는 무엇인지에 대한 깊은 질문을 던지는 소설입니다.",
                    highlight: "( 성장 / 퇴보 )",
                    options: ["성장", "퇴보"],
                    correct: 0
                },
                {
                    id: 4,
                    text: "이 작품의 갈래는 단편 소설, ( 성장 / 연애 ) 소설, 전후 소설입니다.",
                    highlight: "( 성장 / 연애 )",
                    options: ["성장", "연애"],
                    correct: 0
                },
                {
                    id: 5,
                    text: "작품의 성격은 실존주의적, 상징적, ( 관념적 / 사실적 ), ( 의지적 / 체념적 )입니다.",
                    highlight: "( 관념적 / 사실적 )",
                    options: ["관념적", "사실적"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "시간적 배경은 ( 3·1 운동 / 임진왜란 ) ~ 한국 전쟁이며, 공간적 배경은 ( P 마을 / 서울 )입니다.",
                    highlight: "( 3·1 운동 / 임진왜란 )",
                    options: ["3·1 운동", "임진왜란"],
                    correct: 0
                },
                {
                    id: 7,
                    text: "작품의 시점은 ( 전지적 작가 / 1인칭 주인공 ) 시점입니다.",
                    highlight: "( 전지적 작가 / 1인칭 주인공 )",
                    options: ["전지적 작가", "1인칭 주인공"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "작품의 주제는 비극적 현실 ( 극복 / 수용 ) 의지와 새로운 ( 생명력 / 파괴력 )의 발견입니다.",
                    highlight: "( 극복 / 수용 )",
                    options: ["극복", "수용"],
                    correct: 0
                },
                {
                    id: 9,
                    text: "작품의 특징 중 하나는 세대 ( 갈등 / 화합 )로, 할아버지(순응주의), 아버지(행동주의), 현(허무주의→행동주의) 3대의 가치관 변화를 통해 시대정신을 보여줍니다.",
                    highlight: "( 갈등 / 화합 )",
                    options: ["갈등", "화합"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "상징성으로 '( 동굴 / 아파트 )', '불꽃' 등의 상징적 소재를 사용하여 ( 관념적 / 구체적 )인 주제를 형상화합니다.",
                    highlight: "( 동굴 / 아파트 )",
                    options: ["동굴", "아파트"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "인물 변화로 주인공 '현'이 ( 소극적 / 주도적 ) 인물에서 ( 적극적 / 회피적 ) 인물로 변화하는 과정을 중심으로 서사가 전개됩니다.",
                    highlight: "( 소극적 / 주도적 )",
                    options: ["소극적", "주도적"],
                    correct: 0
                },
                {
                    id: 12,
                    text: "실존주의로 ( 극한 / 일상 ) 상황 속에서 주체적인 결단을 통해 자신의 삶의 의미를 찾아가는 실존주의적 태도를 보여줍니다.",
                    highlight: "( 극한 / 일상 )",
                    options: ["극한", "일상"],
                    correct: 0
                },
                {
                    id: 13,
                    text: "주인공 '고현'은 3·1 운동 때 일본 경찰의 ( 총에 / 칼에 ) 맞아 죽은 아버지의 유복자입니다.",
                    highlight: "( 총에 / 칼에 )",
                    options: ["총에", "칼에"],
                    correct: 0
                },
                {
                    id: 14,
                    text: "할아버지 '고 노인'은 아들의 죽음을 ( 자랑스러워하며 / 못마땅해하며 ), 손자인 현에게는 현실에 ( 저항하며 / 순응하며 ) 살 것을 강요합니다.",
                    highlight: "( 자랑스러워하며 / 못마땅해하며 )",
                    options: ["자랑스러워하며", "못마땅해하며"],
                    correct: 1
                },
                {
                    id: 15,
                    text: "현은 현실에 ( 무관심하고 / 적극적이고 ) 소극적인 청년으로 성장합니다.",
                    highlight: "( 무관심하고 / 적극적이고 )",
                    options: ["무관심하고", "적극적이고"],
                    correct: 0
                },
                {
                    id: 16,
                    text: "현은 ( 일본 / 미국 ) 유학 중 제국주의를 찬양하는 일본인 친구의 모습에 환멸을 느끼고 귀국합니다.",
                    highlight: "( 일본 / 미국 )",
                    options: ["일본", "미국"],
                    correct: 0
                },
                {
                    id: 17,
                    text: "현은 곧 ( 학병 / 징용 )으로 끌려갑니다.",
                    highlight: "( 학병 / 징용 )",
                    options: ["학병", "징용"],
                    correct: 0
                },
                {
                    id: 18,
                    text: "학병을 ( 탈출하여 / 마친 뒤 ) 해방된 고향으로 돌아오지만, 이번에는 ( 이념의 대립 / 경제적 빈곤 )이라는 새로운 현실과 마주합니다.",
                    highlight: "( 탈출하여 / 마친 뒤 )",
                    options: ["탈출하여", "마친 뒤"],
                    correct: 0
                },
                {
                    id: 19,
                    text: "현은 공산주의 활동을 하는 친구 '연호'의 권유를 ( 받아들이고 / 거절하고 ), 어떤 ( 사상에도 / 관계에도 ) 얽매이지 않은 채 그저 평범하게 살고자 합니다.",
                    highlight: "( 받아들이고 / 거절하고 )",
                    options: ["받아들이고", "거절하고"],
                    correct: 1
                },
                {
                    id: 20,
                    text: "( 한국 전쟁 / 태평양 전쟁 )이 발발하고 공산주의자들이 P 마을을 점령하자, 연호는 ( 인민재판 / 자선사업 )을 주도하며 폭력을 휘두릅니다.",
                    highlight: "( 한국 전쟁 / 태평양 전쟁 )",
                    options: ["한국 전쟁", "태평양 전쟁"],
                    correct: 0
                },
                {
                    id: 21,
                    text: "주인공 '고현'은 한 인물이 ( 적극적이고 / 소극적이고 ) 허무주의적인 태도에서 벗어나 현실에 ( 맞서 싸우려는 / 순응하려는 ) 의지를 다지게 되는 과정을 그리고 있습니다.",
                    highlight: "( 적극적이고 / 소극적이고 )",
                    options: ["적극적이고", "소극적이고"],
                    correct: 1
                },
                {
                    id: 22,
                    text: "주인공 '고현'은 한 인물이 ( 적극적이고 / 소극적이고 ) 허무주의적인 태도에서 벗어나 현실에 ( 맞서 싸우려는 / 순응하려는 ) 의지를 다지게 되는 과정을 그리고 있습니다.",
                    highlight: "( 맞서 싸우려는 / 순응하려는 )",
                    options: ["맞서 싸우려는", "순응하려는"],
                    correct: 0
                },
                {
                    id: 23,
                    text: "주인공 '고현'의 ( 성장 / 퇴보 )을 통해 ( 개인주의적 / 역사 참여적 ) 삶의 가치와 진정한 ( 생명의 / 물질의 ) 의미는 무엇인지에 대한 깊은 질문을 던지는 소설입니다.",
                    highlight: "( 개인주의적 / 역사 참여적 )",
                    options: ["개인주의적", "역사 참여적"],
                    correct: 1
                },
                {
                    id: 24,
                    text: "주인공 '고현'의 ( 성장 / 퇴보 )을 통해 ( 개인주의적 / 역사 참여적 ) 삶의 가치와 진정한 ( 생명의 / 물질의 ) 의미는 무엇인지에 대한 깊은 질문을 던지는 소설입니다.",
                    highlight: "( 생명의 / 물질의 )",
                    options: ["생명의", "물질의"],
                    correct: 0
                },
                {
                    id: 25,
                    text: "작품의 성격은 실존주의적, 상징적, ( 관념적 / 사실적 ), ( 의지적 / 체념적 )입니다.",
                    highlight: "( 의지적 / 체념적 )",
                    options: ["의지적", "체념적"],
                    correct: 0
                },
                {
                    id: 26,
                    text: "시간적 배경은 ( 3·1 운동 / 임진왜란 ) ~ 한국 전쟁이며, 공간적 배경은 ( P 마을 / 서울 )입니다.",
                    highlight: "( P 마을 / 서울 )",
                    options: ["P 마을", "서울"],
                    correct: 0
                },
                {
                    id: 27,
                    text: "작품의 주제는 비극적 현실 ( 극복 / 수용 ) 의지와 새로운 ( 생명력 / 파괴력 )의 발견입니다.",
                    highlight: "( 생명력 / 파괴력 )",
                    options: ["생명력", "파괴력"],
                    correct: 0
                },
                {
                    id: 28,
                    text: "상징성으로 '( 동굴 / 아파트 )', '불꽃' 등의 상징적 소재를 사용하여 ( 관념적 / 구체적 )인 주제를 형상화합니다.",
                    highlight: "( 관념적 / 구체적 )",
                    options: ["관념적", "구체적"],
                    correct: 0
                },
                {
                    id: 29,
                    text: "인물 변화로 주인공 '현'이 ( 소극적 / 주도적 ) 인물에서 ( 적극적 / 회피적 ) 인물로 변화하는 과정을 중심으로 서사가 전개됩니다.",
                    highlight: "( 적극적 / 회피적 )",
                    options: ["적극적", "회피적"],
                    correct: 0
                },
                {
                    id: 30,
                    text: "할아버지 '고 노인'은 아들의 죽음을 ( 자랑스러워하며 / 못마땅해하며 ), 손자인 현에게는 현실에 ( 저항하며 / 순응하며 ) 살 것을 강요합니다.",
                    highlight: "( 저항하며 / 순응하며 )",
                    options: ["저항하며", "순응하며"],
                    correct: 1
                },
                {
                    id: 31,
                    text: "학병을 ( 탈출하여 / 마친 뒤 ) 해방된 고향으로 돌아오지만, 이번에는 ( 이념의 대립 / 경제적 빈곤 )이라는 새로운 현실과 마주합니다.",
                    highlight: "( 이념의 대립 / 경제적 빈곤 )",
                    options: ["이념의 대립", "경제적 빈곤"],
                    correct: 0
                },
                {
                    id: 32,
                    text: "현은 공산주의 활동을 하는 친구 '연호'의 권유를 ( 받아들이고 / 거절하고 ), 어떤 ( 사상에도 / 관계에도 ) 얽매이지 않은 채 그저 평범하게 살고자 합니다.",
                    highlight: "( 사상에도 / 관계에도 )",
                    options: ["사상에도", "관계에도"],
                    correct: 0
                },
                {
                    id: 33,
                    text: "( 한국 전쟁 / 태평양 전쟁 )이 발발하고 공산주의자들이 P 마을을 점령하자, 연호는 ( 인민재판 / 자선사업 )을 주도하며 폭력을 휘두릅니다.",
                    highlight: "( 인민재판 / 자선사업 )",
                    options: ["인민재판", "자선사업"],
                    correct: 0
                },
                {
                    id: 34,
                    text: "인민재판에서 한 노인이 ( 무참히 / 정당하게 ) 죽는 것을 목격한 현은 처음으로 ( 분노를 / 슬픔을 ) 느끼고, 연호를 때린 뒤 총을 빼앗아 아버지가 죽었던 ( 동굴 / 강가 )로 피신합니다.",
                    highlight: "( 무참히 / 정당하게 )",
                    options: ["무참히", "정당하게"],
                    correct: 0
                },
                {
                    id: 35,
                    text: "인민재판에서 한 노인이 ( 무참히 / 정당하게 ) 죽는 것을 목격한 현은 처음으로 ( 분노를 / 슬픔을 ) 느끼고, 연호를 때린 뒤 총을 빼앗아 아버지가 죽었던 ( 동굴 / 강가 )로 피신합니다.",
                    highlight: "( 분노를 / 슬픔을 )",
                    options: ["분노를", "슬픔을"],
                    correct: 0
                },
                {
                    id: 36,
                    text: "인민재판에서 한 노인이 ( 무참히 / 정당하게 ) 죽는 것을 목격한 현은 처음으로 ( 분노를 / 슬픔을 ) 느끼고, 연호를 때린 뒤 총을 빼앗아 아버지가 죽었던 ( 동굴 / 강가 )로 피신합니다.",
                    highlight: "( 동굴 / 강가 )",
                    options: ["동굴", "강가"],
                    correct: 0
                },
                {
                    id: 37,
                    text: "연호는 현의 ( 할아버지 / 어머니 )를 인질로 잡아 투항을 강요하고, 할아버지는 처음엔 ( 살기 위해 / 죽기 위해 ) 투항하라 말하지만 이내 \"너만이라도 ( 살아내야 한다 / 죽어야 한다 )\"고 외치며 현의 생존을 독려합니다.",
                    highlight: "( 할아버지 / 어머니 )",
                    options: ["할아버지", "어머니"],
                    correct: 0
                },
                {
                    id: 38,
                    text: "연호는 현의 ( 할아버지 / 어머니 )를 인질로 잡아 투항을 강요하고, 할아버지는 처음엔 ( 살기 위해 / 죽기 위해 ) 투항하라 말하지만 이내 \"너만이라도 ( 살아내야 한다 / 죽어야 한다 )\"고 외치며 현의 생존을 독려합니다.",
                    highlight: "( 살기 위해 / 죽기 위해 )",
                    options: ["살기 위해", "죽기 위해"],
                    correct: 0
                },
                {
                    id: 39,
                    text: "연호는 현의 ( 할아버지 / 어머니 )를 인질로 잡아 투항을 강요하고, 할아버지는 처음엔 ( 살기 위해 / 죽기 위해 ) 투항하라 말하지만 이내 \"너만이라도 ( 살아내야 한다 / 죽어야 한다 )\"고 외치며 현의 생존을 독려합니다.",
                    highlight: "( 살아내야 한다 / 죽어야 한다 )",
                    options: ["살아내야 한다", "죽어야 한다"],
                    correct: 0
                },
                {
                    id: 40,
                    text: "이 말에 연호는 할아버지를 ( 총으로 쏴 / 칼로 찔러 ) 죽입니다.",
                    highlight: "( 총으로 쏴 / 칼로 찔러 )",
                    options: ["총으로 쏴", "칼로 찔러"],
                    correct: 0
                },
                {
                    id: 41,
                    text: "할아버지의 ( 죽음에 / 부상에 ) 분노한 현은 동굴에서 뛰쳐나와 연호와 서로 ( 총을 / 주먹을 ) 쏩니다.",
                    highlight: "( 죽음에 / 부상에 )",
                    options: ["죽음에", "부상에"],
                    correct: 0
                },
                {
                    id: 42,
                    text: "할아버지의 ( 죽음에 / 부상에 ) 분노한 현은 동굴에서 뛰쳐나와 연호와 서로 ( 총을 / 주먹을 ) 쏩니다.",
                    highlight: "( 총을 / 주먹을 )",
                    options: ["총을", "주먹을"],
                    correct: 0
                },
                {
                    id: 43,
                    text: "현은 ( 어깨에 / 다리에 ) 총을 맞고 쓰러집니다.",
                    highlight: "( 어깨에 / 다리에 )",
                    options: ["어깨에", "다리에"],
                    correct: 0
                },
                {
                    id: 44,
                    text: "죽어가는 순간, 현은 고통 속에서 오히려 ( 살아 있다는 / 죽어간다는 ) 강렬한 감각, 즉 생명의 ( 불꽃 / 어둠 )을 느낍니다.",
                    highlight: "( 살아 있다는 / 죽어간다는 )",
                    options: ["살아 있다는", "죽어간다는"],
                    correct: 0
                },
                {
                    id: 45,
                    text: "죽어가는 순간, 현은 고통 속에서 오히려 ( 살아 있다는 / 죽어간다는 ) 강렬한 감각, 즉 생명의 ( 불꽃 / 어둠 )을 느낍니다.",
                    highlight: "( 불꽃 / 어둠 )",
                    options: ["불꽃", "어둠"],
                    correct: 0
                },
                {
                    id: 46,
                    text: "그는 할아버지와 아버지가 각자의 방식으로 ( 치열하게 / 무의미하게 ) 살았음을 깨닫고, 자신도 더 이상 현실을 ( 회피하지 않고 / 외면하고 ) 적극적으로 맞서 싸우며 살아가겠다고 ( 결심한다 / 체념한다 ).",
                    highlight: "( 치열하게 / 무의미하게 )",
                    options: ["치열하게", "무의미하게"],
                    correct: 0
                },
                {
                    id: 47,
                    text: "그는 할아버지와 아버지가 각자의 방식으로 ( 치열하게 / 무의미하게 ) 살았음을 깨닫고, 자신도 더 이상 현실을 ( 회피하지 않고 / 외면하고 ) 적극적으로 맞서 싸우며 살아가겠다고 ( 결심한다 / 체념한다 ).",
                    highlight: "( 회피하지 않고 / 외면하고 )",
                    options: ["회피하지 않고", "외면하고"],
                    correct: 0
                },
                {
                    id: 48,
                    text: "그는 할아버지와 아버지가 각자의 방식으로 ( 치열하게 / 무의미하게 ) 살았음을 깨닫고, 자신도 더 이상 현실을 ( 회피하지 않고 / 외면하고 ) 적극적으로 맞서 싸우며 살아가겠다고 ( 결심한다 / 체념한다 ).",
                    highlight: "( 결심한다 / 체념한다 )",
                    options: ["결심한다", "체념한다"],
                    correct: 0
                },
                {
                    id: 49,
                    text: "이 소설을 쓴 선우휘 작가님은 ( 일제 강점기 / 조선 시대 )와 한국 전쟁이라는 한국 근현대사의 가장 아픈 시기를 온몸으로 겪어낸 분입니다.",
                    highlight: "( 일제 강점기 / 조선 시대 )",
                    options: ["일제 강점기", "조선 시대"],
                    correct: 0
                },
                {
                    id: 50,
                    text: "그는 ( 언론인 / 군인 )이자 소설가로서, ( 혼란스러운 / 평화로운 ) 역사 속에서 개인이 어떻게 살아가야 하는지에 대한 질문을 작품에 많이 담았습니다.",
                    highlight: "( 언론인 / 군인 )",
                    options: ["언론인", "군인"],
                    correct: 0
                },
                {
                    id: 51,
                    text: "그는 ( 언론인 / 군인 )이자 소설가로서, ( 혼란스러운 / 평화로운 ) 역사 속에서 개인이 어떻게 살아가야 하는지에 대한 질문을 작품에 많이 담았습니다.",
                    highlight: "( 혼란스러운 / 평화로운 )",
                    options: ["혼란스러운", "평화로운"],
                    correct: 0
                },
                {
                    id: 52,
                    text: "「불꽃」은 ( 1957년 / 1980년 )에 발표된 작품으로, 전쟁이 ( 끝난 직후 / 시작되기 전 ) 폐허 속에서 희망을 찾으려는 사람들의 고민이 담겨 있습니다.",
                    highlight: "( 1957년 / 1980년 )",
                    options: ["1957년", "1980년"],
                    correct: 0
                },
                {
                    id: 53,
                    text: "「불꽃」은 ( 1957년 / 1980년 )에 발표된 작품으로, 전쟁이 ( 끝난 직후 / 시작되기 전 ) 폐허 속에서 희망을 찾으려는 사람들의 고민이 담겨 있습니다.",
                    highlight: "( 끝난 직후 / 시작되기 전 )",
                    options: ["끝난 직후", "시작되기 전"],
                    correct: 0
                },
                {
                    id: 54,
                    text: "작가님은 이 소설을 통해 단순히 '( 반공 / 친북 )'을 외치는 것을 넘어, 어떤 이념이나 사상보다 ( 소중한 / 하찮은 ) 것은 바로 '( 살아있다 / 죽어있다 )'는 생명의 가치 그 자체이며, 그 생명을 ( 지키기 / 버리기 ) 위해 행동해야 한다는 메시지를 전하고 싶었던 것입니다.",
                    highlight: "( 반공 / 친북 )",
                    options: ["반공", "친북"],
                    correct: 0
                },
                {
                    id: 55,
                    text: "작가님은 이 소설을 통해 단순히 '( 반공 / 친북 )'을 외치는 것을 넘어, 어떤 이념이나 사상보다 ( 소중한 / 하찮은 ) 것은 바로 '( 살아있다 / 죽어있다 )'는 생명의 가치 그 자체이며, 그 생명을 ( 지키기 / 버리기 ) 위해 행동해야 한다는 메시지를 전하고 싶었던 것입니다.",
                    highlight: "( 소중한 / 하찮은 )",
                    options: ["소중한", "하찮은"],
                    correct: 0
                },
                {
                    id: 56,
                    text: "작가님은 이 소설을 통해 단순히 '( 반공 / 친북 )'을 외치는 것을 넘어, 어떤 이념이나 사상보다 ( 소중한 / 하찮은 ) 것은 바로 '( 살아있다 / 죽어있다 )'는 생명의 가치 그 자체이며, 그 생명을 ( 지키기 / 버리기 ) 위해 행동해야 한다는 메시지를 전하고 싶었던 것입니다.",
                    highlight: "( 살아있다 / 죽어있다 )",
                    options: ["살아있다", "죽어있다"],
                    correct: 0
                },
                {
                    id: 57,
                    text: "작가님은 이 소설을 통해 단순히 '( 반공 / 친북 )'을 외치는 것을 넘어, 어떤 이념이나 사상보다 ( 소중한 / 하찮은 ) 것은 바로 '( 살아있다 / 죽어있다 )'는 생명의 가치 그 자체이며, 그 생명을 ( 지키기 / 버리기 ) 위해 행동해야 한다는 메시지를 전하고 싶었던 것입니다.",
                    highlight: "( 지키기 / 버리기 )",
                    options: ["지키기", "버리기"],
                    correct: 0
                },
                {
                    id: 58,
                    text: "이야기의 주인공 '고현'은 태어나기도 전에 아버지를 여읜 ( 유복자 / 고아 )입니다.",
                    highlight: "( 유복자 / 고아 )",
                    options: ["유복자", "고아"],
                    correct: 0
                },
                {
                    id: 59,
                    text: "그의 아버지는 3·1 운동에 참여했다가 일본 경찰의 총에 맞아 돌아가신 ( 행동가 / 현실 순응가 )였습니다.",
                    highlight: "( 행동가 / 현실 순응가 )",
                    options: ["행동가", "현실 순응가"],
                    correct: 0
                },
                {
                    id: 60,
                    text: "반면, 아들을 ( 잃은 / 얻은 ) 할아버지는 손자 현에게 늘 \"( 모난 돌이 정 맞는다 / 쇠뿔도 단김에 빼라 )\"며, 세상사에 ( 나서지 말고 / 적극 나서며 ) 그저 조용히 목숨을 보전하며 살라고 가르칩니다.",
                    highlight: "( 잃은 / 얻은 )",
                    options: ["잃은", "얻은"],
                    correct: 0
                },
                {
                    id: 61,
                    text: "반면, 아들을 ( 잃은 / 얻은 ) 할아버지는 손자 현에게 늘 \"( 모난 돌이 정 맞는다 / 쇠뿔도 단김에 빼라 )\"며, 세상사에 ( 나서지 말고 / 적극 나서며 ) 그저 조용히 목숨을 보전하며 살라고 가르칩니다.",
                    highlight: "( 모난 돌이 정 맞는다 / 쇠뿔도 단김에 빼라 )",
                    options: ["모난 돌이 정 맞는다", "쇠뿔도 단김에 빼라"],
                    correct: 0
                },
                {
                    id: 62,
                    text: "반면, 아들을 ( 잃은 / 얻은 ) 할아버지는 손자 현에게 늘 \"( 모난 돌이 정 맞는다 / 쇠뿔도 단김에 빼라 )\"며, 세상사에 ( 나서지 말고 / 적극 나서며 ) 그저 조용히 목숨을 보전하며 살라고 가르칩니다.",
                    highlight: "( 나서지 말고 / 적극 나서며 )",
                    options: ["나서지 말고", "적극 나서며"],
                    correct: 0
                },
                {
                    id: 63,
                    text: "이런 할아버지의 ( 가르침 / 방임 ) 속에서 현은 역사나 사회 문제에 ( 무관심하고 / 관심이 많고 ) 자신의 안전만을 생각하는 ( 소극적인 / 적극적인 ) 청년으로 자라납니다.",
                    highlight: "( 가르침 / 방임 )",
                    options: ["가르침", "방임"],
                    correct: 0
                },
                {
                    id: 64,
                    text: "이런 할아버지의 ( 가르침 / 방임 ) 속에서 현은 역사나 사회 문제에 ( 무관심하고 / 관심이 많고 ) 자신의 안전만을 생각하는 ( 소극적인 / 적극적인 ) 청년으로 자라납니다.",
                    highlight: "( 무관심하고 / 관심이 많고 )",
                    options: ["무관심하고", "관심이 많고"],
                    correct: 0
                },
                {
                    id: 65,
                    text: "이런 할아버지의 ( 가르침 / 방임 ) 속에서 현은 역사나 사회 문제에 ( 무관심하고 / 관심이 많고 ) 자신의 안전만을 생각하는 ( 소극적인 / 적극적인 ) 청년으로 자라납니다.",
                    highlight: "( 소극적인 / 적극적인 )",
                    options: ["소극적인", "적극적인"],
                    correct: 0
                },
                {
                    id: 66,
                    text: "현은 할아버지의 ( 도움으로 / 반대에도 ) 일본 유학까지 가게 되지만, 그곳에서도 ( 마음 편히 / 즐겁게 ) 지내지 못합니다.",
                    highlight: "( 도움으로 / 반대에도 )",
                    options: ["도움으로", "반대에도"],
                    correct: 0
                },
                {
                    id: 67,
                    text: "현은 할아버지의 ( 도움으로 / 반대에도 ) 일본 유학까지 가게 되지만, 그곳에서도 ( 마음 편히 / 즐겁게 ) 지내지 못합니다.",
                    highlight: "( 마음 편히 / 즐겁게 )",
                    options: ["마음 편히", "즐겁게"],
                    correct: 0
                },
                {
                    id: 68,
                    text: "일본인 친구가 일본의 제국주의 전쟁을 ( 찬양하는 / 비판하는 ) 모습을 보고 ( 환멸을 / 감동을 ) 느껴 고향으로 돌아오고 말죠.",
                    highlight: "( 찬양하는 / 비판하는 )",
                    options: ["찬양하는", "비판하는"],
                    correct: 0
                },
                {
                    id: 69,
                    text: "일본인 친구가 일본의 제국주의 전쟁을 ( 찬양하는 / 비판하는 ) 모습을 보고 ( 환멸을 / 감동을 ) 느껴 고향으로 돌아오고 말죠.",
                    highlight: "( 환멸을 / 감동을 )",
                    options: ["환멸을", "감동을"],
                    correct: 0
                },
                {
                    id: 70,
                    text: "하지만 돌아온 고향에서 그는 일본의 ( 학병 / 유학생 )으로 강제 징집됩니다.",
                    highlight: "( 학병 / 유학생 )",
                    options: ["학병", "유학생"],
                    correct: 0
                },
                {
                    id: 71,
                    text: "전쟁터로 끌려간 그는 결국 ( 탈출하여 / 복무를 마치고 ) 해방된 조국으로 돌아옵니다.",
                    highlight: "( 탈출하여 / 복무를 마치고 )",
                    options: ["탈출하여", "복무를 마치고"],
                    correct: 0
                },
                {
                    id: 72,
                    text: "그러나 해방된 조국은 또다시 ( 좌우 이념 대립 / 외세의 침략 )이라는 거대한 소용돌이에 휩싸여 있었습니다.",
                    highlight: "( 좌우 이념 대립 / 외세의 침략 )",
                    options: ["좌우 이념 대립", "외세의 침략"],
                    correct: 0
                },
                {
                    id: 73,
                    text: "현은 공산주의자가 된 옛 친구 '연호'의 합류 권유를 ( 단호히 거절하며 / 마지못해 받아들이며 ), 이번에도 이념의 ( 다툼에서 / 중심에서 ) 벗어나 그저 조용히 살아가려고만 합니다.",
                    highlight: "( 단호히 거절하며 / 마지못해 받아들이며 )",
                    options: ["단호히 거절하며", "마지못해 받아들이며"],
                    correct: 0
                },
                {
                    id: 74,
                    text: "현은 공산주의자가 된 옛 친구 '연호'의 합류 권유를 ( 단호히 거절하며 / 마지못해 받아들이며 ), 이번에도 이념의 ( 다툼에서 / 중심에서 ) 벗어나 그저 조용히 살아가려고만 합니다.",
                    highlight: "( 다툼에서 / 중심에서 )",
                    options: ["다툼에서", "중심에서"],
                    correct: 0
                },
                {
                    id: 75,
                    text: "( 6.25 전쟁 / 갑오개혁 )이 터지고, 현의 고향은 공산주의자들에게 점령됩니다.",
                    highlight: "( 6.25 전쟁 / 갑오개혁 )",
                    options: ["6.25 전쟁", "갑오개혁"],
                    correct: 0
                },
                {
                    id: 76,
                    text: "친구 연호는 ( 완장 / 훈장 )이 되어 마을 사람들을 위협하고 인민재판을 엽니다.",
                    highlight: "( 완장 / 훈장 )",
                    options: ["완장", "훈장"],
                    correct: 0
                },
                {
                    id: 77,
                    text: "현은 그 ( 끔찍한 / 정의로운 ) 광경을 외면하려 하지만, 한 노인이 ( 억울하게 / 정당하게 ) 죽임당하는 모습을 보고 자신도 모르게 ( 분노가 / 기쁨이 ) 폭발합니다.",
                    highlight: "( 끔찍한 / 정의로운 )",
                    options: ["끔찍한", "정의로운"],
                    correct: 0
                },
                {
                    id: 78,
                    text: "현은 그 ( 끔찍한 / 정의로운 ) 광경을 외면하려 하지만, 한 노인이 ( 억울하게 / 정당하게 ) 죽임당하는 모습을 보고 자신도 모르게 ( 분노가 / 기쁨이 ) 폭발합니다.",
                    highlight: "( 억울하게 / 정당하게 )",
                    options: ["억울하게", "정당하게"],
                    correct: 0
                },
                {
                    id: 79,
                    text: "현은 그 ( 끔찍한 / 정의로운 ) 광경을 외면하려 하지만, 한 노인이 ( 억울하게 / 정당하게 ) 죽임당하는 모습을 보고 자신도 모르게 ( 분노가 / 기쁨이 ) 폭발합니다.",
                    highlight: "( 분노가 / 기쁨이 )",
                    options: ["분노가", "기쁨이"],
                    correct: 0
                },
                {
                    id: 80,
                    text: "그는 연호를 때려눕히고 총을 ( 빼앗아 / 돌려주고 ), 옛날 아버지가 숨어 돌아가셨던 뒷산 ( 동굴 / 폐가 )로 몸을 숨깁니다.",
                    highlight: "( 빼앗아 / 돌려주고 )",
                    options: ["빼앗아", "돌려주고"],
                    correct: 0
                },
                {
                    id: 81,
                    text: "그는 연호를 때려눕히고 총을 ( 빼앗아 / 돌려주고 ), 옛날 아버지가 숨어 돌아가셨던 뒷산 ( 동굴 / 폐가 )로 몸을 숨깁니다.",
                    highlight: "( 동굴 / 폐가 )",
                    options: ["동굴", "폐가"],
                    correct: 0
                },
                {
                    id: 82,
                    text: "이는 현이 평생 처음으로 현실에 대해 ( 소극적 방관이 아닌 / 적극적 순응이 아닌 ), ( 적극적인 저항 / 또 다른 도피 )을 선택한 순간이었습니다.",
                    highlight: "( 소극적 방관이 아닌 / 적극적 순응이 아닌 )",
                    options: ["소극적 방관이 아닌", "적극적 순응이 아닌"],
                    correct: 0
                },
                {
                    id: 83,
                    text: "이는 현이 평생 처음으로 현실에 대해 ( 소극적 방관이 아닌 / 적극적 순응이 아닌 ), ( 적극적인 저항 / 또 다른 도피 )을 선택한 순간이었습니다.",
                    highlight: "( 적극적인 저항 / 또 다른 도피 )",
                    options: ["적극적인 저항", "또 다른 도피"],
                    correct: 0
                },
                {
                    id: 84,
                    text: "현이 숨은 곳을 알아낸 연호는 ( 비열한 / 정당한 ) 방법을 씁니다.",
                    highlight: "( 비열한 / 정당한 )",
                    options: ["비열한", "정당한"],
                    correct: 0
                },
                {
                    id: 85,
                    text: "바로 현의 ( 할아버지 / 친구 )를 인질로 잡아 동굴 앞으로 끌고 와, ( 투항하지 않으면 / 협력하지 않으면 ) 할아버지를 죽이겠다고 협박한 것이죠.",
                    highlight: "( 할아버지 / 친구 )",
                    options: ["할아버지", "친구"],
                    correct: 0
                },
                {
                    id: 86,
                    text: "바로 현의 ( 할아버지 / 친구 )를 인질로 잡아 동굴 앞으로 끌고 와, ( 투항하지 않으면 / 협력하지 않으면 ) 할아버지를 죽이겠다고 협박한 것이죠.",
                    highlight: "( 투항하지 않으면 / 협력하지 않으면 )",
                    options: ["투항하지 않으면", "협력하지 않으면"],
                    correct: 0
                },
                {
                    id: 87,
                    text: "평생 손자의 ( 안위만을 / 성공만을 ) 바라던 할아버지는 처음에는 ( 살기 위해 / 명예를 위해 ) 현에게 나오라고 애원합니다.",
                    highlight: "( 안위만을 / 성공만을  )",
                    options: ["안위만을", "성공만을"],
                    correct: 0
                },
                {
                    id: 88,
                    text: "평생 손자의 ( 안위만을 / 성공만을 ) 바라던 할아버지는 처음에는 ( 살기 위해 / 명예를 위해 ) 현에게 나오라고 애원합니다.",
                    highlight: "( 살기 위해 / 명예를 위해 )",
                    options: ["살기 위해", "명예를 위해"],
                    correct: 0
                },
                {
                    id: 89,
                    text: "하지만 이내 무언가를 ( 결심한 듯 / 포기한 듯 ), \"아니다! 너만이라도 살아내야 한다!\"라고 외칩니다.",
                    highlight: "( 결심한 듯 / 포기한 듯 )",
                    options: ["결심한 듯", "포기한 듯"],
                    correct: 0
                },
                {
                    id: 90,
                    text: "할아버지의 이 외침은 평생 현실에 ( 순응하며 / 저항하며 ) 살라던 가르침을 뒤집는, 손자를 향한 ( 마지막 사랑이자 명령 / 절망적인 체념 )이었습니다.",
                    highlight: "( 순응하며 / 저항하며 )",
                    options: ["순응하며", "저항하며"],
                    correct: 0
                },
                {
                    id: 91,
                    text: "할아버지의 이 외침은 평생 현실에 ( 순응하며 / 저항하며 ) 살라던 가르침을 뒤집는, 손자를 향한 ( 마지막 사랑이자 명령 / 절망적인 체념 )이었습니다.",
                    highlight: "( 마지막 사랑이자 명령 / 절망적인 체념 )",
                    options: ["마지막 사랑이자 명령", "절망적인 체념"],
                    correct: 0
                },
                {
                    id: 92,
                    text: "이 말에 ( 분노한 / 감동한 ) 연호는 할아버지를 총으로 쏴 죽이고 맙니다.",
                    highlight: "( 분노한 / 감동한 )",
                    options: ["분노한", "감동한"],
                    correct: 0
                },
                {
                    id: 93,
                    text: "할아버지의 ( 죽음을 / 희생을 ) 눈앞에서 목격한 현은 ( 이성을 / 총을 ) 잃고 동굴 밖으로 뛰쳐나갑니다.",
                    highlight: "( 죽음을 / 희생을 )",
                    options: ["죽음을", "희생을"],
                    correct: 0
                },
                {
                    id: 94,
                    text: "할아버지의 ( 죽음을 / 희생을 ) 눈앞에서 목격한 현은 ( 이성을 / 총을 ) 잃고 동굴 밖으로 뛰쳐나갑니다.",
                    highlight: "( 이성을 / 총을 )",
                    options: ["이성을", "총을"],
                    correct: 0
                },
                {
                    id: 95,
                    text: "그는 연호를 향해 총을 쏘고, 연호 역시 현에게 ( 총을 / 칼을 ) 쏩니다.",
                    highlight: "( 총을 / 칼을 )",
                    options: ["총을", "칼을"],
                    correct: 0
                },
                {
                    id: 96,
                    text: "현은 ( 어깨에 / 마음에 ) 총을 맞고 쓰러져 죽어갑니다.",
                    highlight: "( 어깨에 / 마음에 )",
                    options: ["어깨에", "마음에"],
                    correct: 0
                },
                {
                    id: 97,
                    text: "그런데 바로 그 ( 죽음의 / 절망의 ) 순간, 현은 끔찍한 고통 속에서 ( 역설적으로 / 당연하게도 ) 자신이 '살아있다'는 강렬한 느낌과 함께, 마음속에서 뜨거운 '( 불꽃 / 얼음 )'이 타오르는 것을 느낍니다.",
                    highlight: "( 죽음의 / 절망의 )",
                    options: ["죽음의", "절망의"],
                    correct: 0
                },
                {
                    id: 98,
                    text: "그런데 바로 그 ( 죽음의 / 절망의 ) 순간, 현은 끔찍한 고통 속에서 ( 역설적으로 / 당연하게도 ) 자신이 '살아있다'는 강렬한 느낌과 함께, 마음속에서 뜨거운 '( 불꽃 / 얼음 )'이 타오르는 것을 느낍니다.",
                    highlight: "( 역설적으로 / 당연하게도 )",
                    options: ["역설적으로", "당연하게도"],
                    correct: 0
                },
                {
                    id: 99,
                    text: "그런데 바로 그 ( 죽음의 / 절망의 ) 순간, 현은 끔찍한 고통 속에서 ( 역설적으로 / 당연하게도 ) 자신이 '살아있다'는 강렬한 느낌과 함께, 마음속에서 뜨거운 '( 불꽃 / 얼음 )'이 타오르는 것을 느낍니다.",
                    highlight: "( 불꽃 / 얼음 )",
                    options: ["불꽃", "얼음"],
                    correct: 0
                },
                {
                    id: 100,
                    text: "그는 비로소 ( 깨닫습니다 / 후회합니다 ).",
                    highlight: "( 깨닫습니다 / 후회합니다 )",
                    options: ["깨닫습니다", "후회합니다"],
                    correct: 0
                },
                {
                    id: 101,
                    text: "( 행동하는 / 순응하는 ) 삶을 살았던 아버지도, ( 순응하는 / 행동하는 ) 삶을 살았던 할아버지도 모두 각자의 방식으로 ( 치열하게 / 허무하게 ) 살아왔다는 것을.",
                    highlight: "( 행동하는 / 순응하는 )",
                    options: ["행동하는", "순응하는"],
                    correct: 0
                },
                {
                    id: 102,
                    text: "( 행동하는 / 순응하는 ) 삶을 살았던 아버지도, ( 순응하는 / 행동하는 ) 삶을 살았던 할아버지도 모두 각자의 방식으로 ( 치열하게 / 허무하게 ) 살아왔다는 것을.",
                    highlight: "( 순응하는 / 행동하는 )",
                    options: ["순응하는", "행동하는"],
                    correct: 0
                },
                {
                    id: 103,
                    text: "( 행동하는 / 순응하는 ) 삶을 살았던 아버지도, ( 순응하는 / 행동하는 ) 삶을 살았던 할아버지도 모두 각자의 방식으로 ( 치열하게 / 허무하게 ) 살아왔다는 것을.",
                    highlight: "( 치열하게 / 허무하게 )",
                    options: ["치열하게", "허무하게"],
                    correct: 0
                },
                {
                    id: 104,
                    text: "그리고 이제 자신도 더 이상 ( 도망치지 않고 / 순응하지 않고 ), 부조리한 현실과 ( 맞서 싸우는 / 타협하는 ) 삶을 살아야겠다고 굳게 ( 결심하며 / 포기하며 ) 의식을 잃습니다.",
                    highlight: "( 도망치지 않고 / 순응하지 않고 )",
                    options: ["도망치지 않고", "순응하지 않고"],
                    correct: 0
                },
                {
                    id: 105,
                    text: "그리고 이제 자신도 더 이상 ( 도망치지 않고 / 순응하지 않고 ), 부조리한 현실과 ( 맞서 싸우는 / 타협하는 ) 삶을 살아야겠다고 굳게 ( 결심하며 / 포기하며 ) 의식을 잃습니다.",
                    highlight: "( 맞서 싸우는 / 타협하는 )",
                    options: ["맞서 싸우는", "타협하는"],
                    correct: 0
                },
                {
                    id: 106,
                    text: "그리고 이제 자신도 더 이상 ( 도망치지 않고 / 순응하지 않고 ), 부조리한 현실과 ( 맞서 싸우는 / 타협하는 ) 삶을 살아야겠다고 굳게 ( 결심하며 / 포기하며 ) 의식을 잃습니다.",
                    highlight: "( 결심하며 / 포기하며 )",
                    options: ["결심하며", "포기하며"],
                    correct: 0
                }
            ],
            fullText: `## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**

**[작품 해제]** 이 작품은 ( 3·1 운동 / 6.25 전쟁 )부터 한국 전쟁까지 한국 근현대사의 비극을 배경으로, 한 인물이 ( 적극적이고 / 소극적이고 ) 허무주의적인 태도에서 벗어나 현실에 ( 맞서 싸우려는 / 순응하려는 ) 의지를 다지게 되는 과정을 그리고 있습니다. 주인공 '고현'의 ( 성장 / 퇴보 )을 통해 ( 개인주의적 / 역사 참여적 ) 삶의 가치와 진정한 ( 생명의 / 물질의 ) 의미는 무엇인지에 대한 깊은 질문을 던지는 소설입니다.

**[핵심 정리 표]**

| 구분 | 내용 |
| :--- | :--- |
| **갈래** | 단편 소설, ( 성장 / 연애 ) 소설, 전후 소설 |
| **성격** | 실존주의적, 상징적, ( 관념적 / 사실적 ), ( 의지적 / 체념적 ) |
| **배경** | **시간적:** ( 3·1 운동 / 임진왜란 ) ~ 한국 전쟁  
**공간적:** ( P 마을 / 서울 ) |
| **시점** | ( 전지적 작가 / 1인칭 주인공 ) 시점 |
| **주제** | 비극적 현실 ( 극복 / 수용 ) 의지와 새로운 ( 생명력 / 파괴력 )의 발견 |
| **특징** | 1. 세대 ( 갈등 / 화합 ): 할아버지(순응주의), 아버지(행동주의), 현(허무주의→행동주의) 3대의 가치관 변화를 통해 시대정신을 보여줌.  
2. 상징성: '( 동굴 / 아파트 )', '불꽃' 등의 상징적 소재를 사용하여 ( 관념적 / 구체적 )인 주제를 형상화함.  
3. 인물 변화: 주인공 '현'이 ( 소극적 / 주도적 ) 인물에서 ( 적극적 / 회피적 ) 인물로 변화하는 과정을 중심으로 서사가 전개됨.  
4. 실존주의: ( 극한 / 일상 ) 상황 속에서 주체적인 결단을 통해 자신의 삶의 의미를 찾아가는 실존주의적 태도를 보여줌. |

**[전체 줄거리 및 출제 포인트]**

* **발단: 3대의 비극적 가족사**  
  주인공 '고현'은 3·1 운동 때 일본 경찰의 총에 맞아 죽은 아버지의 유복자이다. 할아버지 '고 노인'은 아들의 죽음을 못마땅해하며, 손자인 현에게는 현실에 순응하며 살 것을 강요한다. 이러한 환경 속에서 현은 현실에 무관심하고 소극적인 청년으로 성장한다.

* **전개: 소극적 현실 도피**  
  현은 일본 유학 중 제국주의를 찬양하는 일본인 친구의 모습에 환멸을 느끼고 귀국하지만, 곧 학병으로 끌려간다. 학병을 탈출하여 해방된 고향으로 돌아오지만, 이번에는 이념의 대립이라는 새로운 현실과 마주한다. 그는 공산주의 활동을 하는 친구 '연호'의 권유를 거절하고, 어떤 사상에도 얽매이지 않은 채 그저 평범하게 살고자 한다.

* **위기-절정: 할아버지의 죽음과 현의 분노**  
  한국 전쟁이 발발하고 공산주의자들이 P 마을을 점령하자, 연호는 인민재판을 주도하며 폭력을 휘두른다. 인민재판에서 한 노인이 무참히 죽는 것을 목격한 현은 처음으로 분노를 느끼고, 연호를 때린 뒤 총을 빼앗아 아버지가 죽었던 동굴로 피신한다. 연호는 현의 할아버지를 인질로 잡아 투항을 강요하고, 할아버지는 처음엔 살기 위해 투항하라 말하지만 이내 "너만이라도 살아내야 한다"고 외치며 현의 생존을 독려한다. 이 말에 연호는 할아버지를 총으로 쏴 죽인다.

* **결말: '불꽃'의 발견과 새로운 결단**  
  할아버지의 죽음에 분노한 현은 동굴에서 뛰쳐나와 연호와 서로 총을 쏜다. 현은 어깨에 총을 맞고 쓰러진다. 죽어가는 순간, 현은 고통 속에서 오히려 살아 있다는 강렬한 감각, 즉 생명의 불꽃을 느낀다. 그는 할아버지와 아버지가 각자의 방식으로 치열하게 살았음을 깨닫고, 자신도 더 이상 현실을 회피하지 않고 적극적으로 맞서 싸우며 살아가겠다고 결심한다.

---

### 2️⃣ **작품 미리보기: 배경지식의 첫걸음** 📝

**# 작가와 시대 이야기** 이 소설을 쓴 선우휘 작가님은 ( 일제 강점기 / 조선 시대 )와 한국 전쟁이라는 한국 근현대사의 가장 아픈 시기를 온몸으로 겪어낸 분입니다. 그는 ( 언론인 / 군인 )이자 소설가로서, ( 혼란스러운 / 평화로운 ) 역사 속에서 개인이 어떻게 살아가야 하는지에 대한 질문을 작품에 많이 담았습니다. 「불꽃」은 ( 1957년 / 1980년 )에 발표된 작품으로, 전쟁이 ( 끝난 직후 / 시작되기 전 ) 폐허 속에서 희망을 찾으려는 사람들의 고민이 담겨 있습니다. 작가님은 이 소설을 통해 단순히 '( 반공 / 친북 )'을 외치는 것을 넘어, 어떤 이념이나 사상보다 ( 소중한 / 하찮은 ) 것은 바로 '( 살아있다 / 죽어있다 )'는 생명의 가치 그 자체이며, 그 생명을 ( 지키기 / 버리기 ) 위해 행동해야 한다는 메시지를 전하고 싶었던 것입니다.

**# 「불꽃」 줄거리, 아주 자세히 살펴보기**

**1. 아버지와 할아버지, 두 개의 그림자** 이야기의 주인공 '고현'은 태어나기도 전에 아버지를 여읜 ( 유복자 / 고아 )입니다. 그의 아버지는 3·1 운동에 참여했다가 일본 경찰의 총에 맞아 돌아가신 ( 행동가 / 현실 순응가 )였습니다. 반면, 아들을 ( 잃은 / 얻은 ) 할아버지는 손자 현에게 늘 "( 모난 돌이 정 맞는다 / 쇠뿔도 단김에 빼라 )"며, 세상사에 ( 나서지 말고 / 적극 나서며 ) 그저 조용히 목숨을 보전하며 살라고 가르칩니다. 이런 할아버지의 ( 가르침 / 방임 ) 속에서 현은 역사나 사회 문제에 ( 무관심하고 / 관심이 많고 ) 자신의 안전만을 생각하는 ( 소극적인 / 적극적인 ) 청년으로 자라납니다.

**2. 도망치고 또 도망치다** 현은 할아버지의 ( 도움으로 / 반대에도 ) 일본 유학까지 가게 되지만, 그곳에서도 ( 마음 편히 / 즐겁게 ) 지내지 못합니다. 일본인 친구가 일본의 제국주의 전쟁을 ( 찬양하는 / 비판하는 ) 모습을 보고 ( 환멸을 / 감동을 ) 느껴 고향으로 돌아오고 말죠. 하지만 돌아온 고향에서 그는 일본의 ( 학병 / 유학생 )으로 강제 징집됩니다. 전쟁터로 끌려간 그는 결국 ( 탈출하여 / 복무를 마치고 ) 해방된 조국으로 돌아옵니다. 그러나 해방된 조국은 또다시 ( 좌우 이념 대립 / 외세의 침략 )이라는 거대한 소용돌이에 휩싸여 있었습니다. 현은 공산주의자가 된 옛 친구 '연호'의 합류 권유를 ( 단호히 거절하며 / 마지못해 받아들이며 ), 이번에도 이념의 ( 다툼에서 / 중심에서 ) 벗어나 그저 조용히 살아가려고만 합니다.

**3. 처음으로 터져 나온 분노** ( 6.25 전쟁 / 갑오개혁 )이 터지고, 현의 고향은 공산주의자들에게 점령됩니다. 친구 연호는 ( 완장 / 훈장 )이 되어 마을 사람들을 위협하고 인민재판을 엽니다. 현은 그 ( 끔찍한 / 정의로운 ) 광경을 외면하려 하지만, 한 노인이 ( 억울하게 / 정당하게 ) 죽임당하는 모습을 보고 자신도 모르게 ( 분노가 / 기쁨이 ) 폭발합니다. 그는 연호를 때려눕히고 총을 ( 빼앗아 / 돌려주고 ), 옛날 아버지가 숨어 돌아가셨던 뒷산 ( 동굴 / 폐가 )로 몸을 숨깁니다. 이는 현이 평생 처음으로 현실에 대해 ( 소극적 방관이 아닌 / 적극적 순응이 아닌 ), ( 적극적인 저항 / 또 다른 도피 )을 선택한 순간이었습니다.

**4. 할아버지의 마지막 외침** 현이 숨은 곳을 알아낸 연호는 ( 비열한 / 정당한 ) 방법을 씁니다. 바로 현의 ( 할아버지 / 친구 )를 인질로 잡아 동굴 앞으로 끌고 와, ( 투항하지 않으면 / 협력하지 않으면 ) 할아버지를 죽이겠다고 협박한 것이죠. 평생 손자의 ( 안위만을 / 성공만을 ) 바라던 할아버지는 처음에는 ( 살기 위해 / 명예를 위해 ) 현에게 나오라고 애원합니다. 하지만 이내 무언가를 ( 결심한 듯 / 포기한 듯 ), "아니다! 너만이라도 살아내야 한다!"라고 외칩니다. 할아버지의 이 외침은 평생 현실에 ( 순응하며 / 저항하며 ) 살라던 가르침을 뒤집는, 손자를 향한 ( 마지막 사랑이자 명령 / 절망적인 체념 )이었습니다. 이 말에 ( 분노한 / 감동한 ) 연호는 할아버지를 총으로 쏴 죽이고 맙니다.

**5. 꺼지지 않는 생명의 '불꽃'** 할아버지의 ( 죽음을 / 희생을 ) 눈앞에서 목격한 현은 ( 이성을 / 총을 ) 잃고 동굴 밖으로 뛰쳐나갑니다. 그는 연호를 향해 총을 쏘고, 연호 역시 현에게 ( 총을 / 칼을 ) 쏩니다. 현은 ( 어깨에 / 마음에 ) 총을 맞고 쓰러져 죽어갑니다. 그런데 바로 그 ( 죽음의 / 절망의 ) 순간, 현은 끔찍한 고통 속에서 ( 역설적으로 / 당연하게도 ) 자신이 '살아있다'는 강렬한 느낌과 함께, 마음속에서 뜨거운 '( 불꽃 / 얼음 )'이 타오르는 것을 느낍니다. 그는 비로소 ( 깨닫습니다 / 후회합니다 ). ( 행동하는 / 순응하는 ) 삶을 살았던 아버지도, ( 순응하는 / 행동하는 ) 삶을 살았던 할아버지도 모두 각자의 방식으로 ( 치열하게 / 허무하게 ) 살아왔다는 것을. 그리고 이제 자신도 더 이상 ( 도망치지 않고 / 순응하지 않고 ), 부조리한 현실과 ( 맞서 싸우는 / 타협하는 ) 삶을 살아야겠다고 굳게 ( 결심하며 / 포기하며 ) 의식을 잃습니다.`
        };


        // 2단계: 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "불꽃",
                meaning: "타오르는 불의 혀. 또는 정열이나 기세 따위를 비유적으로 이르는 말.",
                type: "핵심 소재어",
                confusors: {
                    word: ["불빛", "화염", "열정"],
                    meaning: ["불에서 나는 빛.", "타오르는 불.", "강렬한 감정이나 의욕."]
                }
            },
            {
                word: "동굴",
                meaning: "산기슭이나 강가 따위에 바위가 속으로 깊숙이 쑥 들어가서 굴처럼 된 곳.",
                type: "핵심 소재어",
                confusors: {
                    word: ["폐가", "산골", "은신처"],
                    meaning: ["버려진 집.", "산속의 외딴 마을.", "숨어서 살아가는 곳."]
                }
            },
            {
                word: "생명",
                meaning: "사람이 태어날 때부터 지닌 목숨이나 운명.",
                type: "핵심 소재어",
                confusors: {
                    word: ["인생", "운명", "존재"],
                    meaning: ["사람이 살아가는 일.", "정해진 운세.", "실제로 존재하는 것."]
                }
            },
            {
                word: "학병",
                meaning: "학생의 신분으로 군대에 지원하거나 강제로 징집됨. 또는 그런 군인.",
                type: "역사/사회",
                confusors: {
                    word: ["징용", "의용군", "학도병"],
                    meaning: ["일정한 나이의 사람을 강제로 동원함.", "자원하여 군에 입대한 군인.", "학생 신분의 군인."]
                }
            },
            {
                word: "인민재판",
                meaning: "인민의 이름으로 반혁명 분자나 악질 지주 따위를 재판하던 일.",
                type: "역사/사회",
                confusors: {
                    word: ["민주재판", "혁명재판", "민중재판"],
                    meaning: ["민주주의 원리에 따른 재판.", "혁명 과정에서 행해진 재판.", "민중이 주도한 재판."]
                }
            },
            {
                word: "유랑민",
                meaning: "일정한 거처가 없이 떠돌아다니는 사람.",
                type: "역사/사회",
                confusors: {
                    word: ["난민", "이주민", "방랑자"],
                    meaning: ["전쟁이나 재해로 집을 잃고 떠도는 사람.", "다른 곳으로 이주한 사람.", "정처 없이 떠도는 사람."]
                }
            },
            {
                word: "공산주의",
                meaning: "계급 투쟁을 통하여 자본주의 사회를 타도하고 사회주의 및 공산주의 사회를 건설하려는 운동.",
                type: "역사/사회",
                confusors: {
                    word: ["사회주의", "자본주의", "민주주의"],
                    meaning: ["생산 수단의 공유를 주장하는 사상.", "사유 재산제를 기반으로 한 경제 체제.", "국민이 주권을 가지는 정치 체제."]
                }
            },
            {
                word: "허무",
                meaning: "아무것도 없이 텅 빔. 또는 인생이 덧없고 무상함.",
                type: "상황/정서",
                confusors: {
                    word: ["공허", "절망", "무의미"],
                    meaning: ["아무것도 없는 상태.", "희망을 잃은 상태.", "의미가 없는 상태."]
                }
            },
            {
                word: "냉담",
                meaning: "아무런 의욕이나 감흥이 없이 매우 메마르고 차가움.",
                type: "상황/정서",
                confusors: {
                    word: ["무관심", "냉정", "무심"],
                    meaning: ["관심을 가지지 않음.", "감정에 휩쓸리지 않음.", "아무런 마음이 없음."]
                }
            },
            {
                word: "기피",
                meaning: "회피하여 일을 맡지 아니함.",
                type: "상황/정서",
                confusors: {
                    word: ["회피", "도피", "거부"],
                    meaning: ["피하여 돌아감.", "위험을 피해 도망감.", "받아들이지 않음."]
                }
            },
            {
                word: "체념",
                meaning: "희망을 버리고 단념함.",
                type: "상황/정서",
                confusors: {
                    word: ["포기", "단념", "체포"],
                    meaning: ["이미 시작한 일을 그만둠.", "희망을 버리고 포기함.", "범인을 잡아서 구속함."]
                }
            },
            {
                word: "현실 도피",
                meaning: "현실에 대하여 부정적인 태도를 취하고 그로부터 도피하려는 경향.",
                type: "상황/정서",
                confusors: {
                    word: ["현실 부정", "현실 회피", "현실 외면"],
                    meaning: ["현실을 인정하지 않음.", "현실을 피해 돌아감.", "현실을 보지 않으려 함."]
                }
            },
            {
                word: "인고",
                meaning: "온갖 모욕과 수모를 참고 견딤.",
                type: "상황/정서",
                confusors: {
                    word: ["인내", "참을성", "고통"],
                    meaning: ["어려움을 참고 견딤.", "참을 수 있는 성질.", "신체적 또는 정신적 아픔."]
                }
            },
            {
                word: "경도",
                meaning: "사상이나 이념 따위에 물듦.",
                type: "상황/정서",
                confusors: {
                    word: ["몰입", "집착", "착취"],
                    meaning: ["어떤 일에 깊이 빠짐.", "한 가지에만 마음을 쏟음.", "다른 사람의 노동을 착취함."]
                }
            }
        ];

        // 3단계 문장 독해 데이터
        const sentenceData = [
            {
                sentence: "산다는 것, 그것은 부단히 자기를 죽여 가는 과정에 지나지 않았다. 모든 '삶'은 '죽음'의 동의어였다.",
                question: "이 문장에 드러난 주인공 '현'의 초기 삶의 태도를 한 단어로 표현한다면 무엇인가요?",
                correctAnswer: "허무주의(또는 염세주의)",
                distractors: [
                    "낙천주의",
                    "실용주의", 
                    "이상주의"
                ]
            },
            {
                sentence: "할아버지의 혹을 보고 아이들이 놀려 주었을 때 싸움 끝에 도리어 할아버지에게 회초리를 맞고 나서부터 현은 모든 것에 '체념'하는 버릇이 붙었다.",
                question: "'현'이 '체념'하는 성격을 갖게 된 직접적인 계기가 된 사건은 무엇인가요?",
                correctAnswer: "할아버지를 위해 아이들과 싸웠지만, 오히려 할아버지에게 회초리를 맞았던 사건",
                distractors: [
                    "아버지가 3·1 운동에서 죽은 사건",
                    "일본 유학에서 돌아온 사건",
                    "학병으로 끌려간 사건"
                ]
            },
            {
                sentence: "아버지는 영웅, 할아버지는 살기 위하여 모든 것을 참고 비굴하게 사는 자, 자기는... 현은 자기 존재에 대하여 아무런 대답을 가질 수 없었다.",
                question: "아버지와 할아버지 사이에서 '현'이 느끼는 내적 갈등의 핵심은 무엇인가요?",
                correctAnswer: "대립되는 두 가치관 사이에서 어느 쪽도 선택하지 못하고 정체성의 혼란을 겪는 것",
                distractors: [
                    "아버지를 영웅으로 생각하지만 할아버지를 비굴하다고 여기는 것",
                    "할아버지의 순응주의를 이해하지만 아버지의 저항을 존경하는 것",
                    "두 사람 모두 비겁하다고 생각하는 것"
                ]
            },
            {
                sentence: "꽃 또는 강아지, 송아지, 병아리, 이런 것에만 현은 마음을 붙였다. 거기에는 증오도 투쟁도 있을 수 없기 때문이었다.",
                question: "'현'이 생명이 있는 작은 것들에 마음을 붙인 이유는 무엇인가요?",
                correctAnswer: "증오나 투쟁이 없는 순수한 생명의 세계에서 위안을 얻기 위해서",
                distractors: [
                    "동물을 사랑하는 마음이 강해서",
                    "어린 시절부터 동물을 키워왔기 때문에",
                    "동물들이 자신을 따르기 때문에"
                ]
            },
            {
                sentence: "이부자리 위에서 그는 수없이 되풀이하여 연호를 때려눕혔다. 그럴 때마다 현은 이상한 쾌감과 부끄러움을 함께 느끼는 것이었다.",
                question: "인민재판을 목격한 후 '현'이 '쾌감'과 '부끄러움'을 동시에 느낀 이유는 무엇인가요?",
                correctAnswer: "쾌감은 연호의 폭력에 대한 분노를 상상 속에서 해소하는 감정이고, 부끄러움은 현실에서 아무것도 하지 못하는 자신의 소극적 모습에 대한 자책감",
                distractors: [
                    "쾌감은 연호를 이겼다는 승리감이고, 부끄러움은 폭력을 사용한 것에 대한 죄책감",
                    "쾌감은 연호의 행동을 이해했다는 감정이고, 부끄러움은 자신의 무력함에 대한 절망",
                    "쾌감은 연호와의 우정을 회복했다는 기쁨이고, 부끄러움은 과거의 실수에 대한 후회"
                ]
            },
            {
                sentence: "그러나 지금 할아버지의 이 외침은 분명히 다른 것이었다. 그 속에는 뼈에 저리도록 아프게 하는 무서운 채찍이 있었다.",
                question: "'지금 할아버지의 이 외침'은 구체적으로 어떤 말이며, 왜 '무서운 채찍'처럼 느껴졌나요?",
                correctAnswer: "\"너만이라도 살아내야 한다\"는 외침으로, 평생 순응하라고 가르쳤던 할아버지의 유언이자 더 이상 비겁하게 숨지 말라는 강력한 명령이었기 때문",
                distractors: [
                    "\"투항하라\"는 외침으로, 할아버지의 마지막 명령이었기 때문",
                    "\"도망치지 마라\"는 외침으로, 할아버지의 엄격한 훈계였기 때문",
                    "\"용기를 내라\"는 외침으로, 할아버지의 격려였기 때문"
                ]
            },
            {
                sentence: "그것은 생물과 무생물의 마찰에서 오는 그러한 단순한 광명이 아니었다. 현 자신 속에서 솟아나는 불꽃이었다.",
                question: "현이 죽음의 순간에 발견한 '불꽃'이 이전의 단순한 '광명'과 다른 점은 무엇인가요?",
                correctAnswer: "'광명'이 외부에서 오는 수동적인 빛이라면, '불꽃'은 자기 내부에서 솟아나는 능동적이고 주체적인 생명 에너지",
                distractors: [
                    "'광명'은 밝은 빛이지만 '불꽃'은 뜨거운 열기",
                    "'광명'은 일시적이지만 '불꽃'은 영원함",
                    "'광명'은 차가운 빛이지만 '불꽃'은 따뜻한 열"
                ]
            },
        ];

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 4단계 전용 변수
        let stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],
            startTime: 0,
            timeRemaining: 120,
            maxTime: 120
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            console.log('=== 학습 페이지 초기화 (v2025-10-21-debug) ===');
            console.log('iframe으로 로드됨:', window.self !== window.top);
            console.log('window.parent 존재:', !!window.parent);
            console.log('window.parent !== window:', window.parent !== window);
            console.log('현재 URL:', window.location.href);

            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            renderPassage();
            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 마크다운 처리 (하이라이트 처리 전에 먼저 실행)
            // 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (마크다운 테이블을 HTML 테이블로 변환)
            const tableRegex = /^\|.+\|$/gm;
            const tableMatches = [];
            let match;
            while ((match = tableRegex.exec(html)) !== null) {
                tableMatches.push(match.index);
            }

            if (tableMatches.length > 0) {
                // 테이블 라인들을 찾아서 그룹화
                let i = 0;
                while (i < tableMatches.length) {
                    let tableStart = tableMatches[i];
                    let tableEnd = tableMatches[i];
                    let j = i + 1;

                    // 연속된 테이블 라인 찾기
                    while (j < tableMatches.length && tableMatches[j] - tableEnd < 100) {
                        tableEnd = tableMatches[j];
                        j++;
                    }

                    // 테이블 텍스트 추출
                    let beforeTable = html.substring(0, tableStart);
                    let afterTable = html.substring(tableEnd + html.substring(tableEnd).indexOf('\n') + 1);
                    let tableText = html.substring(tableStart, tableEnd + html.substring(tableEnd).indexOf('\n'));

                    const lines = tableText.split('\n').filter(line => line.trim().startsWith('|'));

                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0;">';
                    let rowIndex = 0;

                    lines.forEach((line) => {
                        // 구분선 스킵
                        if (line.match(/^\|\s*:?-+:?\s*\|/)) return;

                        const cells = line.split('|').slice(1, -1); // 첫번째와 마지막 빈 요소 제거
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f8f9fa; font-weight: 600;' : '';

                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<${tag} style="border: 1px solid #ddd; padding: 12px; text-align: left; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHTML += '</tr>';
                        rowIndex++;
                    });

                    tableHTML += '</table>';
                    html = beforeTable + tableHTML + afterTable;

                    i = j;
                }
            }

            // 볼드 처리
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                return `<div class="subsection">• ${content}</div>`;
            });

            // 하이라이트 처리 (마지막에 실행 - HTML 변환된 내용에 적용)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                } else if (currentStage === 5) {
                    stage5Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            } else if (currentStage === 5) {
                stage5Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            } else if (currentStage === 5) {
                stage5Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            // 2단계 어휘 학습으로 전환
            currentStage = 2;
            initStage2();
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // 단어 → 뜻 문제
                const wordToMeaning = {
                    type: 'word-to-meaning',
                    question: `"${vocab.word}"의 의미는?`,
                    correct: vocab.meaning,
                    word: vocab.word,
                    options: shuffleArray([
                        vocab.meaning,
                        ...vocab.confusors.meaning.slice(0, 3)
                    ])
                };

                // 뜻 → 단어 문제
                const meaningToWord = {
                    type: 'meaning-to-word',
                    question: `"${vocab.meaning}"를 나타내는 용어는?`,
                    correct: vocab.word,
                    meaning: vocab.meaning,
                    options: shuffleArray([
                        vocab.word,
                        ...vocab.confusors.word.slice(0, 3)
                    ])
                };

                stage2Data.questions.push(wordToMeaning, meaningToWord);
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장과 질문 표시
            document.getElementById('sentence-text').textContent = question.sentence;
            document.getElementById('sentence-question').textContent = `Q. ${question.question}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }


        const oxQuizData = [
            { question: "현의 할아버지는 3·1 운동으로 아들을 잃은 후, 손자 현에게도 아버지처럼 저항하는 삶을 살라고 가르쳤다.", answer: false, explanation: "할아버지는 저항하는 삶이 아닌, 현실에 순응하는 소극적인 삶을 살라고 가르쳤습니다. 인물의 가치관을 정반대로 왜곡했습니다." },
            { question: "현은 인민재판에서 친구 연호의 폭력적인 모습을 보고 처음으로 그에게 분노를 느꼈다.", answer: true, explanation: "지문 내용과 일치합니다. 이전까지 현실을 회피하던 현이 처음으로 분노를 느끼고 행동에 나서는 계기가 됩니다." },
            { question: "할아버지는 동굴 앞에서 처음부터 끝까지 현에게 투항하라고만 외쳤다.", answer: false, explanation: "할아버지는 처음에는 투항하라고 외쳤지만, 이내 태도를 바꾸어 \"너만이라도 살아내야 한다\"고 외쳤습니다. 인물의 태도 변화 과정을 무시하고 한 가지 행동만 한 것처럼 왜곡했습니다." },
            { question: "현은 할아버지의 죽음을 목격한 후, 현실에 대한 저항을 포기하고 동굴 속으로 더 깊이 숨었다.", answer: false, explanation: "현은 할아버지의 죽음 이후 동굴 밖으로 뛰쳐나와 저항하는 행동을 선택했습니다. 동굴 속으로 더 깊이 숨는 도피를 선택했다는 진술은 사실과 다릅니다." },
            { question: "죽음의 순간, 현은 고통 속에서 오히려 강렬한 생명력을 느끼며 새로운 삶을 결심했다.", answer: true, explanation: "지문 내용과 일치하며, 작품의 핵심 주제 의식을 드러내는 부분입니다." },
            { question: "현의 아버지는 한국 전쟁에 참전했다가 전사했다.", answer: false, explanation: "현의 아버지가 죽은 것은 '3·1 운동' 때이며, '한국 전쟁'은 현의 세대에 일어난 일입니다. 서로 다른 시대의 사건을 부적절하게 결합했습니다." },
            { question: "현은 학병으로 끌려갔다가 탈출한 경험이 있다.", answer: true, explanation: "지문 내용과 일치합니다." },
            { question: "연호는 현의 할아버지를 인질로 삼아 현의 투항을 유도했다.", answer: true, explanation: "지문 내용과 일치합니다." },
            { question: "현은 죽음의 순간에 이르러서야 저항했던 아버지와 순응했던 할아버지의 삶 모두가 치열했음을 깨달았다.", answer: true, explanation: "지문 내용과 일치합니다. 이는 현이 이전의 이분법적 사고에서 벗어나 통합적인 시각을 갖게 되었음을 보여줍니다." },
            { question: "현은 할아버지의 죽음을 보고 분노하여 연호와 총격전을 벌였다.", answer: true, explanation: "지문 내용과 일치합니다." },
            { question: "할아버지는 아들의 죽음을 자랑스럽게 생각하며, 현에게 늘 아버지의 뜻을 따르라고 말했다.", answer: false, explanation: "할아버지는 아들의 죽음을 못마땅하게 여겼으며, 현에게는 아버지와 반대로 살라고 가르쳤습니다. 할아버지의 태도를 긍정적인 것처럼 왜곡했습니다." },
            { question: "현은 연호의 권유를 받아들여 공산주의 활동에 잠시 가담했었다.", answer: false, explanation: "현은 연호의 권유를 거절했으며, 어떤 이념에도 가담하지 않으려 했습니다. 소설에 등장하지 않는 허구의 사실입니다." },
            { question: "현은 인민재판의 폭력성을 목격한 후, 연호를 제지하고 그의 총을 빼앗아 달아났다.", answer: true, explanation: "지문 내용과 일치합니다. 현의 첫 번째 저항 행동입니다." },
            { question: "현은 연호와의 총격전에서 승리하여 살아남은 뒤 새로운 삶을 다짐했다.", answer: false, explanation: "현은 연호가 쏜 총에 맞아 쓰러져 죽어가는 과정에서 새로운 삶을 다짐한 것이지, 총격전에서 승리하고 살아남은 것이 아닙니다." },
            { question: "'동굴'은 현의 아버지가 죽음을 맞이한 비극적 공간이자, 현이 현실로부터 도피하는 공간이다.", answer: true, explanation: "지문 내용과 일치합니다. 동굴은 아버지의 저항과 죽음, 현의 도피와 각성이라는 이중적 의미를 지닙니다." },
            { question: "할아버지는 연호의 총에 맞아 죽기 직전, \"너만이라도 살아내야 한다\"고 외쳐 현의 생존을 독려했다.", answer: true, explanation: "지문 내용과 일치합니다. 할아버지의 태도 변화를 보여주는 결정적인 대사입니다." },
            { question: "현은 어린 시절, 할아버지를 놀리는 아이들과 싸웠다가 오히려 할아버지에게 칭찬을 받았다.", answer: false, explanation: "현은 칭찬이 아닌 '회초리'를 맞았습니다. 이 사건은 현이 체념하는 성격을 갖게 된 계기가 되었는데, 이를 칭찬받은 긍정적 경험처럼 왜곡했습니다." },
            { question: "현이 마지막에 느낀 '불꽃'은 모든 것을 포기하고 싶은 절망적인 심정을 상징한다.", answer: false, explanation: "'불꽃'은 새로운 삶에 대한 의지와 생명력을 상징합니다. 이를 절망이라는 정반대의 의미와 연결하여 내용을 왜곡했습니다." },
            { question: "현은 일본 유학 시절, 일본인 친구의 제국주의 찬양에 동조하며 그들과 어울렸다.", answer: false, explanation: "현은 친구의 모습에 '환멸'을 느끼고 귀국했습니다. 그들의 사상에 동조했다는 것은 인과 관계를 왜곡한 것입니다." },
            { question: "현은 총에 맞고 쓰러진 후, 자신의 삶이 아무것도 없는 '무(無)'라고 느끼며 생을 마감했다.", answer: false, explanation: "현은 총에 맞고 쓰러진 후, 자신의 삶이 '무(無)'가 아니라 '새로운 창조를 위한 출발'이 되어야 한다고 깨달았습니다. 인식의 변화 방향을 정반대로 서술했습니다." }
        ];

        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '선우휘 <불꽃>';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            // currentStage가 4가 아니면 함수를 종료
            if (currentStage !== 4) {
                return;
            }
            
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 진짜 원문 표시
            const originalText = `불꽃

선우 휘


제Ⅰ부

1

민 씨는 대학 시절 그의 별명이 '식민지(植民地)'였다는 말을 가끔 하곤 한다. 민 씨와 그의 친구들은 그것을 생각할 때마다 폭소를 터뜨린다. 무엇을 의미하는지 그것이 왜 우스운지 나는 그들과 함께 그 추억에 참여하지 못하는 것이 유감이다. 그러나 분명한 것은 그 하찮은 별명의 배후에는 무엇인가 젊은 날의 명랑함이 잠겨 있다는 것이다. 아마도 지금 민 씨의 나이는 마흔 안팎이 될 것이다. 그렇다면 그의 대학 시절은 조국이 해방되고 곧 터진 6·25사변을 전후한 십 년을 두고 말하는 것이다. 바로 그 시기에 벌써 민 씨는 별명의 상징을 가진 인간으로 형성되기 시작하고 있었던 것이다. 광복과 민족 분열과 형제의 싸움을 지나면서도 그의 벌명이 빛을 잃지 않았다는 것은 재미있는 일이다. 공산주의에 반대하는 사람들이 공산주의는 인간의 개성을 무시한다는 비난을 즐겨 하는데 민 씨에게는 그것이 철저히 구현되었던 것 같다. 이런 말을 하면 민 씨는 불쾌하게 생각할지 모른다. 그는 일찍이 일 년 동안의 옥살이를 그의 경력에 기록하고 있는 까닭이다.

그는 서울에 살고 있다. 나는 멀리 떨어진 지방 도시에 살기 때문에 일 년에 한두 번 만날 기회밖에 없다. 그리고 그렇게 만날 때에도 옛날 이야기에 관해서라든가 성공담과 또 우리 자신의 은밀한 사생활에 관해서 이야기를 나눌 뿐이다. 지금도 무엇인가 민 씨에게 자기 확인을 결여하고 있는 듯한 기분을 느낄 때가 있으나 그것이 그의 생활과 다른 사람에게까지 어떤 악조건을 만들어 주는지는 알 수 없다. 인간의 특성이 인간관계를 결정한다고도 하지만 특히 한국 사회 안에서는 우리들의 전통적인 형식이 지배하고 있으며 거기에는 특별한 양식이 존재하고 있다. 그것에 익숙하면 된다. 사람들은 흔히 일상생활에서보다도 휴가 동안 여행 중에 만난 사람들의 개성을 더 뚜렷하게 기억하는 것 같다. 일상생활을 정지시키고 고립시킬 수 있는 여건이 사람들로 하여금 인간의 본성을 드러내 보이게 하는지도 모른다.

내가 민 씨를 만난 것은 삼 년 전 설악산 기슭에 있는 한 시골 여관에서였다. 그곳으로부터 멀지 않은 해안 도시에는 내가 근무하던 직장이 있었다. 나는 그 시절 방학 동안 혼자서 전국을 떠돌아다니곤 했다. 그때 나는 인제에서부터 설악산 입구인 장수대까지 차편으로 가서 걸어서 백담사를 찾아갈 참이었다. 자동차 종점인 그곳에는 단칸방으로 된 구멍가게가 있었다. 정미소는 문을 닫고 있었다. 그날은 비가 와서 나는 하는 수 없이 장수대에서 일박하고 다음 날 백담사로 가기로 결정했다. 저녁이 가까워질 무렵 한 떼의 인원을 실은 지프가 도착했다. 그리고 그들이 모두 내릴 때 문득 내 앞으로 다가온 사람이 있었다. 나는 곧 기억해 낼 수 없었는데 상대는 먼저 나에게 악수를 청하면서 얘기를 걸어왔다. 물론 내가 그를 기억해 내기까지는 그리 오래 걸리지는 않았다. 그는 나와 같은 대학에 다니던 동창생인 민 씨였다.

그를 알고 나니까 그때까지 막연하게 어둠 속으로 빠지던 그날 저녁이 환하게 밝혀지는 것만 같았다. 그는 대학 졸업 후 몇 년 동안 미국에 유학했으며 어떤 중견 기업체의 임원을 지내고 있다고 소개했다. 그리고 그가 거느리고 온 일행은 그 회사의 간부들과 그 가족이라는 것이었다. 민 씨는 위로는 간부가 있고 밑으로는 사원이 있는 중간의 위치였지만 일행 중에서 유일한 미국 유학생 출신이었기 때문에 자연 영어 회화는 물론 여러 가지 사교적인 면에서 촉탁을 받고 있었다.

정미소 주인이 밥을 지었다. 민 씨와 나 그리고 그들 일행까지 합치면 도합 열댓 명이 되었기 때문에 식사 준비는 저녁 늦게까지 걸렸다. 민 씨와 나는 술을 한 병 사 가지고 한쪽 구석에서 마주 앉아 잔을 나누었다. 그가 대학 시절 '식민지'라는 별명을 가지고 있었다는 말을 듣게 된 것은 바로 그날 밤이었다. 밤이 깊어 나는 비로소 자리에 누워 잠을 잘 수가 있었다. 뒤늦게 민 씨도 들어와 잠자리에 들었다. 그러나 사람이 많고 공간이 좁았기 때문에 단잠은 청하기 어려웠다.

새벽에 나는 몸을 뒤척이다가 잠이 깨어 담배를 찾았으나 없었다. 나는 잠옷 차림으로 정미소 앞 구멍가게에 갔다. 담배를 사서 돌아오려고 하는데 이미 두어 사람이 밖에 나와 있었다. 그중의 한 사람은 민 씨였다. 또 한 사람은 키가 훤칠하게 큰 사십 대의 사나이였다. 나중에 알고 보니 그는 민 씨가 다니는 회사의 전무였다.

"이것 참, 생각지도 못한 일이었습니다."

훤칠한 사나이는 초면이었지만 나에게 성가시게 반가운 투로 인사를 했다. 나는 웃으면서 그에게 인사를 하고 대답했다.

"아침 일찍 일어나셨군요."

"글쎄 말입니다. 이런 데 와서 자는 것도 그렇고 그렇습니다."

그는 신문을 읽고 있다가 자기가 읽던 곳에 손가락을 끼워 넣은 채 고개를 들고 말하는 것이었다.

"아무튼 우리도 가끔 이런 데 나와서 자연에 묻혀 쉬어야 됩니다. 그것이 우리 건강에도 좋고 정신 건강에도 좋을 것입니다."

그의 말은 빈틈이 없었다.

"그렇습니다."

나는 인사치레로 맞장구를 치고 얼른 민 씨에게로 다가갔다.

민 씨는 멀거니 연못을 바라보고 서 있었다. 장수대 앞에는 좁지만 연못이 있고 거기에는 잉어가 많았다.

"저 연못을 보세요."

민 씨는 나에게 연못을 가리켜 보이며 말했다.

"정말 맑군요."

그때 우리 뒤에서 훤칠한 사나이가 말했다.

"저것 좀 봐요. 물이 얼마나 맑은지 저 밑바닥까지 훤히 들여다보입니다."

"......"

민 씨는 대답이 없었다.

"저 잉어들 말입니다. 참 유유자적이지요."

"......"

민 씨는 여전히 대꾸가 없었다. 훤칠한 사나이는 혼자 지껄이다가 무슨 생각을 했는지 다시 처마 밑으로 가 버렸다. 나는 민 씨가 전무의 말에 무관심한 것이 이상스러웠다. 어쩌면 일부러 냉대하는 것만 같기도 했다.

이윽고 해가 떠올랐다. 날씨는 전날과는 달리 개었다. 민 씨네 일행은 아침 일찍 다시 지프에 올라 산속으로 떠나 버렸다. 나는 전날 계획대로 백담사로 갔다.

2

민 씨와 나는 그 후에 또 만났다. 다시 설악산 장수대였다. 그날도 장수대에서 다음 날 나는 백담사로 그리고 민 씨는 산장으로 갔다. 그리고 삼 일째 되는 날 백담사를 떠나 내려오는 나와 산장을 떠나 내려온 민 씨가 장수대에서 만난 것이다. 또 그곳에서 일박을 하게 되었다.

"저번에는 장수대에서 비를 만났으나 백담사는 괜찮았지요?"

"예, 괜찮았습니다."

민 씨는 당시 다시 전무와 함께였으나 나머지 일행은 없었다.

"다음에 한번 우리 회사로 놀러 오세요. 내 사무실로 찾아오면 됩니다."

민 씨는 친절하게 청했다. 그때 나는 몹시 궁금했다. 이 사람은 언제나 혼자 있을 때와 여러 사람과 함께 있을 때 다른 것만 같았다. 훤칠한 사나이는 민 씨에게 무척 호의를 가지고 대하는 것이 역력했다. 그러나 민 씨는 냉담한 것만 같았다. 그것이 몹시 인상적이었으나 마음에 걸리기도 했다.

"다음에 서울 가게 되면 꼭 들르겠습니다."

나는 형식적이 아닌 진정으로 그렇게 대답을 했다.

나는 얼마 뒤 서울에 갔다. 물론 민 씨를 만나기 위해서였다. 민 씨가 근무하는 회사는 서울 중심부에 있었다. 나는 그곳으로 민 씨를 찾아갔다. 그는 매우 반가워했다. 그리고 나를 데리고 다방으로 갔다. 우리들은 두어 시간 이야기를 나누었다. 처음에는 서로 안부를 묻고 다음에는 민 씨의 가정에 관해서 들었다. 그는 슬하에 자녀가 둘 있었다. 부인은 현모양처형이며 아주 얌전하고 말이 없는 사람이라고 했다. 그리고 월급에 관한 이야기도 나왔다. 민 씨는 상당히 많은 봉급을 받고 있는 것 같았다.

"꽤 많이 버시는군요."

"그렇습니다. 월급은 많은데 그것이 어디로 가는지 모르겠습니다."

"쓸 데야 많겠지요."

나는 위로조로 말했다. 사실 나는 민 씨가 부럽기도 했다.

"아이들 교육비도 많이 듭니까?"

"물론입니다. 그렇지만 그것만이 아닙니다. 사교비가 많이 든다는 것이 문제입니다. 당신도 아시겠지만 내가 이 회사에서 차지하고 있는 위치 말입니다. 윗사람들의 비위도 맞춰야 하고 또 아랫사람들과도 어울려야 합니다. 그것이 여간 힘든 것이 아닙니다."

"그거야 당연한 것 아닙니까?"

"물론 그렇게 생각할 수도 있지요. 그렇지만 때로는 나 자신이 한심스러워질 때가 있습니다."

"......"

나는 무슨 뜻인지 잘 모르겠다는 듯 그저 담배만 빨았다.

"나는 지금 내 자신이 없습니다. 내 생활을 돌아보면 언제나 남의 생활입니다. 집에서는 아버지라는 위치 때문에 아버지 노릇을 해야 하고 회사에서는 과장이라는 위치 때문에 과장 노릇을 해야 합니다. 가끔 나는 이것이 정말 내 생활인가 하고 의심할 때가 있습니다."

나는 민 씨의 이야기를 들으면서 그가 설악에서 그 전무와 함께 있었던 광경이 생각났다. 그때 민 씨가 보여 주던 냉담한 태도와 지금 그의 이야기가 일치하는 것만 같았다. 나는 감히 충고할 수 있는 아무런 지혜도 없었다. 오히려 내 자신도 그와 같은 번민을 느끼고 있었기 때문이다.

나는 민 씨와 헤어져서 하숙집으로 돌아왔다. 그날 밤 나는 민 씨에 관해서 여러 가지로 생각을 해 보았다. 그는 분명히 지금의 그의 생활을 좋아하지 않았다. 그러면서도 그는 그것을 청산할 수 있는 아무런 용기도 가지고 있지 않았다.

사람이 살아가는 데는 여러 가지 조건이 필요한 것이라고 생각했다. 그중에는 용기도 있고 지혜도 있을 것이다. 민 씨는 지금 무기력한 상태로 자신의 생활을 그저 받아들이고 있을 뿐이었다. 나는 그것이 안타까웠다.

제Ⅱ부

3

그로부터 일 년이 지난 다음이었다. 나는 다시 서울에 갔다. 그리고 민 씨를 만나러 그의 회사에 찾아갔다. 그런데 놀랍게도 민 씨는 이미 그 회사를 그만두었다는 것이었다. 나는 그의 집 주소를 알아서 찾아갔다.

현관문을 열고 나온 사람은 민 씨의 부인이었다. 나는 민 씨의 대학 친구라고 소개를 했다. 부인은 나를 반갑게 맞아들였다. 민 씨는 집에 없었다. 출판사에 나갔다는 것이었다.

"출판사요?"

나는 놀라서 되물었다.

"예, 지금 출판사를 하고 있습니다."

부인은 웃으면서 대답했다. 나는 민 씨가 회사를 그만두고 출판사를 차렸다는 것이 못내 믿어지지 않았다.

"그럼 회사는 언제 그만두셨습니까?"

"벌써 반 년이나 됩니다."

"......"

나는 부인의 얼굴을 뚫어지게 바라보았다. 부인은 태연했다. 나는 민 씨가 회사를 그만두고 출판사를 차렸다는 것이 매우 뜻밖이었다.

"남편이 돌아오면 꼭 댁에 들르시라고 전하겠습니다. 주소를 남겨 주시면 좋겠습니다."

부인은 친절했다. 나는 명함을 한 장 주고 나왔다.

그날 오후 나는 호텔 방에서 쉬고 있었는데 민 씨에게서 전화가 왔다. 나는 약속 장소로 나갔다. 민 씨는 벌써 나와서 나를 기다리고 있었다.

"자네 회사 그만뒀다면서?"

나는 만나자마자 물었다.

"그래, 그만뒀네."

민 씨는 태연하게 대답했다.

"왜 그만뒀나?"

"글쎄, 여러 가지 이유가 있었지."

민 씨는 시원스럽게 대답을 하지 않았다.

"그래서 지금은 출판사를 한다면서?"

"그렇네. 아직 시작한 지 얼마 안 돼서 형편은 좋지 않지만 그래도 재미가 있네."

민 씨는 비로소 밝은 얼굴로 말했다.

"그렇지만 위험하지 않나? 출판사라는 것이 요새 얼마나 많은가? 그리고 또 경쟁도 심하고....."

나는 걱정스럽게 말했다.

"물론 위험하지. 그렇지만 나는 지금 행복하네. 적어도 내 자신의 생활을 하고 있다는 느낌을 가지고 있으니까."

민 씨는 자신 있게 대답했다. 나는 민 씨의 태도에서 일 년 전과는 아주 다른 무엇인가를 발견했다. 그것은 생기였다. 일 년 전의 민 씨는 무기력했다. 그러나 지금의 민 씨는 생기에 넘쳐 있었다.

"자네 정말로 행복한가?"

나는 다시 물었다.

"그렇네. 비록 경제적으로는 일 년 전만 못하지만 정신적으로는 훨씬 풍요롭다네. 나는 지금 내가 하고 싶은 일을 하고 있으니까."

민 씨는 힘주어 말했다.

나는 민 씨와 헤어져 나오면서 많은 것을 생각했다. 인간은 빵만으로 사는 것이 아니라는 성경 말씀이 생각났다. 민 씨는 지금 경제적으로는 어려울지 몰라도 정신적으로는 자유로웠다. 그리고 그것이 그를 행복하게 만들고 있었다.

4

그로부터 또 일 년이 지났다. 나는 다시 서울에 갔다. 그리고 민 씨의 출판사를 찾아갔다. 출판사는 제법 번듯했다. 민 씨는 나를 보자 반색을 하며 맞아들였다.

"어떤가, 사업은 잘되나?"

나는 걱정스럽게 물었다.

"그럭저럭 되어 가네. 물론 큰 출판사들처럼 잘되지는 않지만 그래도 먹고사는 데는 지장이 없네."

민 씨는 웃으며 대답했다.

"다행이군. 그렇지만 너무 무리하지는 말게."

"고맙네. 그런데 자네는 어떤가? 아직도 그 학교에 있나?"

민 씨가 물었다.

"그렇네. 아직도 그대로 있네."

나는 씁쓸하게 대답했다.

"왜 그러나? 무슨 일 있나?"

민 씨는 내 표정을 보고 물었다.

"아니, 별일은 없네. 다만 가끔 내 생활이 권태롭다는 생각이 들 때가 있어."

나는 솔직하게 말했다.

"그럼 자네도 한번 변화를 시도해 보는 것이 어떤가?"

민 씨가 말했다.

"변화라니?"

"그렇네. 나처럼 말일세. 나는 회사를 그만두고 출판사를 시작했을 때 매우 불안했네. 그렇지만 지금은 그때의 결정을 후회하지 않네. 물론 경제적으로는 어렵지만 정신적으로는 훨씬 자유롭고 행복하니까."

민 씨는 힘주어 말했다.

나는 민 씨의 말을 들으면서 많은 것을 느꼈다. 민 씨는 변했다. 일 년 전에 비해서도 더욱 당당해지고 자신감에 넘쳐 있었다. 그것은 그가 자기 자신의 생활을 찾았기 때문일 것이다.

나는 민 씨와 헤어져 나오면서 나 자신을 돌아보았다. 나는 과연 내 자신의 생활을 하고 있는가? 나는 과연 행복한가?

길거리를 걸으면서 나는 깊은 생각에 잠겼다. 석양이 서쪽 하늘을 붉게 물들이고 있었다. 마치 불꽃처럼.`;

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 재시작
        function restartStage4() {
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];
            stage4Data.startTime = Date.now();
            stage4Data.timerInterval = null;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 타이머 시작
            startTimer();

            // 첫 번째 문제 표시
            showStage4Question();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            if (stage4Data.wrongQuestions.length === 0) {
                alert('틀린 문제가 없습니다.');
                return;
            }

            // 틀린 문제만 보여주는 모드로 전환
            stage4Data.showWrongOnly = true;
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.startTime = Date.now();

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 타이머 시작
            startTimer();

            // 첫 번째 틀린 문제 표시
            showStage4Question();
        }


        // 전체 재시작
        function restartAllStages() {
            // 모든 단계 데이터 초기화
            stage1Data.currentQuestionIndex = 0;
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.startTime = Date.now();
            stage1Data.timerInterval = null;

            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timerInterval = null;

            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timerInterval = null;

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];
            stage4Data.startTime = Date.now();
            stage4Data.timerInterval = null;

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.startTime = Date.now();
            stage5Data.timerInterval = null;

            // 결과 초기화
            stageResults = {};

            // 1단계로 돌아가기
            currentStage = 1;
            initStage1();
        }

        // 결과 다운로드
        function downloadResults() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `불꽃_워크북_최종결과_${timestamp}.png`;
            
            // html-to-image 라이브러리를 사용하여 결과 화면을 이미지로 저장
            const resultScreen = document.getElementById('result-screen');
            
            htmlToImage.toPng(resultScreen, {
                backgroundColor: '#ffffff',
                quality: 1.0,
                pixelRatio: 2
            }).then(function (dataUrl) {
                const link = document.createElement('a');
                link.download = filename;
                link.href = dataUrl;
                link.click();
            }).catch(function (error) {
                console.error('이미지 저장 중 오류 발생:', error);
                alert('결과 저장 중 오류가 발생했습니다.');
            });
        }

        // 전역 함수들
        window.showTextModal = showTextModal;
        window.closeTextModal = closeTextModal;

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
            {
                id: 1,
                question: "이 작품에 등장하는 할아버지, 아버지, 그리고 주인공 '현'은 각기 다른 삶의 방식을 대표한다. 3대에 걸친 세 인물의 삶의 태도를 각각 서술하고, 이러한 설정을 통해 작가가 무엇을 보여주고자 했는지 설명하시오.",
                correctAnswer: "할아버지는 현실의 폭력과 부조리에 순응하며 목숨을 보전하는 것을 최우선으로 여기는 '생존주의적 순응주의자'이다. 아버지는 3·1 운동에 참여하여 목숨을 바친 '민족주의적 행동주의자'이다. 주인공 '현'은 초기에는 두 가치관 사이에서 방황하며 삶의 의미를 찾지 못하는 '허무주의자'였으나, 할아버지의 죽음을 계기로 현실에 적극적으로 맞서 싸우려는 '실존주의적 행동주의자'로 성장한다. 이러한 3대의 삶의 방식을 통해 작가는 한국 근현대사의 비극 속에서 각 세대가 어떻게 대응하며 살아왔는지 보여주고, 궁극적으로는 허무주의를 극복하고 현실에 참여하는 주체적인 삶의 가치를 강조하고자 했다.",
                correctParts: [
                    "할아버지는 현실에 순응하며 목숨을 보전하는 생존주의적 순응주의자이다.",
                    "아버지는 3·1 운동에 참여하여 목숨을 바친 민족주의적 행동주의자이다.",
                    "현은 초기에는 허무주의자였으나 할아버지의 죽음을 계기로 실존주의적 행동주의자로 성장한다.",
                    "이러한 설정을 통해 작가는 허무주의를 극복하고 현실에 참여하는 주체적인 삶의 가치를 강조하고자 했다."
                ],
                distractors: [
                    "세 인물 모두 동일한 가치관을 가지고 있다고 설명한다.",
                    "할아버지와 아버지의 삶이 현에게 부정적인 영향을 미쳤다고 본다.",
                    "작가가 세대 간의 갈등만을 강조하려고 했다고 해석한다."
                ]
            },
            {
                id: 2,
                question: "'현'은 소설 초반에 허무주의적이고 현실 도피적인 인물로 그려진다. 그가 이러한 성격을 갖게 된 배경을 그의 '가족사'와 연관 지어 구체적으로 서술하시오.",
                correctAnswer: "현의 아버지는 3·1 운동이라는 역사적 현실에 적극적으로 저항하다 허무하게 죽음을 맞이했다. 이로 인해 할아버지는 아들의 죽음에 대한 트라우마를 갖게 되었고, 손자 현에게는 \"모난 돌이 정 맞는다\"며 현실에 순응하고 목숨만 보전하는 소극적인 삶을 살라고 강요했다. 이처럼 저항의 무의미한 결과(아버지의 죽음)를 목격하고, 생존만을 강조하는 교육(할아버지의 가르침)을 받으며 자랐기 때문에 현은 역사나 사회 현실에 무관심하고 삶의 의미를 찾지 못하는 허무주의적인 인물이 되었다.",
                correctParts: [
                    "아버지는 3·1 운동에 저항하다 허무하게 죽음을 맞이했다.",
                    "할아버지는 아들의 죽음에 대한 트라우마를 갖게 되었다.",
                    "할아버지는 현에게 현실에 순응하고 목숨만 보전하라고 강요했다.",
                    "이러한 가족사로 인해 현은 허무주의적인 인물이 되었다."
                ],
                distractors: [
                    "현의 성격은 가족사와 무관하게 타고난 것이라고 본다.",
                    "할아버지가 현에게 저항하는 삶을 살라고 가르쳤다고 설명한다.",
                    "아버지의 죽음이 현에게 긍정적인 영향을 미쳤다고 해석한다."
                ]
            },
            {
                id: 3,
                question: "이 소설에서 '동굴'은 '현'과 그의 아버지에게 모두 중요한 의미를 지니는 공간이다. 아버지에게 '동굴'은 어떤 공간이었으며, '현'에게는 어떤 공간으로 기능하는지 비교하여 서술하시오.",
                correctAnswer: "아버지에게 '동굴'은 일제에 저항하다 마지막을 맞이한 '순국(殉國)의 공간'이자 저항 정신이 깃든 역사적 공간이다. 반면, 아들인 현에게 '동굴'은 처음에는 인민재판이라는 폭력적인 현실을 피해 숨어든 '현실 도피와 안주(安住)의 공간'으로 기능한다. 하지만 할아버지의 죽음을 겪은 후, 현이 새로운 결단을 내리고 뛰쳐나오는 공간이 되면서, 최종적으로는 과거의 소극적인 자아와 결별하고 새로운 삶을 시작하는 '재탄생과 출발의 공간'으로 의미가 전환된다.",
                correctParts: [
                    "아버지에게 동굴은 일제에 저항하다 죽음을 맞이한 순국의 공간이다.",
                    "현에게 동굴은 처음에는 현실 도피와 안주의 공간으로 기능한다.",
                    "할아버지의 죽음 후 현이 새로운 결단을 내리고 뛰쳐나오는 공간이 된다.",
                    "최종적으로는 과거의 소극적인 자아와 결별하고 새로운 삶을 시작하는 재탄생의 공간으로 의미가 전환된다."
                ],
                distractors: [
                    "아버지와 현에게 동굴의 의미가 동일하다고 설명한다.",
                    "동굴은 단순히 숨는 공간일 뿐이라고 본다.",
                    "현에게 동굴은 처음부터 재탄생의 공간이었다고 해석한다."
                ]
            },
            {
                id: 4,
                question: "평생을 순응주의자로 살아온 할아버지는 죽음의 순간에 \"너만이라도 살아내야 한다!\"라고 외치며 태도의 변화를 보인다. 이 마지막 외침이 '현'에게 어떤 의미를 주었으며, 그의 삶에 어떤 영향을 미쳤는지 서술하시오.",
                correctAnswer: "할아버지의 마지막 외침은 단순히 목숨을 보전하라는 이전의 가르침을 넘어, 어떤 상황에서도 굴하지 말고 꿋꿋하게 살아남으라는 강력한 명령이자 유언이었다. 평생 순응하며 살아온 할아버지의 삶의 방식이 죽음 앞에서 극적으로 전환되는 모습을 통해, 현은 생명의 존엄성과 가치를 깨닫게 된다. 이 외침은 현에게 '무서운 채찍'처럼 느껴져, 더 이상 비겁하게 숨어 지내지 않고 현실에 맞서 싸워야 한다는 결단을 내리게 하는 결정적인 계기가 된다.",
                correctParts: [
                    "할아버지의 외침은 단순한 생존이 아닌 치열한 삶에 대한 명령이었다.",
                    "평생 순응하던 할아버지의 삶의 방식이 죽음 앞에서 극적으로 전환되었다.",
                    "현은 생명의 존엄성과 가치를 깨닫게 되었다.",
                    "이 외침은 현의 가치관 변화에 결정적인 계기가 되었다."
                ],
                distractors: [
                    "할아버지의 외침은 여전히 순응을 권하는 것이었다고 본다.",
                    "현에게 별다른 영향을 미치지 않았다고 설명한다.",
                    "할아버지의 태도 변화가 일시적인 것이라고 해석한다."
                ]
            },
            {
                id: 5,
                question: "'현'은 인민재판을 목격한 이후 처음으로 분노를 느끼고 행동에 나선다. 그가 이전까지 현실을 외면하다가 이 사건을 계기로 변화하게 된 이유는 무엇인지, 당시의 폭력적인 상황과 관련지어 서술하시오.",
                correctAnswer: "이전까지 현이 겪은 현실의 부조리는 간접적이거나 개인적인 차원의 문제였다. 하지만 인민재판은 이념이라는 명분 아래 한 인간의 생명이 공개적으로 무참히 파괴되는 비인간적인 폭력의 현장이었다. 자신의 눈앞에서 벌어지는 극단적인 폭력과 죽음을 목격하면서, 현은 더 이상 현실을 방관하거나 도피할 수 없다는 것을 깨닫고 그동안 억눌러왔던 인간성에 대한 근원적인 분노를 터뜨리며 행동에 나서게 된 것이다.",
                correctParts: [
                    "이전까지 현이 겪은 현실의 부조리는 간접적이거나 개인적인 차원의 문제였다.",
                    "인민재판은 이념이라는 명분 아래 인간의 생명이 공개적으로 파괴되는 비인간적인 폭력의 현장이었다.",
                    "자신의 눈앞에서 벌어지는 극단적인 폭력과 죽음을 목격했다.",
                    "현은 더 이상 현실을 방관하거나 도피할 수 없다는 것을 깨닫고 근원적인 분노를 터뜨리며 행동에 나섰다."
                ],
                distractors: [
                    "인민재판은 현에게 별다른 충격을 주지 않았다고 본다.",
                    "현이 변화한 이유는 개인적인 감정 때문이라고 설명한다.",
                    "인민재판의 폭력성이 과장되었다고 해석한다."
                ]
            }
        ];

        // 5단계 초기화
        function initStage5() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '선우휘 <불꽃>';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
            console.log('=== showFinalResults 함수 호출됨 ===');

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            console.log('전체 결과 계산:', { totalCorrect, totalWrong });
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const totalAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);

            // 전체 문제 수 계산 (실제 문제 배열 기반)
            const stage2Questions = vocabularyData.length * 2;  // 단어당 2문제
            const stage3Questions = sentenceData.length;
            const totalAllQuestions = learningData.questions.length + stage2Questions + stage3Questions + oxQuizData.length + writingQuestions.length;
            const answeredQuestions = totalCorrect + totalWrong;
            const progress = totalAllQuestions > 0
                ? Math.round((answeredQuestions / totalAllQuestions) * 100)
                : 100;

            // 각 스테이지에 totalQuestions 추가
            const stagesDetailWithTotal = {
                stage1: {
                    ...stageResults.stage1,
                    totalQuestions: learningData.questions.length
                },
                stage2: {
                    ...stageResults.stage2,
                    totalQuestions: stage2Questions
                },
                stage3: {
                    ...stageResults.stage3,
                    totalQuestions: stage3Questions
                },
                stage4: {
                    ...stageResults.stage4,
                    totalQuestions: oxQuizData.length
                },
                stage5: {
                    ...stageResults.stage5,
                    totalQuestions: writingQuestions.length
                }
            };

            console.log('=== sendFinalDataToParent 호출됨 ===');
            console.log('전체 문제 수:', totalAllQuestions, '/ 푼 문제 수:', answeredQuestions, '/ 진행률:', progress + '%');
            console.log('window.parent 존재:', !!window.parent);
            console.log('window.parent !== window:', window.parent !== window);

            if (window.parent && window.parent !== window) {
                const messageData = {
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stagesDetailWithTotal,
                        totalQuestions: totalAllQuestions,
                        answeredQuestions: answeredQuestions,
                        correctAnswers: totalCorrect,
                        wrongAnswers: totalWrong,
                        progress: progress,
                        timestamp: Date.now()
                    }
                };

                console.log('부모로 전송할 데이터:', messageData);
                window.parent.postMessage(messageData, '*');
                console.log('postMessage 전송 완료');
            } else {
                console.log('부모 윈도우가 없거나 같은 윈도우입니다. 데이터를 전송하지 않습니다.');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `불꽃_워크북_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
