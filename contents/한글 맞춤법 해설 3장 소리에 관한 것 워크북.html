<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>한글 맞춤법 해설 (심화편) - 제3장 소리에 관한 것</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        .passage-container table th,
        .passage-container table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }

        .passage-container table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        /* Highlight Style */
        .highlight {
            background: linear-gradient(120deg, #ffeaa7 0%, #fdcb6e 100%);
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline;
            position: relative;
        }

        .highlight:hover {
            background: linear-gradient(120deg, #fdcb6e 0%, #fab1a0 100%);
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(253, 203, 110, 0.5);
        }

        .highlight.answered {
            background: linear-gradient(120deg, #dfe6e9 0%, #b2bec3 100%);
            cursor: default;
        }

        .highlight.answered:hover {
            transform: none;
            box-shadow: none;
        }

        .highlight.correct {
            background: linear-gradient(120deg, #55efc4 0%, #00b894 100%);
        }

        .highlight.incorrect {
            background: linear-gradient(120deg, #fab1a0 0%, #ff7675 100%);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            position: fixed;
            cursor: move;
            transition: opacity 0.3s ease;
        }

        .modal-content.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-content.correct-feedback {
            border: 3px solid #00b894;
            animation: correctPulse 0.6s ease;
        }

        .modal-content.incorrect-feedback {
            border: 3px solid #ff7675;
            animation: incorrectShake 0.5s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(0, 184, 148, 0.6); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option-button {
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-family: 'Noto Serif KR', serif;
        }

        .option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
            animation: correctPulse 0.6s ease;
        }

        .option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* OX Learning Styles (Stage 2) */
        .ox-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .ox-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .ox-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .ox-option-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 30px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 32px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ox-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: scale(1.05);
        }

        .ox-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .ox-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
            animation: correctPulse 0.6s ease;
        }

        .ox-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: incorrectShake 0.5s ease;
        }

        /* Multiple Choice Styles (Stage 3) */
        .mcq-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .mcq-question-card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .mcq-question-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .mcq-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mcq-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .mcq-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .mcq-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .mcq-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .mcq-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .mcq-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .mcq-option-button.correct .option-number {
            background: #27ae60;
        }

        .mcq-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .mcq-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Feedback Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Wrong Questions Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: fixed;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .modal-header h3 {
            font-size: 24px;
            color: #2c3e50;
            margin: 0;
        }

        .close-modal-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-modal-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        .modal-body {
            padding: 10px 0;
        }

        .wrong-question-item {
            background: #f8f9fa;
            border-left: 4px solid #dc3545;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }

        .wrong-question-item h4 {
            color: #dc3545;
            margin-bottom: 12px;
            font-size: 18px;
        }

        .wrong-question-item p {
            margin: 8px 0;
            line-height: 1.6;
        }

        .wrong-question-item .question-text {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .wrong-question-item .user-answer {
            color: #dc3545;
            background: #fff5f5;
            padding: 8px 12px;
            border-radius: 5px;
            display: inline-block;
            margin: 5px 0;
        }

        .wrong-question-item .correct-answer {
            color: #28a745;
            background: #f0fff4;
            padding: 8px 12px;
            border-radius: 5px;
            display: inline-block;
            margin: 5px 0;
        }

        .explanation-text {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 16px;
            color: #856404;
            text-align: center;
            line-height: 1.6;
        }

        .question-explanation {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            color: #856404;
            margin-top: 10px;
        }

        .question-explanation strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                font-size: 14px;
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }

            .modal-content {
                padding: 20px;
                max-width: 90%;
            }

            .option-button {
                padding: 12px 15px;
                font-size: 14px;
            }

            .ox-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .ox-option-button {
                padding: 20px 15px;
                font-size: 24px;
            }

            .mcq-question-card {
                padding: 20px;
            }

            .mcq-question-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .mcq-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .mcq-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">한글 맞춤법 해설 (심화편)</div>
                <div class="subtitle" id="stage-subtitle">1단계: 딥리서치</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Modal -->
        <div class="modal-overlay" id="modal-overlay">
            <div class="modal-content" id="modal-content">
                <div class="modal-header" id="modal-header"></div>
                <div class="modal-options" id="modal-options"></div>
            </div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title" id="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>
    </div>

    <script>
        // 모달 드래그 관련 변수
        let isDragging = false;
        let dragStartX, dragStartY;
        let modalStartX, modalStartY;
        let dragListenersAdded = false;

        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소 (레거시)
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null
        };

        // 새로운 stageResults 객체 (틀린 문제 포함)
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // Stage 2와 Stage 3의 wrongQuestions 추적용 배열
        let stage2WrongQuestions = [];
        let stage3WrongQuestions = [];

        // 전역 시작 시간
        let globalStartTime = Date.now();

        // Stage 1: 딥리서치 - 2-choice 질문 데이터
        // ============================================
        // Stage 1: 딥리서치 - 2지선다 하이라이트 문제
        // ============================================
        // 설명: 학습 콘텐츠 내에 하이라이트로 표시된 빈칸 문제
        // 형식: { id: 번호, context: "문맥", correctAnswer: "정답", wrongAnswer: "오답" }
        // - id: 문제 고유 번호
        // - context: 하이라이트가 나타날 문맥 (이 텍스트 다음에 하이라이트가 표시됨)
        // - correctAnswer: 정답 텍스트
        // - wrongAnswer: 오답 텍스트

        const STAGE1_QUESTIONS = [
  {
    id: 1,
    context: "이 조항에서 '한 단어'는 ___을 의미하는 것으로 풀이할 수 있다.",
    correctAnswer: "'한 형태소로 이루어진 단어'",
    wrongAnswer: "둘 이상의 형태소가 결합한 복합어"
  },
  {
    id: 2,
    context: "실제로 이 규정의 적용을 받는 '어깨'나 '산뜻' 등은 모두 ___이다.",
    correctAnswer: "하나의 형태소로 이루어진 단어",
    wrongAnswer: "둘 이상의 형태소가 결합한 복합어"
  },
  {
    id: 3,
    context: "따라서 복합어인 '눈곱[눈꼽], 발바닥[발빠닥], 잠자리[잠짜리]'와 같은 단어의 된소리 현상은 이 조항의 적용을 ___.",
    correctAnswer: "받지 않는다",
    wrongAnswer: "받는다"
  },
  {
    id: 4,
    context: "한 형태소 안의 두 모음 사이에서 나는 된소리는 ___.",
    correctAnswer: "소리 나는 대로 적는다",
    wrongAnswer: "원형을 밝혀 적는다"
  },
  {
    id: 5,
    context: "예를 들어 새의 울음을 나타내는 형태소 '소쩍'을 '솟적'으로 적을 이유가 없는 것은 ___ 형태를 분석하여 표기할 근거가 없기 때문이다.",
    correctAnswer: "'솟'과 '적'이 각각 의미 있는 형태소가 아니므로",
    wrongAnswer: "'솟적적' 전체가 하나의 형태소이므로"
  },
  {
    id: 6,
    context: "어깨 → ___",
    correctAnswer: "어깨",
    wrongAnswer: "엇개"
  },
  {
    id: 7,
    context: "오빠 → ___",
    correctAnswer: "오빠",
    wrongAnswer: "옵바"
  },
  {
    id: 8,
    context: "새끼 → ___",
    correctAnswer: "새끼",
    wrongAnswer: "샛기"
  },
  {
    id: 9,
    context: "토끼 → ___",
    correctAnswer: "토끼",
    wrongAnswer: "톳기"
  },
  {
    id: 10,
    context: "가꾸다 → ___",
    correctAnswer: "가꾸다",
    wrongAnswer: "갓구다"
  },
  {
    id: 11,
    context: "기쁘다 → ___",
    correctAnswer: "기쁘다",
    wrongAnswer: "깃브다"
  },
  {
    id: 12,
    context: "이와 마찬가지로 위의 단어들을 '엇개, 옵바, 샛기' 등으로 적을 근거가 없는 이유는 ___ 소리 나는 대로 적기 때문이다.",
    correctAnswer: "이 단어들이 각각 하나의 형태소이므로",
    wrongAnswer: "두 개의 형태소가 결합한 것이므로"
  },
  {
    id: 13,
    context: "또한 한 형태소에서 'ㄴ, ㄹ, ㅁ, ㅇ' 받침 뒤에서 나는 된소리도 ___ 적는다.",
    correctAnswer: "소리 나는 대로",
    wrongAnswer: "원형을 밝혀"
  },
  {
    id: 14,
    context: "받침 'ㄴ, ㄹ, ㅁ, ㅇ'은 뒤에 오는 예사소리를 된소리로 바꾸어 주는 ___.",
    correctAnswer: "필연적인 조건이 아니다",
    wrongAnswer: "필연적인 조건이다"
  },
  {
    id: 15,
    context: "위 단어들은 된소리로 발음되는데, 해당 받침들은 된소리를 만드는 ___.",
    correctAnswer: "필연적인 환경이 아니다",
    wrongAnswer: "필연적인 환경이다"
  },
  {
    id: 16,
    context: "따라서 'ㄴ, ㄹ, ㅁ, ㅇ' 뒤에 오는 된소리는 특별한 까닭이 없다고 보아 ___.",
    correctAnswer: "소리 나는 대로 적는다",
    wrongAnswer: "원형을 밝혀 적는다"
  },
  {
    id: 17,
    context: "산뜻(하다) → ___",
    correctAnswer: "산뜻",
    wrongAnswer: "산듯"
  },
  {
    id: 18,
    context: "살짝 → ___",
    correctAnswer: "살짝",
    wrongAnswer: "살작"
  },
  {
    id: 19,
    context: "듬뿍 → ___",
    correctAnswer: "듬뿍",
    wrongAnswer: "듬북"
  },
  {
    id: 20,
    context: "뭉뚱(그리다) → ___",
    correctAnswer: "뭉뚱",
    wrongAnswer: "뭉둥"
  },
  {
    id: 21,
    context: "그렇지만 'ㄱ, ㅂ' 받침 뒤에 연결되는 'ㄱ, ㄷ, ㅂ, ㅅ, ㅈ'은 ___ 된소리로 소리 나므로, 이러한 경우에는 된소리로 표기하지 ___.",
    correctAnswer: "언제나",
    wrongAnswer: "때때로"
  },
  {
    id: 22,
    context: "그렇지만 'ㄱ, ㅂ' 받침 뒤에 연결되는 'ㄱ, ㄷ, ㅂ, ㅅ, ㅈ'은 언제나 된소리로 소리 나므로, 이러한 경우에는 된소리로 표기하지 ___.",
    correctAnswer: "않고 원형을 밝혀 적적는다",
    wrongAnswer: "않고 소리대로 적는다"
  },
  {
    id: 23,
    context: "늑대 → 발음: [늑때], 표기: ___",
    correctAnswer: "늑대",
    wrongAnswer: "늑때"
  },
  {
    id: 24,
    context: "낙지 → 발음: [낙찌], 표기: ___",
    correctAnswer: "낙지",
    wrongAnswer: "낙찌"
  },
  {
    id: 25,
    context: "접시 → 발음: [접씨], 표기: ___",
    correctAnswer: "접시",
    wrongAnswer: "접씨"
  },
  {
    id: 26,
    context: "갑자기 → 발음: [갑짜기], 표기: ___",
    correctAnswer: "갑자기",
    wrongAnswer: "갑짜기"
  },
  {
    id: 27,
    context: "'ㄱ, ㅂ' 받침 외에 '믿고[믿꼬], 잊지[읻찌]'와 '낯설다[낟썰다]'처럼 앞말의 받침이 [ㄷ]으로 발음될 때 뒷말의 첫소리가 된소리로 나는 예들도 있다. 이러한 말 역시 된소리를 ___",
    correctAnswer: "표기에 반영하지 않는데",
    wrongAnswer: "표기에 반영하는데"
  },
  {
    id: 28,
    context: "이들은 ___, '눈곱, 발바닥' 등과 마찬가지로 된소리를 표기에 반영하지 않는 것이다.",
    correctAnswer: "'어간+어미'나 '어근+어근'처럼 두 형태소가 결합한 말이므로",
    wrongAnswer: "하나의 형태소 내부 현상이므로"
  },
  {
    id: 29,
    context: "그렇지만 '똑똑하다, 쓱싹쓱싹, 쌉쌀하다'의 '똑똑, 쓱싹, 쌉쌀'처럼 ___에는 예외적으로 된소리를 표기에 반영하여 같은 글자로 적는다.",
    correctAnswer: "같거나 비슷한 음절이 거듭되는 경우",
    wrongAnswer: "전혀 다른 음절이 오는 경우"
  },
  {
    id: 30,
    context: "'형태소'는 ___ 가장 작은 단위를 말한다.",
    correctAnswer: "뜻을 가지고 있는",
    wrongAnswer: "뜻을 구별해 주는"
  },
  {
    id: 31,
    context: "국어에서 'ㅂ'이나 'ㅣ' 등은 뜻을 가지고 있지 않기 때문에 형태소가 될 수 없지만, '비'가 되면 ___인 형태소가 된다.",
    correctAnswer: "의미의 최소 단위",
    wrongAnswer: "소리의 최소 단위"
  },
  {
    id: 32,
    context: "'책가방'은 '책'과 '가방'이라는 두 가지 의미로 쪼개지기 때문에 형태소는 ___이다.",
    correctAnswer: "'책가방'이 아니라 '책'과 '가방'",
    wrongAnswer: "'책가방' 자체"
  },
  {
    id: 33,
    context: "더 작은 단위로 쪼갠다고 해도 쪼갰을 때 의미가 없어지면 더 이상 나눌 수 ___.",
    correctAnswer: "없다",
    wrongAnswer: "있다"
  },
  {
    id: 34,
    context: "'나비'는 '나'와 '비'로 쪼개어지지만 이때 '나'와 '비'는 '나비'의 의미와는 전혀 관계가 없으므로, '나비'는 ___.",
    correctAnswer: "하나의 형태소로 분석된다",
    wrongAnswer: "두 개의 형태소로 분석된다"
  },
  {
    id: 35,
    context: "단어의 첫머리 이외의 경우에는 ___.",
    correctAnswer: "본음대로 적는다",
    wrongAnswer: "두음 법칙을 적용한다"
  },
  {
    id: 36,
    context: "접두사처럼 쓰이는 한자가 붙어서 된 말이나 합성어에서, 뒷말의 첫소리가 'ㄴ' 소리로 나더라도 ___.",
    correctAnswer: "두음 법칙에 따라 적는다",
    wrongAnswer: "본음대로 적는다"
  },
  {
    id: 37,
    context: "둘 이상의 단어로 이루어진 고유 명사를 붙여 쓰는 경우에도 ___.",
    correctAnswer: "[붙임 2]에 준하여 적는다",
    wrongAnswer: "본음대로 적는다"
  },
  {
    id: 38,
    context: "제10항~제12항에서는 국어의 두음 법칙을 규정하였다. 두음 법칙은 단어의 ___에 특정한 소리가 출현하지 못하는 현상을 말한다.",
    correctAnswer: "첫머리",
    wrongAnswer: "끝소리"
  },
  {
    id: 39,
    context: "연도(年度) → ___",
    correctAnswer: "연도",
    wrongAnswer: "년도"
  },
  {
    id: 40,
    context: "열반(涅槃) → ___",
    correctAnswer: "열반",
    wrongAnswer: "녈반"
  },
  {
    id: 41,
    context: "요도(尿道) → ___",
    correctAnswer: "요도",
    wrongAnswer: "뇨도"
  },
  {
    id: 42,
    context: "그런데 여기에는 예외가 있다. 한자어 음절이 '녀, 뇨, 뉴, 니'를 포함하고 있더라도 의존 명사에는 두음 법칙이 ___.",
    correctAnswer: "적용되지 않는다",
    wrongAnswer: "똑같이 적용된다"
  },
  {
    id: 43,
    context: "이는 의존 명사는 독립적으로 쓰이기보다는 그 앞의 말과 연결되어 ___ 때문이다.",
    correctAnswer: "하나의 단위를 구성하기",
    wrongAnswer: "별개의 단위를 구성하기"
  },
  {
    id: 44,
    context: "이러한 이유로 이 말들은 독립된 단어로 잘 인식되지 않아, 단어의 첫머리처럼 ___.",
    correctAnswer: "취급되지 않는다",
    wrongAnswer: "취급된다"
  },
  {
    id: 45,
    context: "그 결과 단어 첫머리임에도 두음 법칙이 적용되지 않고 ___ 적는다.",
    correctAnswer: "본음대로",
    wrongAnswer: "바뀐 음대로"
  },
  {
    id: 46,
    context: "십 년 → ___",
    correctAnswer: "십 년",
    wrongAnswer: "십 연"
  },
  {
    id: 47,
    context: "금 한 냥 → ___",
    correctAnswer: "금 한 냥",
    wrongAnswer: "금 한 양"
  },
  {
    id: 48,
    context: "은 두 냥쭝 → ___",
    correctAnswer: "은 두 냥쭝",
    wrongAnswer: "은 두 양쭝"
  },
  {
    id: 49,
    context: "따라서 '年', '年度'처럼 의존 명사로 쓰이기도 하고 자립 명사로 쓰이기도 하는 한자어의 경우에는 두음 법칙의 적용에서 차이가 ___.",
    correctAnswer: "난다",
    wrongAnswer: "없다"
  },
  {
    id: 50,
    context: "'년, 년도'가 의존 명사라면 '연, 연도'는 ___이다.",
    correctAnswer: "자립 명사",
    wrongAnswer: "의존 명사"
  },
  {
    id: 51,
    context: "연 강수량 ___",
    correctAnswer: "자립 명사",
    wrongAnswer: "의존 명사"
  },
  {
    id: 52,
    context: "일 년 ___",
    correctAnswer: "의존 명사",
    wrongAnswer: "자립 명사"
  },
  {
    id: 53,
    context: "생산 연도 ___",
    correctAnswer: "자립 명사",
    wrongAnswer: "의존 명사"
  },
  {
    id: 54,
    context: "2018년도 ___",
    correctAnswer: "의존 명사",
    wrongAnswer: "자립 명사"
  },
  {
    id: 55,
    context: "단어의 ___에는 두음 법칙이 적용되지 않으므로 본음대로 적는 것이다.",
    correctAnswer: "첫머리가 아닌 경우",
    wrongAnswer: "첫머리인 경우"
  },
  {
    id: 56,
    context: "소녀(少女) → ___",
    correctAnswer: "소녀",
    wrongAnswer: "소여"
  },
  {
    id: 57,
    context: "만년(晩年) → ___",
    correctAnswer: "만년",
    wrongAnswer: "만연"
  },
  {
    id: 58,
    context: "탐닉(耽溺) → ___",
    correctAnswer: "탐닉",
    wrongAnswer: "탐익"
  },
  {
    id: 59,
    context: "'신-여성, 공-염불'은 ___ '신여성, 공염불'로 적는다.",
    correctAnswer: "이미 두음 법칙이 적용된 자립적인 명사에 '신-', '공-'이 결합한 구조이므로",
    wrongAnswer: "하나의 단어 내부에서 음운이 변한 것이므로"
  },
  {
    id: 60,
    context: "둘 이상의 단어로 이루어진 고유 명사를 붙여 쓰는 경우에도, 결합된 각 단어를 ___.",
    correctAnswer: "두음 법칙에 따라 적는다",
    wrongAnswer: "본음대로 적는다"
  }
];

        // ============================================
        // Stage 2: OX 퀴즈
        // ============================================
        // 설명: O/X로 답하는 퀴즈 형식
        // 형식: { id: 번호, text: "문제 내용", answer: "O" 또는 "X", explanation: "해설" }
        // - id: 문제 고유 번호
        // - text: 문제 텍스트 (마크다운 문법 지원: **볼드**, <u>밑줄</u> 등)
        // - answer: 정답 ("O" 또는 "X")
        // - explanation: 정오답 해설 (마크다운 문법 지원)

        const STAGE2_QUESTIONS = [
{
    id: 1,
    text: "제5항에서 말하는 '한 단어'는 '한 형태소로 이루어진 단어'로 해석할 수 있다.",
    answer: "O",
    explanation: "맞습니다. 제5항의 된소리 규정은 '어깨', '산뜻'처럼 더 이상 쪼갤 수 없는 하나의 형태소 안에서 일어나는 현상을 다루기 때문에, '한 단어'는 '한 형태소'로 이해해야 합니다."
  },
  {
    id: 2,
    text: "'어깨'는 두 모음 사이에서 뚜렷한 까닭 없이 된소리가 나므로 '어깨'로 적는다.",
    answer: "O",
    explanation: "맞습니다. '어깨'는 하나의 형태소 안에서, 된소리가 될 필연적 조건이 없는 '두 모음 사이'임에도 된소리로 발음됩니다. 이처럼 뚜렷한 까닭이 없으므로 소리 나는 대로 '어깨'로 적습니다."
  },
  {
    id: 3,
    text: "'ㄴ, ㄹ, ㅁ, ㅇ' 받침 뒤에서 나는 된소리는 특별한 이유가 없으므로 소리 나는 대로 표기한다.",
    answer: "O",
    explanation: "맞습니다. 해당 받침들은 뒤에 오는 예사소리를 필연적으로 된소리로 바꾸는 환경이 아니므로, 된소리로 소리 나는 경우 그 소리를 그대로 표기에 반영합니다."
  },
  {
    id: 4,
    text: "'ㄱ, ㅂ' 받침 뒤의 된소리는 발음이 필연적이므로 표기에 된소리로 반영하지 않는다.",
    answer: "O",
    explanation: "맞습니다. '국수[국쑤]'처럼 발음이 필연적으로 된소리가 되는 환경이므로, 효율성을 위해 굳이 표기에 된소리로 반영하지 않고 예사소리로 적습니다."
  },
  {
    id: 5,
    text: "'딱지'의 표기는 'ㄱ' 받침 뒤 된소리를 표기에 반영하지 않는 원칙을 따른 것이다.",
    answer: "O",
    explanation: "맞습니다. 발음은 [딱찌]로 나지만, 'ㄱ' 받침 뒤라는 필연적 환경이므로 규정에 따라 된소리로 적지 않습니다."
  },
  {
    id: 6,
    text: "'똑똑하다'처럼 비슷한 음절이 거듭되는 경우는 예외적으로 된소리를 표기에 반영한다.",
    answer: "O",
    explanation: "맞습니다. 제5항의 '다만' 조항에 따라 'ㄱ, ㅂ' 받침 뒤라도 '똑똑', '쌉쌀하다'처럼 같은 음절이나 비슷한 음절이 겹쳐 나는 경우는 된소리로 적습니다."
  },
  {
    id: 7,
    text: "복합어 '눈곱'은 [눈꼽]으로 소리 나지만, 제5항의 적용을 받지 않아 '눈곱'으로 적는다.",
    answer: "O",
    explanation: "맞습니다. 제5항은 '한 형태소' 내부에 관한 규정이므로, '눈'과 '곱'이라는 두 형태소가 결합한 복합어의 된소리 현상(사잇소리 현상)은 이 조항으로 설명하지 않습니다."
  },
  {
    id: 8,
    text: "'형태소'는 뜻을 가진 가장 작은 말의 단위이다.",
    answer: "O",
    explanation: "맞습니다. '더 알아보기'에서 설명된 바와 같이, 더 이상 쪼개면 뜻을 잃게 되는 의미의 최소 단위가 형태소입니다."
  },
  {
    id: 9,
    text: "'나비'를 '나'와 '비'로 쪼갤 수 없는 이유는 쪼갠 후의 의미가 원래 의미와 관련이 없기 때문이다.",
    answer: "O",
    explanation: "맞습니다. '나'와 '비'는 각각의 뜻이 있지만, 곤충 '나비'와는 의미적 관련성이 없으므로, '나비' 자체가 하나의 형태소입니다."
  },
  {
    id: 10,
    text: "두음 법칙은 단어의 첫머리에 특정 소리가 오는 것을 꺼리는 현상이다.",
    answer: "O",
    explanation: "맞습니다. 특히 한자어에서 'ㄴ'이나 'ㄹ'이 단어의 첫소리로 오는 것을 피하는 음운 규칙입니다."
  },
  {
    id: 11,
    text: "한자음 '女子'는 두음 법칙에 따라 '여자'로 적는다.",
    answer: "O",
    explanation: "맞습니다. 단어 첫머리에 오는 한자음 '녀'는 '여'로 적는다는 제10항의 대표적인 예시입니다."
  },
  {
    id: 12,
    text: "'남녀(男女)'처럼 단어의 첫머리가 아닌 경우에는 본음대로 '녀'로 적는다.",
    answer: "O",
    explanation: "맞습니다. 두음 법칙은 단어의 첫머리에만 적용되므로, 둘째 음절 이하에서는 본음 '녀'를 그대로 씁니다."
  },
  {
    id: 13,
    text: "'신여성'은 '신-'과 두음 법칙이 적용된 '여성'이 결합한 말이므로 '신여성'으로 적는다.",
    answer: "O",
    explanation: "맞습니다. 이미 독립적인 단어로 쓰이는 '여성'에 접두사처럼 쓰이는 한자 '신(新)'이 붙었으므로, '여성'의 형태를 그대로 유지합니다."
  },
  {
    id: 14,
    text: "고유 명사 '한국여자대학'은 각 단어에 두음 법칙을 적용하여 붙여 쓴다.",
    answer: "O",
    explanation: "맞습니다. '한국', '여자', '대학' 각각을 독립된 단어로 보고 두음 법칙을 적용한 형태를 결합하여 표기합니다."
  },
  {
    id: 15,
    text: "'몇 년'의 '년(年)'은 자립적으로 쓰일 수 없는 의존 명사이므로 두음 법칙의 적용을 받지 않는다.",
    answer: "O",
    explanation: "맞습니다. 의존 명사는 앞말에 기대어 쓰이므로 단어의 첫머리로 보지 않아 두음 법칙의 예외가 되어 본음대로 '년'으로 적습니다."
  },
  {
    id: 16,
    text: "'연도(年度)'는 자립 명사로 쓰일 때와 의존 명사로 쓰일 때 두음 법칙 적용 여부가 다르다.",
    answer: "O",
    explanation: "맞습니다. 단독으로 쓰이는 자립 명사일 때는 '연도', 해를 뜻하는 말 뒤에 쓰이는 의존 명사일 때는 '년도'로 표기가 다릅니다."
  },
  {
    id: 17,
    text: "한자음 '良心'은 두음 법칙에 따라 '양심'으로 적는다.",
    answer: "O",
    explanation: "맞습니다. 제11항에 따라 단어 첫머리의 한자음 '랴'는 '야'로 적습니다."
  },
  {
    id: 18,
    text: "모음이나 'ㄴ' 받침 뒤에 오는 '렬, 률'은 '열, 율'로 적는다.",
    answer: "O",
    explanation: "맞습니다. 제11항 [붙임 1]의 '다만' 조항에 따른 규칙으로, '나열', '비율' 등이 이에 해당합니다."
  },
  {
    id: 19,
    text: "외자로 된 이름 '申砬'은 본음대로 '신립'으로 적을 수 있다.",
    answer: "O",
    explanation: "맞습니다. 제11항 [붙임 2]에 따라, 역사적 인물의 이름처럼 관용이 굳어진 경우 본음 표기를 허용합니다."
  },
  {
    id: 20,
    text: "한자음 '뢰(雷)'는 단어 첫머리에서 '뇌'로 적는다.",
    answer: "O",
    explanation: "맞습니다. 제12항에 따라 단어 첫머리의 '라/래/로/뢰/루/르'는 '나/내/노/뇌/누/느'로 적습니다. 예) 뇌우(雷雨), 뇌성(雷聲). 반대로 단어 첫머리가 아닌 경우에는 본음대로 '뢰'를 유지합니다(예: 지뢰, 낙뢰)."
  },
  {
    id: 21,
    text: "'한 단어 안'이란 복합어를 포함하는 개념이다.",
    answer: "X",
    explanation: "틀렸습니다. 본문 해설에 따르면 제5항의 '한 단어'는 '한 형태소'를 의미하므로 '눈-곱'과 같은 복합어는 포함되지 않습니다."
  },
  {
    id: 22,
    text: "두 모음 사이에서 된소리가 날 경우, 원형을 밝혀 예사소리로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. '어깨', '오빠'처럼 된소리가 나는 뚜렷한 까닭이 없는 경우에는 소리 나는 대로 된소리로 적습니다."
  },
  {
    id: 23,
    text: "'ㄱ, ㅂ' 받침 뒤의 된소리는 '똑똑'과 같은 경우에도 예사소리로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. '똑똑하다'처럼 같은 음절이나 비슷한 음절이 겹쳐 나는 경우는 예외적으로 된소리로 적습니다."
  },
  {
    id: 24,
    text: "'산뜻하다'는 'ㄴ' 받침이 된소리를 만드는 필연적 조건이기 때문에 된소리로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. 'ㄴ' 받침은 된소리를 만드는 필연적 조건이 아니며, 뚜렷한 까닭 없이 된소리가 나므로 소리 나는 대로 적는 것입니다."
  },
  {
    id: 25,
    text: "'책가방'은 '책'과 '가방'으로 쪼갤 수 있으므로 하나의 형태소이다.",
    answer: "X",
    explanation: "틀렸습니다. 뜻을 가진 가장 작은 단위로 쪼갠 '책'과 '가방'이 각각 형태소입니다. 따라서 '책가방'은 두 개의 형태소로 이루어진 단어입니다."
  },
  {
    id: 26,
    text: "'비'는 더 이상 쪼갤 수 없지만 뜻이 없으므로 형태소가 아니다.",
    answer: "X",
    explanation: "틀렸습니다. '비'는 '하늘에서 내리는 물방울'이라는 뜻을 가진 가장 작은 단위이므로 형태소입니다."
  },
  {
    id: 27,
    text: "두음 법칙은 단어의 끝소리에 특정 음운이 오지 못하는 현상이다.",
    answer: "X",
    explanation: "틀렸습니다. 두음 법칙은 단어의 '첫머리'(두음)에 관한 규칙입니다."
  },
  {
    id: 28,
    text: "한자음 '니'는 단어 첫머리에 올 때 의존 명사를 포함하여 모두 '이'로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. 의존 명사에서는 본음대로 적는 예외가 있습니다."
  },
  {
    id: 29,
    text: "'남녀(男女)'는 단어의 첫머리가 아니므로 두음 법칙을 적용하여 '남여'로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. 단어의 첫머리가 아니므로 두음 법칙을 적용하지 않고 본음대로 '남녀'로 적습니다."
  },
  {
    id: 30,
    text: "'공염불'은 [공념불]로 소리 나므로 '공념불'로 적어야 한다.",
    answer: "X",
    explanation: "틀렸습니다. 제10항 [붙임 2]에 따라, 뒷말인 '염불'에 이미 두음 법칙이 적용된 형태이므로 그대로 결합하여 '공염불'로 적습니다."
  },
  {
    id: 31,
    text: "의존 명사 '냥(兩)'은 자립성이 없으므로 두음 법칙에 따라 '양'으로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. 의존 명사는 독립성이 약하여 단어 첫머리로 인식되지 않으므로, 두음 법칙의 예외로서 본음대로 '냥'으로 적습니다."
  },
  {
    id: 32,
    text: "'2018년도'의 '년도'는 자립 명사이므로 두음 법칙을 적용해야 한다.",
    answer: "X",
    explanation: "틀렸습니다. 숫자 뒤에 오는 '년도'는 의존 명사이므로 두음 법칙을 적용하지 않고 본음대로 '년도'로 적습니다."
  },
  {
    id: 33,
    text: "'쾌락(快樂)'은 단어 첫머리에 '라'가 왔으므로 '쾌낙'으로 적어야 한다.",
    answer: "X",
    explanation: "틀렸습니다. '락'은 단어의 첫머리가 아닌 두 번째 음절에 있으므로 두음 법칙이 적용되지 않고 본음대로 적습니다."
  },
  {
    id: 34,
    text: "'실패율(失敗率)'은 'ㄴ' 받침 뒤가 아니므로 '실패률'로 적어야 한다.",
    answer: "X",
    explanation: "틀렸습니다. 제11항 [붙임 1]의 '다만' 조항에 따라, 앞말이 모음으로 끝날 경우 '률'이 아닌 '율'로 적습니다. '실패'는 모음 'ㅐ'로 끝나므로 '실패율'이 맞습니다."
  },
  {
    id: 35,
    text: "'백분률'이 맞는 표기이다.",
    answer: "X",
    explanation: "틀렸습니다. 앞말의 받침이 'ㄴ'이므로 '백분율'이 맞는 표기입니다."
  },
  {
    id: 36,
    text: "합성어 '해외여행'은 [해외려행]으로 소리 나므로 '해외려행'으로 적는다.",
    answer: "X",
    explanation: "틀렸습니다. 합성어의 뒷말인 '여행'은 이미 두음 법칙이 적용된 형태이므로 그대로 결합하여 '해외여행'으로 적습니다."
  },
  {
    id: 37,
    text: "고유어 뒤에 한자어가 결합할 때 두음 법칙은 적용되지 않는다.",
    answer: "X",
    explanation: "틀렸습니다. '구름-양(量)'처럼 고유어 뒤에 결합하는 한자어가 하나의 단어로 인식될 때는 두음 법칙이 적용됩니다."
  },
  {
    id: 38,
    text: "'육천육백육십육'에서 모든 '육'은 두음 법칙의 적용을 받는다.",
    answer: "O",
    explanation: "십진법에 따라 쓰는 수는 두음법칙에 따라 '륙'이 아니라 '육'으로 씁니다."
  },
  {
    id: 39,
    text: "'국제 연합'의 준말 '국련'은 두음 법칙을 따라 '국연'으로 적어야 한다.",
    answer: "X",
    explanation: "틀렸습니다. 준말에서 둘째 음절 이하의 '연'은 단어 첫머리로 보지 않으므로 본음 '련'을 살려 '국련'으로 적습니다."
  },
  {
    id: 40,
    text: "'고랭지(高冷地)'는 '고-냉지'로 분석되므로 '고냉지'로 적어야 한다.",
    answer: "X",
    explanation: "틀렸습니다. 본문에서 '고랭지'는 [고랭지]로 소리 나고, 의미 분석상으로도 '높고 찬 땅'이라는 뜻의 '고랭-지'로 분석되므로 '고랭지'로 적는다고 설명합니다."
  }
];

        // ============================================
        // Stage 3: 객관식 (Multiple Choice)
        // ============================================
        // 설명: 6개 선택지 중 4개를 무작위로 선택하여 출제하는 객관식 문제
        // 형식: { id: 번호, text: "문제", options: ["선택지1", ... "선택지6"], correct: 정답인덱스, explanation: "해설" }
        // - id: 문제 고유 번호
        // - text: 문제 텍스트 (마크다운 지원)
        // - options: 6개의 선택지 배열 (실제 출제 시 4개 무작위 선택)
        // - correct: 정답의 인덱스 (0부터 시작, 즉 0=①, 1=②, 2=③, 3=④, 4=⑤, 5=⑥)
        // - explanation: 정오답 해설 (마크다운 지원, <u>밑줄</u> 가능)

        const STAGE3_QUESTIONS = [
{
    id: 1,
    text: "한글 맞춤법 제5항에 따라 된소리로 적어야 하는 단어는?",
    options: [
      "국수",
      "산뜻",
      "깍두기",
      "법석",
      "딱지",
      "갑자기"
    ],
    correct: 1,
    explanation: "'산뜻'은 'ㄴ' 받침 뒤에서 뚜렷한 까닭 없이 나는 된소리이므로 제5항 본문에 따라 된소리로 적습니다. 나머지는 'ㄱ, ㅂ' 받침 뒤에서 필연적으로 나는 된소리이므로 '다만' 규정에 따라 예사소리로 적습니다."
  },
  {
    id: 2,
    text: "다음 중 제5항의 '다만' 규정이 적용되는 예가 아닌 것은?",
    options: [
      "싹둥",
      "몹시",
      "법석",
      "깍두기",
      "몽땅",
      "국수"
    ],
    correct: 4,
    explanation: "'다만' 규정은 'ㄱ, ㅂ' 받침 뒤의 된소리에 관한 것입니다. '몽땅'은 'ㅇ' 받침 뒤에서 까닭 없이 나는 된소리이므로 본문 규정에 따라 된소리로 적으며, '다만' 규정과는 관련이 없습니다."
  },
  {
    id: 3,
    text: "<보기>의 설명을 바탕으로 할 때, 제5항의 적용을 받지 않는 것은?\n\n<보기>\n제5항에서 '한 단어'는 '한 형태소로 이루어진 단어'를 의미한다.",
    options: [
      "어깨",
      "오빠",
      "산뜻하다",
      "잠자리",
      "훨씬",
      "담뿍"
    ],
    correct: 3,
    explanation: "'잠자리'는 '잠'과 '자리'라는 두 개의 형태소가 결합한 복합어입니다. 제5항은 하나의 형태소 내부에서 일어나는 된소리 현상을 다루므로, 복합어인 '잠자리'에는 적용되지 않습니다."
  },
  {
    id: 4,
    text: "'늑대[늑때]'를 '늑때'로 적지 않는 이유를 가장 잘 설명한 것은?",
    options: [
      "두 모음 사이에서 나는 된소리가 아니기 때문이다.",
      "'ㄴ, ㄹ, ㅁ, ㅇ' 받침 뒤에서 나는 된소리가 아니기 때문이다.",
      "복합어이기 때문이다.",
      "'ㄱ' 받침 뒤에서는 된소리가 나는 것이 필연적이므로 표기에 반영하지 않기 때문이다.",
      "비슷한 음절이 겹쳐 나는 경우이기 때문이다.",
      "고유어가 아니기 때문이다."
    ],
    correct: 3,
    explanation: "제5항 '다만' 규정에 따라 'ㄱ, ㅂ' 받침 뒤에 오는 예사소리는 항상 된소리로 발음되므로, 굳이 표기에 된소리로 반영하지 않고 예사소리로 적습니다."
  },
  {
    id: 5,
    text: "다음 단어 중 표기가 옳은 것은?",
    options: [
      "깍뚜기",
      "싹뚝",
      "몹씨",
      "산듯하다",
      "쌉쌀하다",
      "법썩"
    ],
    correct: 4,
    explanation: "'쌉쌀하다'는 '쌀'이라는 비슷한 음절이 겹쳐 나는 경우로, '다만' 규정의 예외에 해당하여 된소리로 적습니다. 나머지는 각각 '깍두기, 싹둑, 몹시, 산뜻하다, 법석'으로 적어야 합니다."
  },
  {
    id: 6,
    text: "'형태소'에 대한 설명으로 옳지 않은 것은?",
    options: [
      "뜻을 가진 가장 작은 단위이다.",
      "'하늘'은 하나의 형태소이다.",
      "'먹었다'는 '먹-', '-었-', '-다'의 세 형태소로 나뉜다.",
      "'ㅂ'이나 'ㅣ'는 각각의 형태소이다.",
      "'책가방'은 '책'과 '가방'이라는 두 개의 형태소로 나뉜다.",
      "'나비'는 더 이상 쪼갤 수 없는 하나의 형태소이다."
    ],
    correct: 3,
    explanation: "'ㅂ'이나 'ㅣ'는 소리의 단위(음운)일 뿐, 그 자체로 뜻을 가지고 있지 않으므로 형태소가 아닙니다. 이들이 결합하여 '비'처럼 뜻을 가진 단위가 되어야 형태소입니다."
  },
  {
    id: 7,
    text: "한글 맞춤법 제10항의 내용으로 적절하지 않은 것은?",
    options: [
      "한자음 '녀'는 단어 첫머리에서 '여'로 적는다.",
      "의존 명사 '년(年)'은 예외적으로 본음을 인정한다.",
      "단어의 첫머리가 아닌 '남녀'의 '녀'는 본음대로 적는다.",
      "접두사가 붙은 '신여성'은 '신녀성'으로 적는다.",
      "고유 명사 '한국여자대학'은 두음 법칙에 따라 적는다.",
      "'요소(尿素)'는 '뇨소'가 아닌 '요소'로 적는다."
    ],
    correct: 3,
    explanation: "[붙임 2]에 따라 '신여성'은 이미 두음 법칙이 적용된 '여성'에 '신-'이 결합한 것이므로 '신여성'으로 적습니다. '신녀성'으로 적는 것이 아닙니다."
  },
  {
    id: 8,
    text: "다음 중 두음 법칙이 적용되지 않는 단어는?",
    options: [
      "낙원(樂園)",
      "익명(匿名)",
      "은닉(隱匿)",
      "역사(歷史)",
      "노동(勞動)",
      "유행(流行)"
    ],
    correct: 2,
    explanation: "'은닉'의 '닉'은 단어의 두 번째 음절, 즉 단어 첫머리가 아니므로 두음 법칙이 적용되지 않고 본음대로 적습니다."
  },
  {
    id: 9,
    text: "<보기>의 '년'과 '연'의 쓰임에 대한 설명으로 옳은 것은?\n\n<보기>\n가: 졸업 연도 / 나: 2025 년도\n다: 연 강수량 / 라: 십 년",
    options: [
      "가, 다는 의존 명사이고 나, 라는 자립 명사이다.",
      "가, 다는 자립 명사이고 나, 라는 의존 명사이다.",
      "가는 자립 명사, 나는 의존 명사이지만 다, 라는 모두 자립 명사이다.",
      "가, 나, 다, 라 모두 자립 명사이다.",
      "가, 나, 다, 라 모두 의존 명사이다.",
      "가, 라는 자립 명사이고 나, 다는 의존 명사이다."
    ],
    correct: 1,
    explanation: "'연도', '연'처럼 독립적으로 쓰이거나 단어의 첫머리에 올 경우 자립 명사이며 두음 법칙이 적용됩니다. 숫자나 다른 말 뒤에 기대어 쓰이는 '년도', '년'은 의존 명사이며 두음 법칙이 적용되지 않습니다."
  },
  {
    id: 10,
    text: "다음 중 밑줄 친 부분의 표기가 옳은 것은?",
    options: [
      "우리 회사의 올해 <u>생산양</u>은 작년보다 늘었다.",
      "범죄 <u>은익</u> 혐의로 조사를 받았다.",
      "그는 <u>비논리적</u> 주장을 펼쳤다.",
      "오늘은 <u>양녁</u> 1월 1일이다.",
      "<u>대한 요소 비료 회사</u>",
      "<u>남존여비</u> 사상은 구시대적이다."
    ],
    correct: 5,
    explanation: "'남존여비'는 각 부분이 단어처럼 인식되어 두음 법칙이 적용된 형태로 굳어진 말입니다. ①생산량, ②은닉, ③비논리적, ④양력('양녁'은 오기), ⑤대한요소비료회사(붙여 씀)가 맞는 표기입니다."
  },
  {
    id: 11,
    text: "한글 맞춤법 제11항에 따라 '열' 또는 '율'로 적어야 하는 경우는?",
    options: [
      "성공__",
      "합격__",
      "명중__",
      "타__",
      "출석__",
      "능__"
    ],
    correct: 3,
    explanation: "'타율'은 앞말 '타'가 모음으로 끝나므로 '률'이 아닌 '율'로 적습니다. 나머지는 모두 모음이나 'ㄴ' 받침 이외의 받침으로 끝나므로 '률'로 적습니다. (성공률, 합격률, 명중률, 출석률, 능률)"
  },
  {
    id: 12,
    text: "다음 중 제11항 [붙임 1]의 '다만' 규정(모음이나 'ㄴ' 받침 뒤의 '렬, 률')이 적용된 단어는?",
    options: [
      "수력(水力)",
      "협력(協力)",
      "분열(分裂)",
      "진리(眞理)",
      "쌍룡(雙龍)",
      "도리(道理)"
    ],
    correct: 2,
    explanation: "'분열'은 앞말이 'ㄴ' 받침으로 끝나므로 '다만' 규정에 따라 '렬'이 '열'로 바뀐 경우입니다."
  },
  {
    id: 13,
    text: "<보기>를 참고할 때, 표기가 옳은 것끼리 짝지어진 것은?\n\n<보기>\n모음이나 'ㄴ' 받침 뒤에 이어지는 '렬, 률'은 '열, 율'로 적는다.",
    options: [
      "치렬, 실패률",
      "선열, 백분률",
      "나열, 실패율",
      "분렬, 규율",
      "비열, 전률",
      "진열, 선율"
    ],
    correct: 5,
    explanation: "'진열'은 앞말이 'ㄴ' 받침 뒤이므로 '열'로 적고, '선율' 역시 'ㄴ' 받침 뒤이므로 '율'로 적는 것이 맞습니다. 나머지는 '치열, 실패율, 백분율, 분열, 규율, 비열, 전율'이 올바른 표기입니다."
  },
  {
    id: 14,
    text: "한글 맞춤법 제12항에 따라 '나, 내, 노, 뇌, 누, 느'로 적어야 하는 경우가 아닌 것은?",
    options: [
      "來日(내일)",
      "老人(노인)",
      "往來(왕래)",
      "雷聲(뇌성)",
      "樓閣(누각)",
      "陵墓(능묘)"
    ],
    correct: 2,
    explanation: "'왕래(往來)'의 '래'는 단어의 첫머리가 아니므로 본음대로 '래'로 적습니다. 나머지는 모두 단어 첫머리에 오므로 두음 법칙에 따라 각각 내일, 노인, 뇌성, 누각, 능묘로 적습니다."
  },
  {
    id: 15,
    text: "다음 중 표기가 모두 옳은 것은?",
    options: [
      "상노인, 고랭지, 어린이난",
      "중노동, 고냉지, 가십란",
      "비논리적, 고랭지, 어머니난",
      "내내월, 고냉지, 가십난",
      "상노인, 고랭지, 어린이란",
      "중노동, 고냉지, 어머니란"
    ],
    correct: 0,
    explanation: "'상노인'(접두사처럼 쓰이는 한자+두음 법칙), '고랭지'('고랭-지'로 분석), '어린이난'(고유어+두음 법칙 적용된 '난')이 모두 올바른 표기입니다. '고랭지'를 '고냉지'로 잘못 표기한 보기, 고유어 뒤에 '란'을 쓴 보기들은 틀렸습니다."
  },
  {
    id: 16,
    text: "다음 중 한자음 '리(里)'가 두음 법칙의 적용을 받지 않는 예는?",
    options: [
      "이장(里長)",
      "이정표(里程標)",
      "수백 리",
      "이두(吏讀)",
      "이치(理致)",
      "이면(裏面)"
    ],
    correct: 2,
    explanation: "'리(里)'가 거리를 나타내는 의존 명사로 쓰일 때는 앞말(수백)에 기대어 쓰이므로 단어의 첫머리로 보지 않아 두음 법칙을 적용하지 않고 본음대로 '리'로 적습니다."
  },
  {
    id: 17,
    text: "'列'의 표기가 나머지와 다른 하나는?",
    options: [
      "행__",
      "최전__",
      "균__",
      "전__",
      "직__",
      "장__"
    ],
    correct: 2,
    explanation: "'균열'은 앞말의 받침이 'ㄴ'이므로, 제11항 [붙임 1]의 '다만' 조항에 따라 '렬'이 아닌 '열'로 적습니다. 나머지는 모두 'ㄴ' 받침이나 모음으로 끝나지 않으므로 본음대로 '렬'로 적습니다. (행렬, 최전렬, 전렬, 직렬, 장렬)"
  },
  {
    id: 18,
    text: "밑줄 친 부분의 표기가 옳지 않은 것은?",
    options: [
      "국제연합의 준말은 <u>국련</u>이다.",
      "그는 <u>몰이해</u>로 일관했다.",
      "새로 부임한 <u>신입</u> 사원이다.",
      "십진법에 따라 <u>육천육백육십육</u>으로 쓴다.",
      "그녀는 <u>양심</u>에 가책을 느꼈다.",
      "이것은 상등품과 하등품의 <u>우렬</u>을 가리는 자리다."
    ],
    correct: 5,
    explanation: "'우열(優劣)'의 '열'은 앞 글자 '우'가 모음으로 끝나므로, '렬'이 아닌 '열'로 적어야 합니다."
  },
  {
    id: 19,
    text: "다음 중 '고유어+한자어' 구성에서 두음 법칙이 적용된 예는?",
    options: [
      "구름양(量)",
      "운량(雲量)",
      "공란(空欄)",
      "투고란(投稿欄)",
      "왕릉(王陵)",
      "태릉(泰陵)"
    ],
    correct: 0,
    explanation: "고유어 '구름' 뒤에 한자어 '양(量)'이 결합할 때, '양'이 독립적인 단어로 인식되어 두음 법칙이 적용된 형태('량'→'양')로 적습니다. 나머지는 모두 '한자어+한자어' 구성입니다."
  },
  {
    id: 20,
    text: "제12항 [붙임 2]에 따라 뒷말을 두음 법칙에 따라 적는 경우는?",
    options: [
      "실낙원",
      "동구릉",
      "가정란",
      "왕래",
      "쾌락",
      "지뢰"
    ],
    correct: 0,
    explanation: "'실-낙원(失樂園)'은 접두사처럼 쓰이는 한자 '실'이 독립성이 있는 단어 '낙원'에 결합한 경우로, 뒷말 '낙원'을 두음 법칙에 따라 적습니다. 나머지는 모두 단어의 첫머리가 아닌 경우라 본음대로 적습니다."
  },
  {
    id: 21,
    text: "된소리 표기에 대한 설명으로 옳지 않은 것은?",
    options: [
      "'어깨'는 두 모음 사이에서 이유 없이 된소리가 나므로 된소리로 적는다.",
      "'국수'는 'ㄱ' 받침 뒤에서 필연적으로 된소리가 나므로 예사소리로 적는다.",
      "'산뜻'은 'ㄴ' 받침 뒤에서 이유 없이 된소리가 나므로 된소리로 적는다.",
      "'눈곱'은 복합어이므로 제5항에 따라 된소리로 적지 않는다.",
      "'똑똑'은 같은 음절이 겹치므로 예외적으로 된소리로 적는다.",
      "'믿고'는 두 형태소가 결합한 말이므로 된소리로 적지 않는다."
    ],
    correct: 5,
    explanation: "'믿고'는 [믿꼬]로 된소리가 나지만, 이는 두 형태소('믿-'과 '-고')가 결합하는 과정에서 일어나는 된소리되기 현상입니다. 된소리를 표기에 반영하지 않는 것은 맞지만, 그 이유가 '한 형태소 내부'의 현상을 다루는 제5항 규정 때문은 아닙니다."
  },
  {
    id: 22,
    text: "다음 중 두음 법칙 표기가 틀린 것은?",
    options: [
      "신여성",
      "대한 요소 비료 회사",
      "공염불",
      "구년도",
      "한국여자대학",
      "남존여비"
    ],
    correct: 1,
    explanation: "제10항 [붙임 3]에 따라 둘 이상의 단어로 이루어진 고유 명사를 붙여 쓸 때는, 각 단어에 두음 법칙을 적용한 후 모두 붙여 씁니다. 따라서 '대한요소비료회사'로 붙여 써야 합니다."
  },
  {
    id: 23,
    text: "제11항에 제시된 의존 명사로, 본음대로 적는 것은?",
    options: [
      "냥(兩)",
      "년(年)",
      "리(里)",
      "량(輛)",
      "푼(分)",
      "원(圓)"
    ],
    correct: 2,
    explanation: "제11항의 '다만' 조항에서는 의존 명사 '리(里)'와 '리(理)'를 본음대로 적는다고 명시하고 있습니다. '냥'과 '년'은 제10항의 예외이며, '량' 또한 제11항의 예외로 본음대로 적습니다."
  },
  {
    id: 24,
    text: "'률(律, 率)'의 표기가 '률'이 아닌 '율'로 적히는 환경은?",
    options: [
      "'ㄱ' 받침 뒤",
      "'ㅂ' 받침 뒤",
      "'ㅅ' 받침 뒤",
      "'ㅇ' 받침 뒤",
      "'ㄴ' 받침 뒤",
      "'ㄷ' 받침 뒤"
    ],
    correct: 4,
    explanation: "제11항 [붙임 1] '다만' 조항에 따라, 모음으로 끝나거나 'ㄴ' 받침으로 끝나는 말 뒤에서는 '률'을 '율'로 적습니다."
  },
  {
    id: 25,
    text: "'낙화유수(落花流水)'의 표기에 적용된 두음 법칙은?",
    options: [
      "제10항",
      "제11항",
      "제12항",
      "제10항, 제11항",
      "제11항, 제12항",
      "제10항, 제12항"
    ],
    correct: 4,
    explanation: "'낙화(落花)'의 '낙'은 원래 '락'이었으나 제12항에 따라 '낙'으로 적고, '유수(流水)'의 '유'는 원래 '류'였으나 제11항에 따라 '유'로 적습니다. 따라서 제11항과 제12항이 모두 적용되었습니다."
  },
  {
    id: 26,
    text: "다음 중 형태소 분석이 바르게 된 것은?",
    options: [
      "나비 → 나 + 비",
      "싹둑 → 싹 + 둑",
      "어깨 → 엇 + 개",
      "책가방 → 책 + 가방",
      "국수 → 국 + 수",
      "몽땅 → 몽 + 땅"
    ],
    correct: 3,
    explanation: "'책가방'은 '책'과 '가방'이라는 뜻을 가진 두 개의 형태소로 나눌 수 있습니다. 나머지는 모두 더 이상 뜻을 가진 단위로 쪼갤 수 없는 하나의 형태소입니다."
  },
  {
    id: 27,
    text: "다음 단어들 중 표기 원리가 다른 하나는?",
    options: [
      "살짝",
      "훨씬",
      "갑자기",
      "담뿍",
      "몽땅"
    ],
    correct: 2,
    explanation: "'갑자기'는 'ㅂ' 받침 뒤에서 필연적으로 나는 된소리를 표기에 반영하지 않은 예(제5항 '다만' 규정)입니다. 나머지는 모두 'ㄹ, ㅁ, ㅇ' 받침 뒤에서 뚜렷한 까닭 없이 나는 된소리를 소리 나는 대로 적은 예입니다."
  },
  {
    id: 28,
    text: "<보기>의 규정이 모두 적용된 단어는?\n\n<보기>\n가. 제10항: 한자음 '녀, 뇨, 뉴, 니'가 단어 첫머리에 올 적에는, 두음 법칙에 따라 '여, 요, 유, 이'로 적는다.\n나. 제11항: 한자음 '랴, 려, 례, 료, 류, 리'가 단어의 첫머리에 올 적에는, 두음 법칙에 따라 '야, 여, 예, 요, 유, 이'로 적는다.",
    options: [
      "남녀노소(男女老少)",
      "연이율(年利率)",
      "해외여행(海外旅行)",
      "유언비어(流言蜚語)",
      "이용(利用)",
      "은닉(隱匿)"
    ],
    correct: 1,
    explanation: "'연이율(年利率)'은 '연(年)'에 제10항이, '이율(利率)'의 '이'에 제11항이 적용된 후 결합한 단어입니다. '연'은 '년'이, '이'는 '리'가 각각 두음 법칙에 따라 변한 것입니다."
  },
  {
    id: 29,
    text: "'서울여관'을 '서울려관'으로 적지 않는 이유는?",
    options: [
      "'여관'이 한자어이기 때문이다.",
      "'서울'이 고유어이기 때문이다.",
      "'서울'과 '여관'이 결합한 고유 명사로, 각 단어에 두음 법칙을 적용하기 때문이다.",
      "발음이 [서울려관]이 아니기 때문이다.",
      "'여관'의 '여'는 단어 첫머리가 아니기 때문이다.",
      "고유 명사에는 두음 법칙을 적용하지 않기 때문이다."
    ],
    correct: 2,
    explanation: "제11항 [붙임 5]에 따라 둘 이상의 단어로 이루어진 고유 명사를 붙여 쓸 때는, 결합된 각 단어('서울'과 '여관')를 독립된 단어로 보아 각각 두음 법칙을 적용합니다. 따라서 '려관'이 아닌 '여관'으로 적은 후 결합합니다."
  },
  {
    id: 30,
    text: "다음 중 '낙뢰(落雷)'와 표기 원리가 같은 단어는?",
    options: [
      "내일(來日)",
      "왕래(往來)",
      "뇌성(雷聲)",
      "지뢰(地雷)",
      "비논리적(非論理的)",
      "상노인(上老人)"
    ],
    correct: 3,
    explanation: "'낙뢰'와 '지뢰'는 모두 '뢰'가 단어의 첫머리가 아닌 위치에 오므로 두음 법칙이 적용되지 않고 본음대로 적은 경우입니다. 나머지는 '래, 로, 뇌'가 단어 첫머리에 오거나(①, ③), 접두사처럼 쓰이는 말 뒤에 와서(⑤, ⑥) 두음 법칙이 적용된 경우, 또는 다른 한자음이 본음대로 쓰인 경우(②)입니다."
  }
];

        // 타이머 관련 변수
        let timerInterval;
        let currentTime = 300; // 5분 (300초)
        const maxTime = 300;

        // 현재 학습 상태
        let currentQuestionIndex = 0;
        let correctCount = 0;
        let wrongCount = 0;
        let startTime;
        let answeredQuestions = new Set();

        // 셔플된 문제 배열 (Stage 2 & 3용)
        let shuffledStage2Questions = [];
        let shuffledStage3Questions = [];

        // Fisher-Yates 셔플 알고리즘
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // 모달 드래그 설정 (한 번만 실행)
        function setupModalDrag() {
            if (dragListenersAdded) return;
            
            const modal = document.getElementById('modal-content');

            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);

            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', stopDrag);
            
            dragListenersAdded = true;
        }

        function startDrag(e) {
            const modal = document.getElementById('modal-content');
            if (e.target.closest('.option-button')) return;

            // 터치 이벤트에서 기본 동작 방지
            if (e.type === 'touchstart') {
                e.preventDefault();
            }

            isDragging = true;
            modal.classList.add('dragging');

            const touch = e.touches ? e.touches[0] : e;
            dragStartX = touch.clientX;
            dragStartY = touch.clientY;

            const rect = modal.getBoundingClientRect();
            modalStartX = rect.left;
            modalStartY = rect.top;
        }

        function drag(e) {
            if (!isDragging) return;
            
            // 터치 이벤트에서 기본 동작 방지
            if (e.type === 'touchmove') {
                e.preventDefault();
            }

            const touch = e.touches ? e.touches[0] : e;
            const deltaX = touch.clientX - dragStartX;
            const deltaY = touch.clientY - dragStartY;

            const modal = document.getElementById('modal-content');
            modal.style.left = (modalStartX + deltaX) + 'px';
            modal.style.top = (modalStartY + deltaY) + 'px';
        }

        function stopDrag() {
            if (!isDragging) return;
            isDragging = false;
            document.getElementById('modal-content').classList.remove('dragging');
        }

        // 타이머 시작
        function startTimer() {
            timerInterval = setInterval(() => {
                currentTime--;
                updateTimerBar();

                if (currentTime <= 0) {
                    endStage();
                }
            }, 1000);
        }

        // 타이머 바 업데이트
        function updateTimerBar() {
            const percentage = (currentTime / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        // 시간 더하기/빼기
        function addTime(seconds) {
            currentTime = Math.min(currentTime + seconds, maxTime);
            updateTimerBar();
        }

        function subtractTime(seconds) {
            currentTime = Math.max(currentTime - seconds, 0);
            updateTimerBar();
        }

        // Markdown to HTML 변환
        function convertMarkdownToHTML(text) {
            // 테이블 처리
            let html = text.replace(/\|(.+)\|/g, (match) => {
                const cells = match.split('|').filter(c => c.trim());
                const isHeader = text.indexOf(match) !== -1 && text.split(match)[1].indexOf('|---') !== -1;
                const tag = isHeader ? 'th' : 'td';
                return '<tr>' + cells.map(cell => `<${tag}>${cell.trim()}</${tag}>`).join('') + '</tr>';
            });

            // 테이블 구조 감싸기
            html = html.replace(/(<tr>.*<\/tr>\n)+/g, (match) => {
                return '<table>' + match + '</table>';
            });

            // 헤딩 변환
            html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');

            // 볼드 변환
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

            // 밑줄 변환 (<u> 태그 지원)
            html = html.replace(/<u>(.+?)<\/u>/g, '<u>$1</u>');

            // 리스트 변환
            html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>\n?)+/g, (match) => {
                return '<ul>' + match + '</ul>';
            });

            // 줄바꿈 변환
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        // Stage 1: 딥리서치 - 2-choice 질문이 있는 HTML 생성
        // ============================================
        // Stage 1 학습 콘텐츠 생성 함수
        // ============================================
        // 설명: Stage 1에서 표시할 학습 콘텐츠를 생성합니다.
        // rawContent 내에서 <span class="highlight" data-question-id="번호">__________</span> 형식으로
        // STAGE1_QUESTIONS의 문제가 하이라이트로 표시됩니다.
        // - data-question-id: STAGE1_QUESTIONS 배열의 id와 일치해야 함
        // - 마크다운 문법 지원 (## 제목, **볼드**, 리스트 등)

        function generateStage1Content() {
            // ============================================
            // rawContent: Stage 1에 표시할 학습 콘텐츠
            // ============================================
            // 마크다운 문법 지원: ### 제목, **볼드**, <ul><li> 리스트, <table> 테이블 등
            // 하이라이트 문제 삽입: <span class="highlight" data-question-id="번호">__________</span>
            // - data-question-id는 STAGE1_QUESTIONS의 id와 반드시 일치해야 함
            // - context 속성은 어느 위치에서 하이라이트가 나타날지 결정함

            const rawContent = `<div class="text-content">
<h3><strong>한글 맞춤법 해설 (심화편)</strong></h3>

<h4><strong>제3장 소리에 관한 것</strong></h4>

<p><strong>제1절 된소리</strong></p>

<p>제5항</p>

<p>한 단어 안에서 뚜렷한 까닭 없이 나는 된소리는 다음 음절의 첫소리를 된소리로 적는다.</p>

<p><strong>1. 두 모음 사이에서 나는 된소리</strong></p>

<ul>
<li>소쩍새, 어깨, 오빠, 으뜸, 아끼다</li>
<li>기쁘다, 깨끗하다, 어떠하다, 해쓱하다, 가끔</li>
<li>거꾸로, 부썩, 어찌, 이따금</li>
</ul>

<p><strong>2. 'ㄴ, ㄹ, ㅁ, ㅇ' 받침 뒤에서 나는 된소리</strong></p>

<ul>
<li>산뜻하다, 잔뜩, 살짝, 훨씬, 담뿍</li>
<li>움찔, 몽땅, 엉뚱하다</li>
</ul>

<p><strong>다만, 'ㄱ, ㅂ' 받침 뒤에서 나는 된소리는, 같은 음절이나 비슷한 음절이 겹쳐 나는 경우가 아니면 된소리로 적지 아니한다.</strong></p>

<ul>
<li>국수, 깍두기, 딱지, 색시, 싹둑(~싹둑)</li>
<li>법석, 갑자기, 몹시</li>
</ul>

<p>이 조항에서 '한 단어'는 <span class="highlight" data-question-id="1">__________</span>를 의미하는 것으로 풀이할 수 있다. 실제로 이 규정의 적용을 받는 '어깨'나 '산뜻' 등은 모두 <span class="highlight" data-question-id="2">__________</span>이다. 따라서 복합어인 '눈곱[눈꼽], 발바닥[발빠닥], 잠자리[잠짜리]'와 같은 단어의 된소리 현상은 이 조항의 적용을 <span class="highlight" data-question-id="3">__________</span>.</p>

<p>한 형태소 안의 두 모음 사이에서 나는 된소리는 <span class="highlight" data-question-id="4">__________</span>. 예를 들어 새의 울음을 나타내는 형태소 '소쩍'을 '솟적'으로 적을 이유가 없는 것은 <span class="highlight" data-question-id="5">__________</span> 형태를 분석하여 표기할 근거가 없기 때문이다.</p>

<p>(예시 분석 1)</p>

<ul>
<li>어깨 → <span class="highlight" data-question-id="6">(엇개/어깨)</span></li>
<li>오빠 → <span class="highlight" data-question-id="7">(옵바/오빠)</span></li>
<li>새끼 → <span class="highlight" data-question-id="8">(샛기/새끼)</span></li>
<li>토끼 → <span class="highlight" data-question-id="9">(톳기/토끼)</span></li>
<li>가꾸다 → <span class="highlight" data-question-id="10">(갓구다/가꾸다)</span></li>
<li>기쁘다 → <span class="highlight" data-question-id="11">(깃브다/기쁘다)</span></li>
</ul>

<p>이와 마찬가지로 위의 단어들을 '엇개, 옵바, 샛기' 등으로 적을 근거가 없는 이유는 <span class="highlight" data-question-id="12">__________</span> 소리 나는 대로 적기 때문이다.</p>

<p>또한 한 형태소에서 'ㄴ, ㄹ, ㅁ, ㅇ' 받침 뒤에서 나는 된소리도 <span class="highlight" data-question-id="13">__________</span> 적는다. 받침 'ㄴ, ㄹ, ㅁ, ㅇ'은 뒤에 오는 예사소리를 된소리로 바꾸어 주는 <span class="highlight" data-question-id="14">__________</span>.</p>

<p>(예시 분석 2)</p>

<ul>
<li>엉뚱(하다), 절뚝(거리다), 듬뿍, 함빡<br>
위 단어들은 된소리로 발음되는데, 해당 받침들은 된소리를 만드는 <span class="highlight" data-question-id="15">__________</span>.</li>
</ul>

<p>따라서 'ㄴ, ㄹ, ㅁ, ㅇ' 뒤에 오는 된소리는 특별한 까닭이 없다고 보아 <span class="highlight" data-question-id="16">__________</span>.</p>

<p>(예시 분석 3)</p>

<ul>
<li>산뜻(하다) → <span class="highlight" data-question-id="17">(산듯/산뜻)</span></li>
<li>살짝 → <span class="highlight" data-question-id="18">(살작/살짝)</span></li>
<li>듬뿍 → <span class="highlight" data-question-id="19">(듬북/듬뿍)</span></li>
<li>뭉뚱(그리다) → <span class="highlight" data-question-id="20">(뭉둥/뭉뚱)</span></li>
</ul>

<p>그렇지만 'ㄱ, ㅂ' 받침 뒤에 연결되는 'ㄱ, ㄷ, ㅂ, ㅅ, ㅈ'은 <span class="highlight" data-question-id="21">__________</span> 된소리로 소리 나므로, 이러한 경우에는 된소리로 표기하지 <span class="highlight" data-question-id="22">__________</span>.</p>

<p>(예시 분석 4)</p>

<ul>
<li>늑대 → 발음: $$늑때$$, 표기: <span class="highlight" data-question-id="23">(늑대/늑때)</span></li>
<li>낙지 → 발음: $$낙찌$$, 표기: <span class="highlight" data-question-id="24">(낙지/낙찌)</span></li>
<li>접시 → 발음: $$접씨$$, 표기: <span class="highlight" data-question-id="25">(접시/접씨)</span></li>
<li>갑자기 → 발음: $$갑짜기$$, 표기: <span class="highlight" data-question-id="26">(갑자기/갑짜기)</span></li>
</ul>

<p>'ㄱ, ㅂ' 받침 외에 '믿고[믿꼬], 잊지[읻찌]'와 '낯설다[낟썰다]'처럼 앞말의 받침이 [ㄷ]으로 발음될 때 뒷말의 첫소리가 된소리로 나는 예들도 있다. 이러한 말 역시 된소리를 <span class="highlight" data-question-id="27">__________</span> 이는 다른 이유에서이다. 이들은 <span class="highlight" data-question-id="28">__________</span>, '눈곱, 발바닥' 등과 마찬가지로 된소리를 표기에 반영하지 않는 것이다. 그렇지만 '똑똑하다, 쓱싹쓱싹, 쌉쌀하다'의 '똑똑, 쓱싹, 쌉쌀'처럼 <span class="highlight" data-question-id="29">__________</span>에는 예외적으로 된소리를 표기에 반영하여 같은 글자로 적는다.</p>

<h4><strong>더 알아보기: 형태소(形態素)란?</strong></h4>

<p>'형태소'는 <span class="highlight" data-question-id="30">__________</span> 가장 작은 단위를 말한다. 국어에서 'ㅂ'이나 'ㅣ' 등은 뜻을 가지고 있지 않기 때문에 형태소가 될 수 없지만, '비'가 되면 <span class="highlight" data-question-id="31">__________</span>인 형태소가 된다. '책가방'은 '책'과 '가방'이라는 두 가지 의미로 쪼개지기 때문에 형태소는 <span class="highlight" data-question-id="32">__________</span>이다. 더 작은 단위로 쪼갠다고 해도 쪼갰을 때 의미가 없어지면 더 이상 나눌 수 <span class="highlight" data-question-id="33">__________</span>. '나비'는 '나'와 '비'로 쪼개어지지만 이때 '나'와 '비'는 '나비'의 의미와는 전혀 관계가 없으므로, '나비'는 <span class="highlight" data-question-id="34">__________</span>.</p>

<h4><strong>제5절 두음 법칙</strong></h4>

<p>제10항</p>

<p>한자음 '녀, 뇨, 뉴, 니'가 단어 첫머리에 올 적에는, 두음 법칙에 따라 '여, 요, 유, 이'로 적는다.</p>

<table>
<tr><th>ㄱ (취함)</th><th>ㄴ (버림)</th><th>ㄱ (취함)</th><th>ㄴ (버림)</th></tr>
<tr><td>여자(女子)</td><td>녀자</td><td>유대(紐帶)</td><td>뉴대</td></tr>
<tr><td>연세(年歲)</td><td>년세</td><td>이토(泥土)</td><td>니토</td></tr>
<tr><td>요소(尿素)</td><td>뇨소</td><td>익명(匿名)</td><td>닉명</td></tr>
</table>

<p>다만, 다음과 같은 의존 명사에서는 '냐, 녀' 음을 인정한다.</p>

<p>냥(兩) 냥쭝(兩-) 년(年)(몇 년)</p>

<p><strong>[붙임 1]</strong> 단어의 첫머리 이외의 경우에는 <span class="highlight" data-question-id="35">__________</span>.</p>

<ul>
<li>남녀(男女), 당뇨(糖尿), 결뉴(結紐), 은닉(隱匿)</li>
</ul>

<p><strong>[붙임 2]</strong> 접두사처럼 쓰이는 한자가 붙어서 된 말이나 합성어에서, 뒷말의 첫소리가 'ㄴ' 소리로 나더라도 <span class="highlight" data-question-id="36">__________</span>.</p>

<ul>
<li>신여성(新女性), 공염불(空念佛), 남존여비(男尊女卑)</li>
</ul>

<p><strong>[붙임 3]</strong> 둘 이상의 단어로 이루어진 고유 명사를 붙여 쓰는 경우에도 <span class="highlight" data-question-id="37">__________</span>.</p>

<ul>
<li>한국여자대학, 대한요소비료회사</li>
</ul>

<p>제10항~제12항에서는 국어의 두음 법칙을 규정하였다. 두음 법칙은 단어의 <span class="highlight" data-question-id="38">__________</span>에 특정한 소리가 출현하지 못하는 현상을 말한다. '녀, 뇨, 뉴, 니'를 포함하는 한자어 음절이 단어 첫머리에 올 때는 'ㄴ'이 나타나지 못하여 '여, 요, 유, 이'의 형태로 실현되는데, 이 조항에서는 이러한 두음 법칙의 내용을 규정하였다.</p>

<p>(예시 분석 5)</p>

<ul>
<li>연도(年度) → <span class="highlight" data-question-id="39">(년도/연도)</span></li>
<li>열반(涅槃) → <span class="highlight" data-question-id="40">(녈반/열반)</span></li>
<li>요도(尿道) → <span class="highlight" data-question-id="41">(뇨도/요도)</span></li>
</ul>

<p>그런데 여기에는 예외가 있다. 한자어 음절이 '녀, 뇨, 뉴, 니'를 포함하고 있더라도 의존 명사에는 두음 법칙이 <span class="highlight" data-question-id="42">__________</span>. 이는 의존 명사는 독립적으로 쓰이기보다는 그 앞의 말과 연결되어 <span class="highlight" data-question-id="43">__________</span> 때문이다. 즉 '냥, 냥쭝, 년' 등과 같은 의존 명사는 한글 맞춤법 제42항에 따라 앞말과 띄어 쓰지만 언제나 의존하는 대상과 하나의 단위로 쓰인다. 이러한 이유로 이 말들은 독립된 단어로 잘 인식되지 않아, 단어의 첫머리처럼 취급되지 <span class="highlight" data-question-id="44">__________</span>. 그 결과 단어 첫머리임에도 두음 법칙이 적용되지 않고 <span class="highlight" data-question-id="45">__________</span> 적는다.</p>

<p>(예시 분석 6)</p>

<ul>
<li>십 년 → <span class="highlight" data-question-id="46">(십 연/십 년)</span></li>
<li>금 한 냥 → <span class="highlight" data-question-id="47">(금 한 양/금 한 냥)</span></li>
<li>은 두 냥쭝 → <span class="highlight" data-question-id="48">(은 두 양쭝/은 두 냥쭝)</span></li>
</ul>

<p>따라서 '年', '年度'처럼 의존 명사로 쓰이기도 하고 자립 명사로 쓰이기도 하는 한자어의 경우에는 두음 법칙의 적용에서 차이가 <span class="highlight" data-question-id="49">__________</span>. '년, 년도'가 의존 명사라면 '연, 연도'는 <span class="highlight" data-question-id="50">__________</span>이다.</p>

<p>(예시 분석 7)</p>

<ul>
<li>연 강수량 <span class="highlight" data-question-id="51">(의존 명사/자립 명사)</span> / 일 년 <span class="highlight" data-question-id="52">(의존 명사/자립 명사)</span></li>
<li>생산 연도 <span class="highlight" data-question-id="53">(의존 명사/자립 명사)</span> / 2018년도 <span class="highlight" data-question-id="54">(의존 명사/자립 명사)</span></li>
</ul>

<p><strong>[붙임 1]</strong> 단어의 <span class="highlight" data-question-id="55">__________</span>에는 두음 법칙이 적용되지 않으므로 본음대로 적는 것이다.</p>

<p>(예시 분석 8)</p>

<ul>
<li>소녀(少女) → <span class="highlight" data-question-id="56">(소여/소녀)</span></li>
<li>만년(晩年) → <span class="highlight" data-question-id="57">(만연/만년)</span></li>
<li>탐닉(耽溺) → <span class="highlight" data-question-id="58">(탐익/탐닉)</span></li>
</ul>

<p><strong>[붙임 2]</strong> '신-여성, 공-염불'은 <span class="highlight" data-question-id="59">__________</span> '신여성, 공염불'로 적는다.</p>

<p><strong>[붙임 3]</strong> 둘 이상의 단어로 이루어진 고유 명사를 붙여 쓰는 경우에도, 결합된 각 단어를 <span class="highlight" data-question-id="60">__________</span>. 따라서 '한국 여자 농구 연맹'을 붙여서 쓰면 '한국여자농구연맹'이 된다.</p>

<p><em>(이하 제11항, 제12항 내용 및 관련 문제들은 지면 관계상 생략합니다. 위와 같은 방식으로 내용을 구성하여 제공할 수 있습니다.)</em></p>
</div>`;

            return rawContent;
        }

        // Stage 1: 딥리서치 초기화
        function initStage1() {
            currentStage = 1;
            currentQuestionIndex = 0;
            correctCount = 0;
            wrongCount = 0;
            answeredQuestions.clear();
            currentTime = 300;
            startTime = Date.now();

            // UI 업데이트
            document.querySelector('.title').textContent = '한글 맞춤법 해설 3장 - 소리에 관한 것';
            document.getElementById('stage-subtitle').textContent = '1단계: 딥리서치';
            document.getElementById('current-question').textContent = answeredQuestions.size.toString();
            document.getElementById('total-questions').textContent = STAGE1_QUESTIONS.length.toString();

            // 단계 인디케이터 업데이트
            const dots = document.querySelectorAll('.stage-dot');
            dots.forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index === 0) dot.classList.add('active');
            });

            // 지문 표시
            const passageHTML = generateStage1Content();
            document.getElementById('passage-container').innerHTML = passageHTML;

            // 하이라이트 클릭 이벤트 추가
            const highlights = document.querySelectorAll('.highlight');
            highlights.forEach(highlight => {
                highlight.addEventListener('click', function() {
                    const questionId = parseInt(this.getAttribute('data-question-id'));
                    if (!answeredQuestions.has(questionId)) {
                        showQuestion(questionId, this);
                    }
                });
            });

            document.getElementById('result-screen').classList.remove('active');
            // 학습 완료 시스템을 위한 데이터 export
        window.learningResultData = {
            totalStages: totalStages || 5,
            totalCorrect: totalCorrect || 0,
            totalWrong: totalWrong || 0,
            totalAccuracy: totalAccuracy || 0,
            totalScore: totalScore || 0,
            totalElapsedTime: totalElapsedTime || (Date.now() - globalStartTime),
            stagesDetail: stageResults || {}
        };
        console.log('학습 데이터 export:', window.learningResultData);


            document.getElementById('main-content').style.display = 'block';
            // 학습 완료 버튼 추가
            if (typeof addCompleteLearningButton === 'function') {
                setTimeout(() => addCompleteLearningButton(), 500);
            }
            startTimer();
        }

        // 질문 모달 표시
        function showQuestion(questionId, highlightElement) {
            const question = STAGE1_QUESTIONS.find(q => q.id === questionId);
            if (!question) return;

            const modalOverlay = document.getElementById('modal-overlay');
            const modalHeader = document.getElementById('modal-header');
            const modalOptions = document.getElementById('modal-options');
            const modalContent = document.getElementById('modal-content');

            // 모달 초기화
            modalContent.classList.remove('correct-feedback', 'incorrect-feedback');

            // 질문 헤더
            modalHeader.textContent = question.context;

            // 선지 셔플
            const options = shuffleArray([
                { text: question.correctAnswer, isCorrect: true },
                { text: question.wrongAnswer, isCorrect: false }
            ]);

            // 선지 버튼 생성
            modalOptions.innerHTML = '';
            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-button';
                button.textContent = option.text;
                button.onclick = () => checkAnswer(questionId, option.isCorrect, button, highlightElement);
                modalOptions.appendChild(button);
            });

            // 모달 표시
            modalOverlay.classList.add('active');

            // 모달 위치 설정 (하이라이트 근처에 배치하되 화면 밖으로 나가지 않도록)
            const highlightRect = highlightElement.getBoundingClientRect();
            const modalWidth = 500; // max-width
            const modalHeight = 300; // 대략적인 높이

            // 하이라이트 오른쪽에 배치 시도
            let left = highlightRect.right + 20;
            let top = highlightRect.top;

            // 오른쪽 공간이 부족하면 왼쪽에 배치
            if (left + modalWidth > window.innerWidth) {
                left = highlightRect.left - modalWidth - 20;
            }

            // 왼쪽도 공간이 부족하면 중앙에 배치
            if (left < 0) {
                left = (window.innerWidth - modalWidth) / 2;
            }

            // 위쪽으로 벗어나지 않도록
            if (top < 20) {
                top = 20;
            }

            // 아래쪽으로 벗어나지 않도록
            if (top + modalHeight > window.innerHeight) {
                top = window.innerHeight - modalHeight - 20;
            }

            modalContent.style.left = left + 'px';
            modalContent.style.top = top + 'px';

            // 모달 드래그 설정 (한 번만 실행)
            setupModalDrag();
        }

        // 답변 체크
        function checkAnswer(questionId, isCorrect, button, highlightElement) {
            const buttons = document.querySelectorAll('.option-button');
            const modalContent = document.getElementById('modal-content');

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            if (isCorrect) {
                button.classList.add('correct');
                modalContent.classList.add('correct-feedback');
                highlightElement.classList.add('correct', 'answered');
                highlightElement.textContent = button.textContent;
                correctCount++;
                addTime(10);
            } else {
                button.classList.add('incorrect');
                modalContent.classList.add('incorrect-feedback');
                highlightElement.classList.add('incorrect', 'answered');

                // 정답 표시
                const correctButton = Array.from(buttons).find(btn => !btn.classList.contains('incorrect'));
                if (correctButton) {
                    correctButton.classList.add('correct');
                    highlightElement.textContent = correctButton.textContent;
                }

                wrongCount++;
                subtractTime(40);
            }

            // 답변한 질문 추가
            answeredQuestions.add(questionId);
            document.getElementById('current-question').textContent = answeredQuestions.size.toString();

            // 모달 닫기
            setTimeout(() => {
                document.getElementById('modal-overlay').classList.remove('active');

                // 모든 질문 완료 확인
                if (answeredQuestions.size === STAGE1_QUESTIONS.length) {
                    setTimeout(() => endStage(), 500);
                }
            }, 1500);
        }

        // Stage 2: OX 학습 초기화
        function initStage2() {
            clearInterval(timerInterval);

            currentStage = 2;
            currentQuestionIndex = 0;
            correctCount = 0;
            wrongCount = 0;
            currentTime = 300;
            startTime = Date.now();

            // 틀린 문제 배열 초기화
            stage2WrongQuestions = [];

            // OX 문제 셔플 (매번 새로운 순서로)
            shuffledStage2Questions = shuffleArray(STAGE2_QUESTIONS);

            // UI 업데이트
            document.getElementById('stage-subtitle').textContent = '2단계: OX 학습';
            document.getElementById('current-question').textContent = '1';
            document.getElementById('total-questions').textContent = shuffledStage2Questions.length.toString();

            // 단계 인디케이터 업데이트
            const dots = document.querySelectorAll('.stage-dot');
            dots.forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index === 0) dot.classList.add('completed');
                if (index === 1) dot.classList.add('active');
            });

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';
            showOXQuestion();
            startTimer();
        }

        // OX 문제 표시
        function showOXQuestion() {
            const question = shuffledStage2Questions[currentQuestionIndex];

            document.getElementById('passage-container').innerHTML = `
                <div class="ox-container">
                    <div class="ox-question-card">
                        <div class="question-number">문제 ${currentQuestionIndex + 1} / ${shuffledStage2Questions.length}</div>
                        <div class="question-text">${convertMarkdownToHTML(question.text)}</div>
                        <div class="ox-options">
                            <button class="ox-option-button" onclick="checkOXAnswer('O')">O</button>
                            <button class="ox-option-button" onclick="checkOXAnswer('X')">X</button>
                        </div>
                        ${question.explanation ? `<div class="explanation-text" id="ox-explanation" style="display:none;">${convertMarkdownToHTML(question.explanation)}</div>` : ''}
                    </div>
                </div>
            `;
        }

        // OX 답변 체크
        function checkOXAnswer(answer) {
            const question = shuffledStage2Questions[currentQuestionIndex];
            const buttons = document.querySelectorAll('.ox-option-button');
            const isCorrect = answer === question.answer;

            buttons.forEach(button => {
                button.disabled = true;
                if (button.textContent === answer) {
                    button.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
            });

            if (isCorrect) {
                correctCount++;
                addTime(10);
            } else {
                wrongCount++;
                subtractTime(15);

                // 틀린 문제 저장
                stage2WrongQuestions.push({
                    question: question.text,
                    userAnswer: answer,
                    correctAnswer: question.answer,
                    explanation: question.explanation || ''
                });

                // 설명 표시
                const explanation = document.getElementById('ox-explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            setTimeout(() => {
                currentQuestionIndex++;
                document.getElementById('current-question').textContent = (currentQuestionIndex + 1).toString();

                if (currentQuestionIndex >= shuffledStage2Questions.length) {
                    endStage();
                } else {
                    showOXQuestion();
                }
            }, 2000);
        }

        // Stage 3: 객관식 학습 초기화
        function initStage3() {
            clearInterval(timerInterval);

            currentStage = 3;
            currentQuestionIndex = 0;
            correctCount = 0;
            wrongCount = 0;
            currentTime = 300;
            startTime = Date.now();

            // 틀린 문제 배열 초기화
            stage3WrongQuestions = [];

            // 객관식 문제 셔플 (매번 새로운 순서로)
            shuffledStage3Questions = shuffleArray(STAGE3_QUESTIONS);

            // 각 문제에 대해 4지선다 미리 생성
            shuffledStage3Questions.forEach(q => {
                q.selectedOptions = generate4Options(q.options, q.correct);
            });

            // UI 업데이트
            document.getElementById('stage-subtitle').textContent = '3단계: 객관식 학습';
            document.getElementById('current-question').textContent = '1';
            document.getElementById('total-questions').textContent = shuffledStage3Questions.length.toString();

            // 단계 인디케이터 업데이트
            const dots = document.querySelectorAll('.stage-dot');
            dots.forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index < 2) dot.classList.add('completed');
                if (index === 2) dot.classList.add('active');
            });

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';
            showMCQQuestion();
            startTimer();
        }

        // 6지선다에서 4지선다 생성 (정답 포함)
        function generate4Options(allOptions, correctIndex) {
            const correctOption = allOptions[correctIndex];
            const otherOptions = allOptions.filter((_, i) => i !== correctIndex);

            // 오답 중에서 3개 랜덤 선택
            const shuffledOthers = shuffleArray(otherOptions);
            const selected3Others = shuffledOthers.slice(0, 3);

            // 정답과 3개 오답을 합쳐서 셔플
            const final4Options = shuffleArray([correctOption, ...selected3Others]);

            // 새로운 정답 인덱스 찾기
            const newCorrectIndex = final4Options.indexOf(correctOption);

            return {
                options: final4Options,
                correctIndex: newCorrectIndex
            };
        }

        // 객관식 문제 표시
        function showMCQQuestion() {
            const question = shuffledStage3Questions[currentQuestionIndex];
            const { options, correctIndex } = question.selectedOptions;

            const optionsHTML = options.map((opt, index) => `
                <button class="mcq-option-button" onclick="checkMCQAnswer(${index})">
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${convertMarkdownToHTML(opt)}</span>
                </button>
            `).join('');

            document.getElementById('passage-container').innerHTML = `
                <div class="mcq-container">
                    <div class="mcq-question-card">
                        <div class="question-number">문제 ${currentQuestionIndex + 1} / ${shuffledStage3Questions.length}</div>
                        <div class="mcq-question-text">${convertMarkdownToHTML(question.text)}</div>
                        <div class="mcq-options">
                            ${optionsHTML}
                        </div>
                        ${question.explanation ? `<div class="explanation-text" id="mcq-explanation" style="display:none;">${convertMarkdownToHTML(question.explanation)}</div>` : ''}
                    </div>
                </div>
            `;
        }

        // 객관식 답변 체크
        function checkMCQAnswer(selectedIndex) {
            const question = shuffledStage3Questions[currentQuestionIndex];
            const { options, correctIndex } = question.selectedOptions;
            const buttons = document.querySelectorAll('.mcq-option-button');
            const isCorrect = selectedIndex === correctIndex;

            buttons.forEach((button, index) => {
                button.disabled = true;
                if (index === selectedIndex) {
                    button.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
                if (index === correctIndex && !isCorrect) {
                    button.classList.add('correct');
                }
            });

            if (isCorrect) {
                correctCount++;
                addTime(10);
            } else {
                wrongCount++;
                subtractTime(20);

                // 틀린 문제 저장
                stage3WrongQuestions.push({
                    question: question.text,
                    userAnswer: options[selectedIndex],
                    correctAnswer: options[correctIndex],
                    explanation: question.explanation || ''
                });

                // 설명 표시
                const explanation = document.getElementById('mcq-explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            setTimeout(() => {
                currentQuestionIndex++;
                document.getElementById('current-question').textContent = (currentQuestionIndex + 1).toString();

                if (currentQuestionIndex >= shuffledStage3Questions.length) {
                    endStage();
                } else {
                    showMCQQuestion();
                }
            }, 2000);
        }

        // 단계 종료
        function endStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const totalTime = Math.floor((endTime - startTime) / 1000);
            const minutes = Math.floor(totalTime / 60);
            const seconds = totalTime % 60;

            let totalQuestions = 0;
            if (currentStage === 1) {
                totalQuestions = STAGE1_QUESTIONS.length;
            } else if (currentStage === 2) {
                totalQuestions = shuffledStage2Questions.length;
            } else if (currentStage === 3) {
                totalQuestions = shuffledStage3Questions.length;
            }

            const accuracy = totalQuestions > 0 ? Math.round((correctCount / totalQuestions) * 100) : 100;
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산

            // 결과 저장 (레거시)
            allStageResults[`stage${currentStage}`] = {
                totalQuestions,
                correctCount,
                wrongCount,
                accuracy,
                totalTime
            };

            // 새로운 stageResults에 저장 (틀린 문제 포함)
            const wrongQuestionsArray = currentStage === 2 ? stage2WrongQuestions :
                                       currentStage === 3 ? stage3WrongQuestions : [];

            stageResults[`stage${currentStage}`] = {
                correct: correctCount,
                wrong: wrongCount,
                score: score,
                elapsedTime: totalTime,
                wrongQuestions: wrongQuestionsArray
            };

            // 결과 화면 표시
            document.getElementById('result-title').textContent = `${currentStage}단계 학습 완료!`;
            document.getElementById('progress-stat').textContent = '100%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = correctCount;
            document.getElementById('wrong-stat').textContent = wrongCount;
            document.getElementById('time-stat').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // 버튼 업데이트
            const resultButtons = document.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>';

            // Stage 2와 Stage 3의 경우 틀린 문제 보기 버튼 추가
            if (currentStage === 2 && stage2WrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button" style="background: #dc3545; color: white;" onclick="showWrongQuestionsStage2()">틀린 문제 보기 (${stage2WrongQuestions.length}문제)</button>`;
            } else if (currentStage === 3 && stage3WrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button" style="background: #dc3545; color: white;" onclick="showWrongQuestionsStage3()">틀린 문제 보기 (${stage3WrongQuestions.length}문제)</button>`;
            }

            // 다음 단계 버튼 (Stage 3이면 "전체 결과 보기")
            if (currentStage === 3) {
                buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            } else {
                buttonsHTML += '<button class="result-button primary" onclick="nextStage()">다음 단계로</button>';
            }

            resultButtons.innerHTML = buttonsHTML;

            document.getElementById('main-content').style.display = 'none';
            document.getElementById('result-screen').classList.add('active');
        }

        // 다시 학습하기
        function restartStage() {
            document.getElementById('main-content').style.display = 'block';
            document.getElementById('result-screen').classList.remove('active');

            if (currentStage === 1) {
                initStage1();
            } else if (currentStage === 2) {
                initStage2();
            } else if (currentStage === 3) {
                initStage3();
            }
        }

        // 다음 단계로
        function nextStage() {
            document.getElementById('main-content').style.display = 'block';

            if (currentStage === 1) {
                initStage2();
            } else if (currentStage === 2) {
                initStage3();
            } else if (currentStage === 3) {
                // 모든 단계 완료
                alert('모든 학습을 완료했습니다!');
                initStage1();
            }
        }

        // Stage 2 틀린 문제 보기
        function showWrongQuestionsStage2() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal-stage2')) {
                const modalHTML = `
                    <div id="wrong-questions-modal-stage2" class="modal-overlay">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>2단계: OX - 틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModalStage2()">✕</button>
                            </div>
                            <div class="modal-body" id="wrong-questions-content-stage2"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('wrong-questions-content-stage2');
            content.innerHTML = stage2WrongQuestions.map((item, index) => `
                <div class="wrong-question-item">
                    <h4>문제 ${index + 1}</h4>
                    <div class="question-text">${convertMarkdownToHTML(item.question)}</div>
                    <p><strong>당신의 답:</strong> <span class="user-answer">${convertMarkdownToHTML(item.userAnswer)}</span></p>
                    <p><strong>정답:</strong> <span class="correct-answer">${convertMarkdownToHTML(item.correctAnswer)}</span></p>
                    ${item.explanation ? `
                        <div class="question-explanation">
                            <strong>📝 해설</strong>
                            ${convertMarkdownToHTML(item.explanation)}
                        </div>
                    ` : ''}
                </div>
            `).join('');

            document.getElementById('wrong-questions-modal-stage2').classList.add('active');
        }

        // Stage 2 틀린 문제 모달 닫기
        function closeWrongQuestionsModalStage2() {
            document.getElementById('wrong-questions-modal-stage2').classList.remove('active');
        }

        // Stage 3 틀린 문제 보기
        function showWrongQuestionsStage3() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal-stage3')) {
                const modalHTML = `
                    <div id="wrong-questions-modal-stage3" class="modal-overlay">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>3단계: 객관식 - 틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModalStage3()">✕</button>
                            </div>
                            <div class="modal-body" id="wrong-questions-content-stage3"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('wrong-questions-content-stage3');
            content.innerHTML = stage3WrongQuestions.map((item, index) => `
                <div class="wrong-question-item">
                    <h4>문제 ${index + 1}</h4>
                    <div class="question-text">${convertMarkdownToHTML(item.question)}</div>
                    <p><strong>당신의 답:</strong> <span class="user-answer">${convertMarkdownToHTML(item.userAnswer)}</span></p>
                    <p><strong>정답:</strong> <span class="correct-answer">${convertMarkdownToHTML(item.correctAnswer)}</span></p>
                    ${item.explanation ? `
                        <div class="question-explanation">
                            <strong>📝 해설</strong>
                            ${convertMarkdownToHTML(item.explanation)}
                        </div>
                    ` : ''}
                </div>
            `).join('');

            document.getElementById('wrong-questions-modal-stage3').classList.add('active');
        }

        // Stage 3 틀린 문제 모달 닫기
        function closeWrongQuestionsModalStage3() {
            document.getElementById('wrong-questions-modal-stage3').classList.remove('active');
        }

        // 시간 포맷팅 함수
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 전체 결과 보기
        function showFinalResults() {
            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = stageResults.stage1.correct + stageResults.stage2.correct + stageResults.stage3.correct;
            const totalWrong = stageResults.stage1.wrong + stageResults.stage2.wrong + stageResults.stage3.wrong;
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = stageResults.stage1.score + stageResults.stage2.score + stageResults.stage3.score;
            const totalElapsedTime = stageResults.stage1.elapsedTime + stageResults.stage2.elapsedTime + stageResults.stage3.elapsedTime;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: OX 학습',
                stage3: '3단계: 객관식 학습'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 30.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(totalElapsedTime)}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 2와 Stage 3의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 2 틀린 문제
            if (stageResults.stage2.wrongQuestions && stageResults.stage2.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 2단계: OX - 틀린 문제</h3>
`;
                stageResults.stage2.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 3 틀린 문제
            if (stageResults.stage3.wrongQuestions && stageResults.stage3.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 3단계: 객관식 - 틀린 문제</h3>
`;
                stageResults.stage3.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 이미지로 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `한글맞춤법_제3장_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 페이지 로드 시 모달 드래그 설정 초기화
        window.onload = function() {
            // 모달 드래그 설정을 페이지 로드 시 한 번만 실행
            setupModalDrag();
            initStage1();
        };
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>