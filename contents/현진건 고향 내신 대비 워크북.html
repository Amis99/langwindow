<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>현진건 &lt;고향&gt; 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">현진건 &lt;고향&gt;</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                {
                    id: 1,
                    text: "이 작품은 1920년대 일제 강점기를 배경으로, 기차에서 우연히 만난 '나'와 '그'의 대화를 통해 당대 조선 농민들의 비참한 현실을 고발하는 _____입니다.",
                    highlight: "(단편 소설 / 장편 소설)",
                    options: ["단편 소설", "장편 소설"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "외부 이야기('나'와 '그'의 만남) 속에 내부 이야기('그'의 과거 회상)가 들어 있는 _____를 통해 '그' 개인의 비극을 민족 전체의 아픔으로 확장합니다.",
                    highlight: "(액자식 구성 / 옴니버스식 구성)",
                    options: ["액자식 구성", "옴니버스식 구성"],
                    correct: 0
                },
                {
                    id: 3,
                    text: "이 작품의 갈래는 단편 소설, _____ 소설, 액자 소설입니다.",
                    highlight: "(사실주의 / 낭만주의)",
                    options: ["사실주의", "낭만주의"],
                    correct: 0
                },
                {
                    id: 4,
                    text: "이 작품의 성격은 사실적, 고발적, _____입니다.",
                    highlight: "(민족주의적 / 개인주의적)",
                    options: ["민족주의적", "개인주의적"],
                    correct: 0
                },
                {
                    id: 5,
                    text: "공간적 배경: 대구에서 서울로 향하는 _____ 안",
                    highlight: "(기차 안 / 버스 안)",
                    options: ["기차 안", "버스 안"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "내화(내부 이야기)는 서술자인 '나'가 '그'에게 들은 이야기를 전달하는 _____ 시점입니다.",
                    highlight: "(전지적 작가 / 1인칭 주인공)",
                    options: ["전지적 작가", "1인칭 주인공"],
                    correct: 0
                },
                {
                    id: 7,
                    text: "주제: 일제 강점하 우리 민족의 _____과 고향 상실의 아픔",
                    highlight: "(비참한 삶 / 풍요로운 삶)",
                    options: ["비참한 삶", "풍요로운 삶"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "액자식 구성: '나'의 관찰과 '그'의 신세타령으로 이루어져, 이야기의 _____을 높임.",
                    highlight: "(사실성 / 비현실성)",
                    options: ["사실성", "비현실성"],
                    correct: 0
                },
                {
                    id: 9,
                    text: "사실주의: 토지 수탈, 유랑 등 1920년대 농촌의 현실을 _____으로 묘사함.",
                    highlight: "(구체적 / 추상적)",
                    options: ["구체적", "추상적"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "인물: 전형적 인물('그')을 통해 식민지 백성의 _____ 삶을 효과적으로 보여줌.",
                    highlight: "(보편적인 / 특수한)",
                    options: ["보편적인", "특수한"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "언어: 등장인물의 _____ 사용으로 생동감과 사실성을 부여함.",
                    highlight: "(사투리 / 표준어)",
                    options: ["사투리", "표준어"],
                    correct: 0
                },
                {
                    id: 12,
                    text: "상징: '그'의 기이한 옷차림, 폐허가 된 고향 등을 통해 주제를 _____으로 드러냄.",
                    highlight: "(암시적 / 직접적)",
                    options: ["암시적", "직접적"],
                    correct: 0
                },
                {
                    id: 13,
                    text: "'그'의 모습은 뿌리 뽑힌 유랑민의 모습을 _____",
                    highlight: "(상징하며 / 왜곡하며)",
                    options: ["상징하며", "왜곡하며"],
                    correct: 0
                },
                {
                    id: 14,
                    text: "'나'는 그에게서 처음에는 _____과 호기심을 동시에 느낀다.",
                    highlight: "(거부감 / 동질감)",
                    options: ["거부감", "동질감"],
                    correct: 0
                },
                {
                    id: 15,
                    text: "'그'의 고향은 원래 역둔토를 부치며 평화롭게 살던 마을이었으나, 땅이 모두 _____의 소유로 넘어가면서 삶이 피폐해진다.",
                    highlight: "(동양 척식 회사 / 개인 지주)",
                    options: ["동양 척식 회사", "개인 지주"],
                    correct: 0
                },
                {
                    id: 16,
                    text: "중간 소작인의 이중 수탈로 소작인들은 소출의 _____도 제대로 받지 못하게 되고, 마을 사람들은 고향을 떠나 뿔뿔이 흩어진다.",
                    highlight: "(3할 / 7할)",
                    options: ["3할", "7할"],
                    correct: 0
                },
                {
                    id: 17,
                    text: "이는 당시 일제의 _____이 농촌 사회를 어떻게 파괴했는지 보여주는 구체적인 사례이다.",
                    highlight: "(토지 수탈 정책 / 문화 통치 정책)",
                    options: ["토지 수탈 정책", "문화 통치 정책"],
                    correct: 0
                },
                {
                    id: 18,
                    text: "'그'의 가족 역시 9년 전, 살기 좋다는 말을 듣고 희망을 품고 _____으로 이주한다.",
                    highlight: "(서간도 / 일본)",
                    options: ["서간도", "일본"],
                    correct: 0
                },
                {
                    id: 19,
                    text: "하지만 그곳의 삶도 녹록지 않아 아버지와 어머니가 연이어 _____로 돌아가시는 비극을 겪는다.",
                    highlight: "(병과 영양실조 / 사고)",
                    options: ["병과 영양실조", "사고"],
                    correct: 0
                },
                {
                    id: 20,
                    text: "'그'의 가족사는 개인의 불행을 넘어, 당시 유랑하던 우리 민족이 겪어야 했던 _____ 고난을 대표한다.",
                    highlight: "(보편적인 / 예외적인)",
                    options: ["보편적인", "예외적인"],
                    correct: 0
                },
                {
                    id: 21,
                    text: "이후 '그'는 일본의 탄광, 철공장 등을 떠돌며 _____ 삶을 이어간다.",
                    highlight: "(방랑하는 / 정착하는)",
                    options: ["방랑하는", "정착하는"],
                    correct: 0
                },
                {
                    id: 22,
                    text: "'그'는 울화와 그리움에 9년 만에 고향을 찾아가지만, 마을은 집도 사람도 없이 완전히 _____가 된 상태였다.",
                    highlight: "(폐허 / 현대화)",
                    options: ["폐허", "현대화"],
                    correct: 0
                },
                {
                    id: 23,
                    text: "'그'는 \"썩어 넘어진 서까래, 풀풀 구르는 주추는! 꼭 무덤을 파서 해골을 헐어 젖혀 놓은 것 같더마.\"라고 말하며, 고향의 모습에서 _____의 이미지를 떠올린다.",
                    highlight: "(죽음 / 희망)",
                    options: ["죽음", "희망"],
                    correct: 0
                },
                {
                    id: 24,
                    text: "이는 단순한 물리적 공간의 파괴를 넘어, 우리 민족의 삶의 터전과 _____가 완전히 파괴되었음을 의미한다.",
                    highlight: "(공동체 / 개인 재산)",
                    options: ["공동체", "개인 재산"],
                    correct: 0
                },
                {
                    id: 25,
                    text: "'그'의 비참한 이야기에 '나'는 술을 건네며 위로한다. 술은 '나'의 _____을 보여주는 소재이다.",
                    highlight: "(연민과 공감 / 무관심과 경계)",
                    options: ["연민과 공감", "무관심과 경계"],
                    correct: 0
                },
                {
                    id: 26,
                    text: "'그'가 흘리는 눈물 속에서 '나'는 '음산하고 비참한 _____'을 발견한다.",
                    highlight: "(조선의 얼굴 / 개인의 슬픔)",
                    options: ["조선의 얼굴", "개인의 슬픔"],
                    correct: 0
                },
                {
                    id: 27,
                    text: "이 장면을 통해 서술자 '나'는 '그'의 개인적 비극이 곧 _____ 전체의 비극임을 깨닫고, 주제 의식을 명확하게 드러낸다.",
                    highlight: "(우리 민족 / 특정 계층)",
                    options: ["우리 민족", "특정 계층"],
                    correct: 0
                }
            ],
            fullText: `## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**

본격적인 작품 분석에 앞서, 현진건의 <고향>이 어떤 작품인지 핵심적인 특징들을 먼저 알아봅시다.

**[작품 해제]** 이 작품은 1920년대 일제 강점기를 배경으로, 기차에서 우연히 만난 '나'와 '그'의 대화를 통해 당대 조선 농민들의 비참한 현실을 고발하는 (단편 소설 / 장편 소설)입니다. 특히 외부 이야기('나'와 '그'의 만남) 속에 내부 이야기('그'의 과거 회상)가 들어 있는 (액자식 구성 / 옴니버스식 구성)을 통해 '그' 개인의 비극을 민족 전체의 아픔으로 확장하며 사실성과 보편성을 획득하고 있습니다.

**[핵심 정리 표]**

| 구분 | 내용 |
| :---- | :---- |
| **갈래** | 단편 소설, (사실주의 / 낭만주의) 소설, 액자 소설 |
| **성격** | 사실적, 고발적, (민족주의적 / 개인주의적) |
| **배경** | 시간적: 1920년대 일제 강점기 공간적: 대구에서 서울로 향하는 (기차 안 / 버스 안) |
| **시점** | 외화(외부 이야기): 1인칭 관찰자 시점 내화(내부 이야기): (전지적 작가 / 1인칭 주인공) 시점 (서술자인 '나'가 '그'에게 들은 이야기를 전달) |
| **주제** | 일제 강점하 우리 민족의 (비참한 삶 / 풍요로운 삶)과 고향 상실의 아픔 |
| **특징** | 1. 액자식 구성: '나'의 관찰과 '그'의 신세타령으로 이루어져, 이야기의 (사실성 / 비현실성)을 높임. 2. 사실주의: 토지 수탈, 유랑 등 1920년대 농촌의 현실을 (구체적 / 추상적)으로 묘사함. 3. 인물: 전형적 인물('그')을 통해 식민지 백성의 (보편적인 / 특수한) 삶을 효과적으로 보여줌. 4. 언어: 등장인물의 (사투리 / 표준어) 사용으로 생동감과 사실성을 부여함. 5. 상징: '그'의 기이한 옷차림, 폐허가 된 고향 등을 통해 주제를 (암시적 / 직접적)으로 드러냄. |

**[전체 줄거리 및 출제 포인트]**

**[외화] 발단: '나'와 '그'의 만남**

* '나'는 대구에서 서울로 가는 기차 안에서 조선, 중국, 일본의 옷을 뒤섞어 입은 기이한 차림의 '그'를 만난다. '그'의 모습은 뿌리 뽑힌 유랑민의 모습을 (상징하며 / 왜곡하며), '나'는 그에게서 처음에는 (거부감 / 동질감)과 호기심을 동시에 느낀다.

**[내화 1] 전개-위기: '그'의 과거 (수탈과 유랑)**

* '그'의 고향은 원래 역둔토를 부치며 평화롭게 살던 마을이었으나, 땅이 모두 (동양 척식 회사 / 개인 지주)의 소유로 넘어가면서 삶이 피폐해진다.
* 중간 소작인의 이중 수탈로 소작인들은 소출의 (3할 / 7할)도 제대로 받지 못하게 되고, 마을 사람들은 고향을 떠나 뿔뿔이 흩어진다. 이는 당시 일제의 (토지 수탈 정책 / 문화 통치 정책)이 농촌 사회를 어떻게 파괴했는지 보여주는 구체적인 사례이다.
* '그'의 가족 역시 9년 전, 살기 좋다는 말을 듣고 희망을 품고 (서간도 / 일본)으로 이주한다.
* 하지만 그곳의 삶도 녹록지 않아 아버지와 어머니가 연이어 (병과 영양실조 / 사고)로 돌아가시는 비극을 겪는다. '그'의 가족사는 개인의 불행을 넘어, 당시 유랑하던 우리 민족이 겪어야 했던 (보편적인 / 예외적인) 고난을 대표한다.
* 이후 '그'는 일본의 탄광, 철공장 등을 떠돌며 (방랑하는 / 정착하는) 삶을 이어간다.

**[내화 2] 절정: 폐허가 된 고향**

* '그'는 울화와 그리움에 9년 만에 고향을 찾아가지만, 마을은 집도 사람도 없이 완전히 (폐허 / 현대화)가 된 상태였다.
* '그'는 "썩어 넘어진 서까래, 풀풀 구르는 주추는! 꼭 무덤을 파서 해골을 헐어 젖혀 놓은 것 같더마."라고 말하며, 고향의 모습에서 (죽음 / 희망)의 이미지를 떠올린다. 이는 단순한 물리적 공간의 파괴를 넘어, 우리 민족의 삶의 터전과 (공동체 / 개인 재산)가 완전히 파괴되었음을 의미한다.

**[외화] 결말: 공감과 민족적 비애**

* '그'의 비참한 이야기에 '나'는 술을 건네며 위로한다. 술은 '나'의 (연민과 공감 / 무관심과 경계)을 보여주는 소재이다.
* '그'가 흘리는 눈물 속에서 '나'는 '음산하고 비참한 (조선의 얼굴 / 개인의 슬픔)'을 발견한다.
* 이 장면을 통해 서술자 '나'는 '그'의 개인적 비극이 곧 (우리 민족 / 특정 계층) 전체의 비극임을 깨닫고, 주제 의식을 명확하게 드러낸다.`
        };

        // 2단계: 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "동양 척식 회사",
                meaning: "1908년 일제가 조선의 토지와 자원을 수탈할 목적으로 세운 국책 회사.",
                type: "개념",
                confusors: {
                    word: ["조선 총독부", "식산은행", "동아일보사"],
                    meaning: ["1910년 일제가 조선을 식민 통치하기 위해 설치한 최고 기관.", "1918년 일제가 조선의 농공업 발전 명목으로 설립한 금융 기관.", "1920년 조선인들이 민족 언론을 위해 창간한 신문사."]
                }
            },
            {
                word: "역둔토(驛屯土)",
                meaning: "조선 시대, 각 역(驛)에 속하여 경비를 충당하던 토지.",
                type: "개념",
                confusors: {
                    word: ["궁방전(宮房田)", "둔전(屯田)", "사패지(賜牌地)"],
                    meaning: ["조선 시대, 왕실 소유로 궁방의 경비를 충당하던 농토.", "조선 시대, 군사 훈련과 식량 확보를 위해 운영하던 토지.", "조선 시대, 공신이나 관료에게 하사한 사유지."]
                }
            },
            {
                word: "중간 소작인",
                meaning: "소작권을 가진 지주와 실제 농사를 짓는 소작인 사이에서 중개하는 사람.",
                type: "개념",
                confusors: {
                    word: ["실작인", "마름", "지주"],
                    meaning: ["실제로 농사를 직접 짓는 소작인.", "지주를 대신하여 농사와 소작료를 관리하는 사람.", "땅을 소유하고 소작인에게 빌려주는 사람."]
                }
            },
            {
                word: "실작인",
                meaning: "실제 농사를 짓는 소작인.",
                type: "개념",
                confusors: {
                    word: ["중간 소작인", "마름", "소작료"],
                    meaning: ["지주와 실작인 사이에서 중개하는 사람.", "지주를 대신하여 농사를 감독하는 관리인.", "소작인이 지주에게 내는 지대."]
                }
            },
            {
                word: "소출",
                meaning: "수확한 농작물.",
                type: "개념",
                confusors: {
                    word: ["소작료", "작황", "추수"],
                    meaning: ["소작인이 지주에게 내는 지대나 소작 대금.", "농작물이 자라는 상태나 수확의 정도.", "익은 곡식이나 과일 따위를 거두어들임."]
                }
            },
            {
                word: "전야",
                meaning: "논과 밭으로 이루어진 들.",
                type: "개념",
                confusors: {
                    word: ["평야", "농경지", "황무지"],
                    meaning: ["넓고 평평하게 펼쳐진 들판.", "농사를 짓는 데 사용되는 땅.", "개간하지 않아 거칠고 황폐한 땅."]
                }
            },
            {
                word: "주추",
                meaning: "기둥 밑에 기초로 받쳐 놓은 돌.",
                type: "개념",
                confusors: {
                    word: ["상인방", "대들보", "추녀"],
                    meaning: ["기둥 위에 가로로 걸쳐 놓은 나무.", "지붕의 무게를 받치는 가장 큰 나무.", "처마의 네 귀에서 45도 각도로 뻗어 나온 나무."]
                }
            },
            {
                word: "서까래",
                meaning: "지붕의 골격을 이루며 도리를 받치는 나무.",
                type: "개념",
                confusors: {
                    word: ["도리", "대들보", "기둥"],
                    meaning: ["서까래를 받치기 위해 가로로 건 나무.", "지붕의 무게를 받치는 가장 큰 나무.", "건물의 무게를 지탱하는 세로 나무."]
                }
            },
            {
                word: "유리(流離)",
                meaning: "한곳에 정착하여 살지 못하고 이리저리 떠돌아다님.",
                type: "상황",
                confusors: {
                    word: ["정착(定着)", "이주(移住)", "체류(滯留)"],
                    meaning: ["일정한 곳에 자리를 잡고 머물러 삶.", "다른 지역으로 거처를 옮겨 가서 삶.", "일정한 곳에 머물러 떠나지 아니함."]
                }
            },
            {
                word: "쇠진(衰盡)",
                meaning: "몸과 마음이 지쳐 쇠약해짐.",
                type: "상황",
                confusors: {
                    word: ["분발(奮發)", "매진(邁進)", "활력(活力)"],
                    meaning: ["정신을 가다듬어 힘을 냄.", "힘써 나아감.", "활동하는 힘이나 기운."]
                }
            },
            {
                word: "악착(齷齪)",
                meaning: "매우 모질고 끈덕진. 또는 그런 것.",
                type: "정서",
                confusors: {
                    word: ["나태(懶怠)", "나약(懦弱)", "우유부단(優柔不斷)"],
                    meaning: ["게으름을 피우며 할 일을 하지 아니함.", "의지가 약하고 굳세지 못함.", "결단력이 없어 행동이 분명하지 못함."]
                }
            },
            {
                word: "주접",
                meaning: "하는 일 없이 빌붙어 지냄. 또는 그런 사람.",
                type: "상황",
                confusors: {
                    word: ["자립(自立)", "독립(獨立)", "자활(自活)"],
                    meaning: ["남에게 의존하지 않고 스스로 섬.", "남에게 예속되거나 의존하지 않고 자기 힘으로 섬.", "스스로의 힘으로 생활함."]
                }
            },
            {
                word: "음산(陰散)",
                meaning: "음침하고 스산한.",
                type: "정서",
                confusors: {
                    word: ["명랑(明朗)", "화창(和暢)", "쾌활(快活)"],
                    meaning: ["밝고 맑은.", "날씨가 따뜻하고 맑은.", "성격이 밝고 활발한."]
                }
            },
            {
                word: "폐농(廢農)",
                meaning: "마을의 농사일이 모두 망하여 황폐하게 됨.",
                type: "상황",
                confusors: {
                    word: ["황폐화(荒廢化)", "파산(破産)", "몰락(沒落)"],
                    meaning: ["토지나 지역이 거칠고 쓸쓸하게 망가짐.", "재산을 다 잃고 경제적으로 파탄남.", "높은 지위나 생활이 무너져 내림."]
                }
            },
            {
                word: "남부여대(男負女戴)",
                meaning: "남자는 지고 여자는 인다는 뜻으로, 가난한 사람들이 살 곳을 찾아 떠돌아다님을 이르는 말.",
                type: "한자성어",
                confusors: {
                    word: ["유리걸식(流離乞食)", "가산탕진(家産蕩盡)", "이산가족(離散家族)"],
                    meaning: ["떠돌아다니며 빌어먹는다는 뜻으로, 집 없이 떠돌며 구걸하는 것을 이르는 말.", "집안의 재산을 모두 탕진하여 없앤다는 뜻으로, 살림을 망치는 것을 이르는 말.", "전쟁이나 재난으로 가족이 뿔뿔이 흩어진 것을 이르는 말."]
                }
            },
            {
                word: "서간도",
                meaning: "만주 지역의 서쪽 지역. 일제 강점기 조선인들이 이주한 지역.",
                type: "개념",
                confusors: {
                    word: ["북간도", "만주", "연변"],
                    meaning: ["만주 지역의 북쪽 지역. 두만강 북쪽 일대를 가리킴.", "중국 동북부 지역의 옛 명칭. 현재 랴오닝, 지린, 헤이룽장성 일대.", "중국 지린성 동부의 조선족 자치주. 조선인 이주민이 많이 거주."]
                }
            },
            {
                word: "규슈",
                meaning: "일본의 남서쪽에 위치한 큰 섬. 탄광이 많았던 지역.",
                type: "개념",
                confusors: {
                    word: ["혼슈", "홋카이도", "시코쿠"],
                    meaning: ["일본의 가장 큰 섬. 도쿄, 오사카 등 주요 도시가 위치함.", "일본의 최북단 섬. 삿포로가 있으며 추운 기후가 특징.", "일본의 네 개 주요 섬 중 가장 작은 섬. 시코쿠 지방을 형성."]
                }
            },
            {
                word: "오사카",
                meaning: "일본의 주요 공업 도시. 일제 강점기 조선인 노동자가 많이 일했던 곳.",
                type: "개념",
                confusors: {
                    word: ["도쿄", "교토", "고베"],
                    meaning: ["일본의 수도. 정치, 경제, 문화의 중심지로 가장 큰 도시.", "일본의 옛 수도. 전통 문화와 유적이 많이 남아 있는 역사 도시.", "일본 효고현의 항구 도시. 무역과 해운업이 발달한 곳."]
                }
            }
        ];

        // 3단계 문장 독해 데이터
        const sentenceData = [
    {
        sentence: "저는 손에 흙 한번 만져 보지도 않고 동척엔 소작인 노릇을 하며 실작인에게는 지주 행세를 하게 되었다.",
        question: "이 문장에서 부당한 이익을 취하는 '저'는 누구인가?",
        correctAnswer: "중간 소작인",
        distractors: ["동양 척식 회사의 직원", "땅을 직접 경작하는 실작인", "토지를 소유한 일본인 지주"]
    },
    {
        sentence: "동척에 소작료를 물고 나서 또 중간 소작인에게 긁히고 보니, 실작인의 손에는 소출의 삼 할도 떨어지지 않았다.",
        question: "'실작인'의 손에 수확물의 30%도 남지 않게 된 원인은 무엇인가?",
        correctAnswer: "동양 척식 회사와 중간 소작인에게 이중으로 수탈당했기 때문",
        distractors: ["날씨가 좋지 않아 농사 수확량이 크게 줄어들었기 때문", "농사 기술과 경험이 부족하여 생산량이 적었기 때문", "농토가 척박하여 애초에 수확량 자체가 적었기 때문"]
    },
    {
        sentence: "그 후로 '죽겠다', '못 살겠다' 하는 소리는 중이 염불하듯 그들의 입길에서 오르내리게 되었다.",
        question: "'그들'이 '죽겠다'는 말을 입에 달고 살게 된 근본적인 이유는 무엇인가?",
        correctAnswer: "동척과 중간 소작인의 이중 수탈로 생계 유지가 불가능했기 때문",
        distractors: ["마을 전체에 전염병이 크게 돌아 생명을 위협받았기 때문", "가뭄과 홍수가 반복되어 여러 해 동안 흉년이 계속되었기 때문", "마을 사람들 사이의 갈등과 불화로 공동체가 무너졌기 때문"]
    },
    {
        sentence: "쫓겨 가는 운명이거든 어디를 간들 신신하랴.",
        question: "이 문장이 의미하는 바는 무엇인가?",
        correctAnswer: "어디를 가더라도 처지가 나아지지 않을 것이라는 비관적 예측",
        distractors: ["새로운 곳으로 가면 더 나은 삶이 기다릴 것이라는 희망적 기대", "고향을 절대로 떠나서는 안 된다는 강한 충고와 경고", "운명을 거스를 수 없으니 순응하며 살아야 한다는 체념"]
    },
    {
        sentence: "조금 좋은 땅은 먼저 간 이가 모조리 차지를 하였고 황무지는 비록 많다 하나 그곳 당도하던 날부터 아침거리 저녁거리 걱정이라...",
        question: "'그'의 가족이 서간도에서 황무지를 개간하지 못한 이유는 무엇인가?",
        correctAnswer: "당장 끼니를 해결하기도 어려워 장기적 투자가 불가능했기 때문",
        distractors: ["황무지의 토질이 너무 척박하여 개간해도 농사가 불가능했기 때문", "중국 관헌으로부터 황무지 개간에 대한 허가를 받지 못했기 때문", "개간에 필요한 농기구와 도구를 전혀 구할 수 없었기 때문"]
    },
    {
        sentence: "열아홉 살밖에 안 된 그가 홀어머니를 모시고 악으로 악으로 모진 목숨을 이어 가는 중 사 년이 못 되어 영양 부족한 몸이 심한 노동에 지친 탓으로 그의 어머니 또한 죽고 말았다.",
        question: "'그의 어머니'가 돌아가시게 된 직접적인 원인은 무엇인가?",
        correctAnswer: "영양 부족과 심한 노동",
        distractors: ["전염병 감염과 추운 날씨", "농사일 중의 사고와 부상", "고향에 대한 그리움과 우울증"]
    },
    {
        sentence: "악착한 운명이 던져 준 깊은 슬픔을 술로 녹이려는 듯이 연거푸 다섯 잔을 마신 그는 다시 말을 계속하였다.",
        question: "그가 술을 마신 이유는 무엇이라고 서술자는 추측하고 있는가?",
        correctAnswer: "운명이 준 깊은 슬픔을 술로 잊거나 해소하려고",
        distractors: ["술에 취해 고통스러운 이야기를 중단하려고", "'나'에게 술을 대접받은 것에 대한 감사 표시로", "추운 날씨 때문에 몸을 따뜻하게 녹이려고"]
    },
    {
        sentence: "고향에 가시니 반가워하는 사람이 있습니까?",
        question: "이 질문에 담긴 '나'의 마음은 무엇인가?",
        correctAnswer: "'그'의 불행한 이야기에 공감하며 그를 안타깝게 여기는 마음",
        distractors: ["고향에 남아 있는 사람들이 누구인지에 대한 단순한 호기심", "'그'가 하는 이야기의 진실성을 의심하며 확인하려는 마음", "'그'와의 대화를 빨리 끝내고 떠나보내고 싶은 불편한 마음"]
    },
    {
        sentence: "썩어 넘어진 서까래, 풀풀 구르는 주추는! 꼭 무덤을 파서 해골을 헐어 젖혀 놓은 것 같더마.",
        question: "이러한 비유를 통해 알 수 있는 '그'의 심정은 어떠한가?",
        correctAnswer: "고향 상실에 대한 충격과 참담함과 절망감",
        distractors: ["고향이 어떻게 변했는지에 대한 강한 호기심", "폐허가 된 고향에서 새롭게 시작하려는 기대감", "고통스러운 과거의 기억을 완전히 잊고 싶은 마음"]
    },
    {
        sentence: "나는 그 눈물 가운데 음산하고 비참한 조선의 얼굴을 똑똑히 본 듯싶었다.",
        question: "'조선의 얼굴'은 구체적으로 무엇을 상징하는가?",
        correctAnswer: "일제 강점하에서 수탈당하고 고통받는 우리 민족의 비참한 현실",
        distractors: ["'그' 한 개인이 겪은 불행하고 슬픈 과거와 삶의 궤적", "서간도로 떠나 이주한 조선인들이 겪는 고난과 어려운 처지", "조선의 농촌 사회에 만연한 가난하고 피폐한 생활상"]
    },
    {
        sentence: "그 신세도 내 신세만이나 하구먼.",
        question: "이 대화를 통해 알 수 있는 두 인물의 공통적인 처지는 무엇인가?",
        correctAnswer: "둘 다 가난 때문에 고향을 떠나 비참한 삶을 살고 있다",
        distractors: ["둘 다 일본인이 운영하는 집에서 고용살이를 하고 있다", "둘 다 서울로 올라가 새로운 일자리를 찾으러 가는 중이다", "둘 다 전쟁과 이별로 인해 가족을 모두 잃어버렸다"]
    },
    {
        sentence: "인물이나 좋은 계집은 유곽으로 가고요...",
        question: "이 구절은 당시 여성이 겪어야 했던 어떤 비극적인 현실을 보여주는가?",
        correctAnswer: "가난으로 인해 인격과 존엄성을 잃고 성적으로 착취당해야 했던 현실",
        distractors: ["여성들이 학교에 다니며 교육을 받을 기회가 원천적으로 차단되었던 현실", "여성들이 정치에 참여하거나 투표권을 행사할 수 없었던 제도적 현실", "여성들이 원하는 직업을 자유롭게 선택할 권리가 없었던 사회적 현실"]
    }
        ];

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            renderPassage();
            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 마크다운 처리 (하이라이트 처리 전에 먼저 실행)
            // 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (마크다운 테이블을 HTML 테이블로 변환)
            const tableRegex = /^\|.+\|$/gm;
            const tableMatches = [];
            let match;
            while ((match = tableRegex.exec(html)) !== null) {
                tableMatches.push(match.index);
            }

            if (tableMatches.length > 0) {
                // 테이블 라인들을 찾아서 그룹화
                let i = 0;
                while (i < tableMatches.length) {
                    let tableStart = tableMatches[i];
                    let tableEnd = tableMatches[i];
                    let j = i + 1;

                    // 연속된 테이블 라인 찾기
                    while (j < tableMatches.length && tableMatches[j] - tableEnd < 100) {
                        tableEnd = tableMatches[j];
                        j++;
                    }

                    // 테이블 텍스트 추출
                    let beforeTable = html.substring(0, tableStart);
                    let afterTable = html.substring(tableEnd + html.substring(tableEnd).indexOf('\n') + 1);
                    let tableText = html.substring(tableStart, tableEnd + html.substring(tableEnd).indexOf('\n'));

                    const lines = tableText.split('\n').filter(line => line.trim().startsWith('|'));

                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0;">';
                    let rowIndex = 0;

                    lines.forEach((line) => {
                        // 구분선 스킵
                        if (line.match(/^\|\s*:?-+:?\s*\|/)) return;

                        const cells = line.split('|').slice(1, -1); // 첫번째와 마지막 빈 요소 제거
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f8f9fa; font-weight: 600;' : '';

                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<${tag} style="border: 1px solid #ddd; padding: 12px; text-align: left; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHTML += '</tr>';
                        rowIndex++;
                    });

                    tableHTML += '</table>';
                    html = beforeTable + tableHTML + afterTable;

                    i = j;
                }
            }

            // 볼드 처리
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                return `<div class="subsection">• ${content}</div>`;
            });

            // 하이라이트 처리 (마지막에 실행 - HTML 변환된 내용에 적용)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            // 2단계 어휘 학습으로 전환
            currentStage = 2;
            initStage2();
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // 단어 → 뜻 문제
                const wordToMeaning = {
                    type: 'word-to-meaning',
                    question: `"${vocab.word}"의 의미는?`,
                    correct: vocab.meaning,
                    word: vocab.word,
                    options: shuffleArray([
                        vocab.meaning,
                        ...vocab.confusors.meaning.slice(0, 3)
                    ])
                };

                // 뜻 → 단어 문제
                const meaningToWord = {
                    type: 'meaning-to-word',
                    question: `"${vocab.meaning}"를 나타내는 용어는?`,
                    correct: vocab.word,
                    meaning: vocab.meaning,
                    options: shuffleArray([
                        vocab.word,
                        ...vocab.confusors.word.slice(0, 3)
                    ])
                };

                stage2Data.questions.push(wordToMeaning, meaningToWord);
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장과 질문 표시
            document.getElementById('sentence-text').textContent = question.sentence;
            document.getElementById('sentence-question').textContent = `Q. ${question.question}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }

        // ================== 4단계: OX퀴즈 ==================
        const stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],  // 틀린 문제 저장
            startTime: null,
            timeRemaining: 120
        };

        // OX퀴즈 데이터
        const oxQuizData = [
    { question: "'그'는 '나'에게 술을 따라 주며 자신의 신세를 한탄하기 시작했다.", answer: false, explanation: "술을 따라 준 주체는 '나'이지 '그'가 아닙니다. 행위의 주체를 바꾸어 사실 관계를 왜곡했습니다." },
    { question: "'그'의 고향 마을 사람들은 동양 척식 회사의 등장 이후에도 역둔토 덕분에 평화롭게 살 수 있었다.", answer: false, explanation: "동양 척식 회사의 등장 이후, 마을 사람들의 삶은 수탈로 인해 완전히 파괴되었습니다." },
    { question: "'그'의 가족은 서간도의 생활이 너무 비참했기 때문에 결국 뿔뿔이 흩어지고 말았다.", answer: true, explanation: "" },
    { question: "'그'는 일본의 탄광과 철공장에서 일하며 타지를 떠돌았다.", answer: true, explanation: "" },
    { question: "'그'는 폐허가 된 고향의 모습에서 앞으로의 희망을 발견하고 서울로 향하는 길이었다.", answer: false, explanation: "'그'는 폐허가 된 고향에서 '무덤', '해골'과 같은 절망과 죽음의 이미지를 떠올렸습니다." },
    { question: "서술자 '나'는 '그'와 함께 서간도로 가서 그의 부모님 산소를 돌보았다.", answer: false, explanation: "'나'는 기차 안에서 '그'의 이야기를 듣고 있을 뿐, 그의 과거(내화)에 직접 참여한 사실이 없습니다." },
    { question: "서술자 '나'는 '그'의 눈물에서 식민지 조선의 비참한 현실을 떠올렸다.", answer: true, explanation: "" },
    { question: "'나'가 '그'에게 정종을 따라 준 것은 그의 이야기를 그만 듣고 싶다는 의사를 표현하기 위함이었다.", answer: false, explanation: "'나'가 '그'에게 술을 준 것은 그의 비극적인 이야기에 공감하고 연민을 느껴 위로하기 위한 행동입니다." },
    { question: "'그'의 고향 마을은 9년 만에 사람이 살지 않는 폐허로 변해 있었다.", answer: true, explanation: "" },
    { question: "'그'의 어머니는 서간도로 이주한 직후에 돌아가셨고, 그 후에 아버지가 돌아가셨다.", answer: false, explanation: "아버지가 먼저 돌아가셨고, 그 후에 어머니가 돌아가셨습니다. 사건의 선후 관계를 뒤집었습니다." },
    { question: "중간 소작인은 실제로 농사를 짓지 않으면서 실작인들을 착취하여 이익을 얻었다.", answer: true, explanation: "" },
    { question: "'그'가 고향에서 만난 옛 여인은 유곽에 팔려 갔다가 돌아와 현재는 '그'와 함께 살고 있다.", answer: false, explanation: "옛 여인이 유곽에 다녀온 것은 사실이지만, '그'와 함께 산다는 내용은 없습니다." },
    { question: "'그'의 기이한 옷차림은 조선, 중국, 일본을 떠돌아다닌 그의 유랑 생활을 암시한다.", answer: true, explanation: "" },
    { question: "'그'의 아버지는 '그'에게 '흰 죽 한 모금 못 자셨구마.'라는 유언을 남기고 돌아가셨다.", answer: false, explanation: "해당 대사는 '그'가 '나'에게 자신의 어머니가 돌아가실 때의 상황을 설명하는 말입니다." },
    { question: "'그'는 일본에서의 노동 생활을 통해 많은 돈을 모아 고향으로 금의환향하는 길이었다.", answer: false, explanation: "일본에서의 삶은 '방탕해졌다', '돈을 모을 수 없었다'고 서술되며, 고향은 폐허가 되었습니다." },
    { question: "'나'는 '그'의 이야기에 점차 동정심과 연민을 느끼게 된다.", answer: true, explanation: "" },
    { question: "'그'의 고향 마을이 폐허가 된 것은 마을 사람들끼리의 불화 때문이었다.", answer: false, explanation: "마을이 파괴된 근본적인 원인은 동양 척식 회사를 앞세운 일제의 토지 수탈 정책입니다." },
    { question: "'그'가 부르는 노래의 내용은 땅을 되찾고 친구들과 재회하는 희망적인 미래를 담고 있다.", answer: false, explanation: "노래의 내용은 전토는 신작로가 되고 친구는 감옥에 가는 등 모든 것을 상실하는 절망적 현실을 담고 있습니다." },
    { question: "'그'는 고향을 떠나 서간도로 갈 때만 해도 살기 좋아질 것이라는 기대를 가지고 있었다.", answer: true, explanation: "" },
    { question: "'그'는 고향에서 만난 옛 여인과 결혼하여 새로운 삶을 시작하기로 약속했다.", answer: false, explanation: "'그'는 옛 여인과 만나 서로의 처지를 한탄했을 뿐, 결혼을 약속하는 등 새로운 미래를 기약하는 일은 없었습니다." }
        ];

        // 4단계 초기화
        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '현진건 <고향>';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 4';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 진짜 원문 표시
            const originalText = `대구에서 서울로 올라오는 차중에서 생긴 일이다. 나는 나와 마주 앉은 그를 매우 흥미있게 바라보고 또 바라보았다. 두루마기 격으로 기모노를 둘렀고, 그 안에서 옥양목 저고리가 내어 보이며 아랫도리엔 중국식 바지를 입었다. 그것은 그네들이 흔히 입는 유지 모양으로 번질번질한 암갈색 피륙으로 지은 것이었다. 그리고 발은 감발을 하였는데 짚신을 신었고, 고무가리로 깎은 머리엔 모자도 쓰지 않았다. 우연히 이따금 기묘한 모임을 꾸민 것이다. 우리가 자리를 잡은 찻간에는 공교롭게 세 나라 사람이 다 모였으니, 내 옆에는 중국 사람이 기대었다. 그의 옆에는 일본 사람이 앉아 있었다. 그는 동양 삼국옷을 한몸에 감은 보람이 있어 일본말도 곧잘 철철 대이거니와 중국말에도 그리 서툴지 않은 모양이었다.

"고꼬마데 오이데 데스까?(어디까지 가십니까?)"하고 첫마디를 걸더니만, 도꼬가 어떠니, 오사까가 어떠니, 조선 사람은 고추를 끔찍이 많이 먹는다는 둥, 일본 음식은 너무 싱거워서 처음에는 속이 뉘엿걸다는 둥, 횡설수설 지껄이다가 일본 사람이 엄지와 검지 손가락으로 짧게 끊은 꼿꼿한 윗수염을 비비면서 마지못해 까땍까땍하는 고개와 함께 "소데스까(그렇습니까)"란 한 마디로 코대답을 할 따름이요, 잘 받아 주지 않으매, 그는 또 중국인을 붙들고서 실랑이를 하였다. "니상나열취……" "니싱섬마"하고 덤벼 보았으나 중국인 또한 그 기름낀 뚜우한 얼굴에 수수께끼 같은 웃음을 띨 뿐이요 별로 대구를 하지 않았건만, 그래도 무어라고 연해 웅얼거리면서 나를 보고 웃어 보였다.

그것은 마치 짐승을 놀리는 요술장이가 구경꾼을 바라볼 때처럼 훌륭한 재주를 갈채해 달라는 웃음이었다. 나는 쌀쌀하게 그의 시선을 피해 버렸다. 그 주적대는 꼴이 어줍지 않고 밉살스러웠다. 그는 잠깐 입을 닫치고 무료한 듯이 머리를 덕억덕억 긁기도 하며, 손톱을 이로 물어뜯기도 하고, 멀거니 창 밖을 내다보기도 하다가, 암만해도 중절대지 않고는 못 참겠던지 문득 나에게로 향하며, "어디꺼정 가는 기오?"라고 경상도 사투리로 말을 붙인다.

"서울까지 가요."

"그런기오. 참 반갑구마. 나도 서울꺼정 가는데. 그러면 우리 동행이 되겠구마."

나는 이 지나치게 반가와하는 말씨에 대하여 무어라고 대답할 말도 없고, 또 굳이 대답하기도 싫기에 덤덤히 입을 닫쳐 버렸다.

"서울에 오래 살았는기요?" 그는 또 물었다.

"육칠년이나 됩니다." 조금 성가시다 싶었으되, 대꾸 않을 수도 없었다.

"에이구, 오래 살았구마, 나는 처음길인데 우리 같은 막벌이군이 차를 내려서 어디로 찾아가야 되겠는기요? 일본으로 말하면 기전야도 같은 것이 있는기오?"

하고 그는 답답한 제 신세를 생각했던지 찡그려 보았다. 그때 나는 그의 얼굴이 웃기보다 찡그리기에 가장 적당한 얼굴임을 발견하였다. 군데군데 찢어진 겅성드뭇한 눈썹이 올올이 일어서며, 아래로 축 처지는 서슬에 양미간에는 여러 가닥 주름이 잡히고, 광대뼈 위로 뺨살이 실룩실룩 보이자 두 볼은 쪽 빨아든다. 입은 소태나 먹은 것처럼 왼편으로 삐뚤어지게 찢어 올라가고, 죄던 눈엔 눈물이 괸 듯 삼십 세밖에 안되어 보이는 그 얼굴이 10년 가량은 늙어진 듯하였다. 나는 그 신산스러운 표정에 얼마쯤 감동이 되어서 그에게 대한 반감이 풀려지는 듯하였다.

"글쎄요, 아마 노동 숙박소란 것이 있지요."

노동 숙박소에 대해서 미주알고주알 묻고 나서,

"시방 가면 무슨 일자리를 구하겠는기오?"라고 그는 매달리는 듯이 또 꽤쳤다.

"글쎄요, 무슨 일자리를 구할 수 있을는지요." 나는 내 대답이 너무 냉랭하고 불친절한 것이 죄송스러웠다. 그러나 일자리에 대하여 아무 지식이 없는 나로서는 이외에 더 좋은 대답을 해 줄 수가 없었던 것이다. 그 대신 나는 은근하게 물었다.

"어디서 오시는 길입니까?"

"흠, 고향에서 오누마."하고 그는 휘 한숨을 쉬었다. 그러자, 그의 신세타령의 실마리는 풀려 나왔다. 그의 고향은 대구에서 멀지 않은 K군 H란 외따른 동리였다. 한 백호 남짓한 그곳 주님은 전부가 역둔토를 파먹고 살았는데, 역둔토로 말하면 사삿집 땅을 부치는 것보다 떨어지는 것이 후하였다. 그러므로 넉넉지는 못할망정 평화로운 농촌으로 남부럽지 않게 지낼 수 있었다. 그러나 세상이 뒤바뀌자 그 땅은 전부가 동양 척식 회사의 소유에 들어가고 말았다. 직접으로 회사에 소작료를 바치게 되었으면 그래도 나으련만 소위 중간 소작인이란 것이 생겨나서 저는 손에 흙 한 번 만져 보지도 않고 동척엔 소작인 노릇을 하며, 실지인에게는 지주 행세를 하게 되었다. 동척에 소작료를 물고 나서 또 중간 소작료인에게 긁히고 보니, 실작인의 손에는 소출이 3할도 떨어지지 않았다. 그후로 \<죽겠다, 못 살겠다\>하는 소리는 중이 염불하듯 그들의 입길에서 오르내리게 되었다. 남부여대하고 타처로 유리하는 사람만 늘고 동리는 점점 쇠진해갔다.

지금으로부터 9년 전, 그가 열일곱 살 되던 해 봄에(그의 나이는 실상 스물여섯이었다. 가난과 고생이 얼마나 사람을 늙히는가?) 그의 집안은 살기 좋다는 바람에 서간도로 이사를 갔었다. 쫓겨가는 운명이거든 어디를 간들 신신하랴. 그곳의 비옥한 전야도 그들을 위하여 열려질 리 없었다. 조금 좋은 땅은 먼저 간 이가 모조리 차지하였고 황무지는 비록 많다 하나 그곳 당도하던 날부터 아침거리 저녁거리 걱정이랴. 무슨 행세로 적어도 1년이란 장구한 세월을 먹고 입어 가며 거친 땅을 풀 수가 있으랴. 남의 밑천을 얻어서 농사를 짓고 보니, 가을이 되어 얻는 것은 빈주먹뿐이었다. 이태 동안을 사는 것이 아니라 억지로 버티어 갈 제, 그의 아버지는 망연히 병을 얻어 타국의 외로운 혼이 되고 말았다. 열아홉 살밖에 안된 그가 홀어머니를 보시고 악으로 악으로 모진 목숨을 이어가는 중 4년이 못되어 영양 부족한 몸이 심한 노동에 지친 탓으로 그의 어머니 또한 죽고 말았다.

"모친까장 돌아갔구마." "돌아가실 때 흰죽 한 모금도 못 자셨구마."하고 이야기하던 이는 문득 말을 뚝 끊는다. 나는 무엇이라고 위로할 말을 몰랐다. 한동안 머뭇머뭇이 있다가 나는 차를 탈 때에 친구들이 사준 정종병 마개를 빼었다. 찻잔에 부어서 그도 마시고 나도 마셨다. 악착한 운명이 던져 준 깊은 슬픔을 술로 녹이려는 듯이 연거푸 다섯 잔을 마시는 그는 다시 말을 계속하였다. 그후 그는 부모 잃은 땅에 오래 머물기 싫었다. 신의주로, 안동현으로 품을 팔다가 일본으로 또 벌이를 찾아가게 되었다. 규슈 탄광에 있어도 보고, 오사까 철공장에도 몸을 담아 보았다. 벌이는 조금 나았으나 외롭고 젊은 몸은 자연히 방탕해졌다. 돈을 모으려야 모을 수 없고 이따금 울화만 치받치기 때문에 한곳에 주접을 하고 있을 수 없었다. 화도 나고 고국 산천이 그립기도 하여서 훌쩍 뛰어나왔다가 오래간만에 고향을 둘러보고 벌이를 구할 겸 서울로 올라가는 길이라 했다.

"고향에 가시니 반가워하는 사람이 있습디까?" 나는 탄식하였다.

"반가워하는 사람이 다 뮌기오, 고향이 통 없어졌더마."

"그렇겠지요. 9년 동안이나 퍽 변했겠지요."

"변하고 뭐고 간에 아무것도 없더마. 집도 없고, 사람도 없고, 개 한 마리도 얼씬을 않더마."

"그러면, 아주 폐농이 되었단 말씀이오?"

"흥, 그렇구마. 무너지다 만 담만 즐비하게 남았드마. 우리 살던 집도 터야 안 남았는기오, 암만 찾아도 못 찾겠더마. 사람 살던 동리가 그렇게 된 것을 혹 구경했는기오?"

하고 그의 짜는 듯 한 목은 높아졌다.

"썩어 넘어진 서까래, 뚤뚤 구르는 주추는\! 꼭 무덤을 파서 해골을 헐어 젖혀놓은 것 같더마. 세상에 이런 일도 있는기오? 백여호 살던 동리가 10년이 못 되어 통 없어지는 수도 있는기오, 후\!"

하고 그는 한숨을 쉬며, 그때의 광경을 눈앞에 그리는 듯이 멀거니 먼산을 보다가 내가 따라 준 술을 꿀꺽 들이켜고,

"참\! 가슴이 터지더마, 가슴이 터져"

하자마자 굵직한 눈물 둬 방울이 뚝뚝 떨어진다.

나는 그 눈물 가운데 음산하고 비참한 조선의 얼굴을 똑똑히 본 듯 싶었다.

이윽고 나는 이런 말을 물었다.

"그래, 이번 길에 고향 사람은 하나도 못 만났습니까?"

"하나 만났구마, 단지 하나."

"친척되는 분이던가요?"

"아니구마, 한 이웃에 살던 사람이구마."하고 그의 얼굴은 더욱 침울했다.

"여간 반갑지 않으셨지어요."

"반갑다마다, 죽은 사람을 만난 것 같더마. 더구나 그 사람은 나와 까닭도 좀 있던 사람인데……"

"까닭이라니?"

"나와 혼인 말이 있던 여자구마."

"하아\!" 나는 놀란 듯이 벌린 입이 닫혀지지 않았다.

"그 신세도 내 신세만 하구마."

하고 그는 또 이야기를 계속하였다. 그 여자는 자기보다 나이 두 살 위였는데, 한이웃에 사는 탓으로 같이 놀기도 하고 싸우기도 하며 자라났다. 그가 열 네살 적부터 그들 부모들 사이에 혼인 말이 있었고 그도 어린 마음에 매우 탐탁하게 생각하였었다. 그런데 그 처녀가 열일곱 살 된 겨울에 별안간 간 곳을 모르게 되었다. 알고 보니, 그 아버지되는 자가 20원을 받고 대구 유곽에 팔아먹은 것이었다. 그 소문이 퍼지자 그 차녀 가족은 그 동리에서 못 살고 멀리 이사를 갔는데 그 후로는 물론 피차에 한 번 만나 보지도 못하였다. 이번에야 빈터만 남은 고향을 구경하고 돌아오는 길에 읍내에서 그 아내될 뻔한 댁과 마주치게 되었다.

처녀는 어떤 일본 사람 집에서 아이를 보고 있었다. 궐녀는 20원 몸값을 10년을 두고 갚았건만 그래도 주인에게 빚이 60원이나 남았었는데, 몸에 몹쓸 병이 들어 나이 늙어져서 산송장이 되니까. 주인되는 자가 특별히 빚을 탕감해 주고, 작년 가을에야 놓아 준 것이었다.

궐녀도 자기와 같이 10년 동안이나 그리던 고향에 찾아오니까 거기에는 집도 없고, 부모도 없고 쓸쓸한 돌무더기만 눈물을 자아낼 뿐이었다. 하루해를 울어 보내고 읍내로 들어와서 돌아다니다가, 10년 동안에 한 마디 두 마디 배워 두었던 일본말 덕택으로 그 일본 집에 있게 되었던 것이다.

"암만 사람이 변하기로 어째 그렇게도 변하는기오? 그 숱 많던머리가 훌렁 다 벗을졌두마. 눈을 푹 들어가고 그 이들이들하던 얼굴빛도 마치 유산을 끼얹은 듯하더마."

"서로 붙잡고 많이 우셨겠지요"

"눈물도 안 나오더마. 일본 우동집에 들어가서 둘이서 정종만 열병 때려뉘고 헤어졌구마."

하고 가슴을 짜는 듯한 괴로운 한숨을 쉬더니만 그는 지난 슬픔을 새록새록 자아내어 마음을 새기기에 지쳤음이더라.

"이야기를 다하면 뭐하는기오."

하고 쓸쓸하게 입을 다문다.

나 또한 너무도 참혹한 사람살이를 듣기에 쓴물이 났다.

"자, 우리 술이나 마자 먹읍시다."

하고 우리는 주거니받거니 한되 병을 다 말리고 말았다. 그는 취흥에 겨워서 우리가 어릴 때 멋모르고 부르던 노래를 읊조렸다.

볏섬이나 나는 전토는

신작로가 되고요……

말마디나 하는 친구는

감옥소로 가고요……

담뱃대나 떠는 노인은

공동묘지 가고요……

인물이나 좋은 계집은

유곽으로 가고요……`;

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
    {
        id: 1,
        question: "'그'의 가족이 고향을 떠나 서간도로 이주해야만 했던 이유를, 소설에 나타난 사회적, 경제적 배경과 관련지어 서술하시오.",
        correctAnswer: "'그'의 가족이 고향을 떠난 이유는 일제의 토지 수탈 정책 때문이었다. 원래 마을 사람들은 역둔토를 부치며 평화롭게 살았지만, 모든 땅이 동양 척식 회사의 소유가 되고 중간 소작인의 이중 착취까지 더해지자, 소출의 3할도 손에 쥐기 힘든 극심한 경제적 어려움에 처하게 되었다. 결국 생계를 유지할 수 없게 된 마을 사람들이 하나둘 떠나게 되면서 '그'의 가족 역시 '살기 좋다'는 말을 믿고 서간도로 이주하게 되었다.",
        correctParts: [
            "'그'의 가족이 고향을 떠난 이유는 일제의 토지 수탈 정책 때문이었다.",
            "원래 마을 사람들은 역둔토를 부치며 평화롭게 살았지만,",
            "모든 땅이 동양 척식 회사의 소유가 되고 중간 소작인의 이중 착취까지 더해지자,",
            "소출의 3할도 손에 쥐기 힘든 극심한 경제적 어려움에 처하게 되었다.",
            "결국 생계를 유지할 수 없게 된 마을 사람들이 하나둘 떠나게 되면서",
            "'그'의 가족 역시 '살기 좋다'는 말을 믿고 서간도로 이주하게 되었다."
        ],
        distractors: ["일제의 강압적인 이주 정책에 의해 강제로 이주당했다", "고향에서 자연재해가 발생하여 농사를 지을 수 없게 되었다", "더 나은 교육 기회를 찾아 서간도로 이주하였다"]
    },
    {
        id: 2,
        question: "소설 초반에 묘사된 '그'의 기이한 옷차림(조선, 중국, 일본의 옷을 섞어 입은 모습)이 상징하는 바를 서술하시오.",
        correctAnswer: "'그'의 기이한 옷차림은 일제 강점하에 삶의 터전을 잃고 조선, 중국(서간도), 일본 등지를 떠돌아다녀야 했던 그의 비참한 유랑 생활을 상징한다. 또한 어느 한 곳에도 정착하지 못하고 뿌리 뽑힌 채 살아가는 식민지 조선인의 정체성 혼란과 비극적인 처지를 암시한다.",
        correctParts: [
            "'그'의 기이한 옷차림은 일제 강점하에 삶의 터전을 잃고",
            "조선, 중국(서간도), 일본 등지를 떠돌아다녀야 했던",
            "그의 비참한 유랑 생활을 상징한다.",
            "또한 어느 한 곳에도 정착하지 못하고 뿌리 뽑힌 채 살아가는",
            "식민지 조선인의 정체성 혼란과 비극적인 처지를 암시한다."
        ],
        distractors: ["국제적인 감각과 개방적인 사고방식을 나타낸다", "세 나라의 문화를 존중하는 태도를 보여준다", "패션에 대한 독특한 취향을 드러낸다"]
    },
    {
        id: 3,
        question: "'그'가 9년 만에 돌아본 고향의 모습은 어떠했으며, 그는 폐허가 된 고향을 무엇에 비유하여 자신의 참담한 심정을 드러냈는지 서술하시오.",
        correctAnswer: "9년 만에 돌아온 고향은 집도, 사람도, 심지어 개 한 마리도 없이 완전히 폐농이 된 상태였다. 무너진 담만 즐비하게 남아 있었고, 썩은 서까래와 뒹구는 주춧돌만이 있었다. '그'는 이러한 고향의 모습을 '무덤을 파서 해골을 헐어 젖혀 놓은 것'에 비유하며 삶의 터전이 송두리째 파괴된 것에 대한 충격과 참담한 심정을 드러냈다.",
        correctParts: [
            "9년 만에 돌아온 고향은 집도, 사람도, 심지어 개 한 마리도 없이",
            "완전히 폐농이 된 상태였다.",
            "무너진 담만 즐비하게 남아 있었고, 썩은 서까래와 뒹구는 주춧돌만이 있었다.",
            "'그'는 이러한 고향의 모습을 '무덤을 파서 해골을 헐어 젖혀 놓은 것'에 비유하며",
            "삶의 터전이 송두리째 파괴된 것에 대한 충격과 참담한 심정을 드러냈다."
        ],
        distractors: ["마을이 현대화되어 옛 모습을 찾을 수 없게 되었다", "자연으로 돌아가 평화로운 모습으로 변했다", "새로운 사람들이 들어와 번창하는 마을이 되었다"]
    },
    {
        id: 4,
        question: "서술자 '나'가 '그'에게 '정종'을 건네는 행위가 두 인물의 관계에서 어떤 의미와 기능을 하는지 서술하시오.",
        correctAnswer: "'나'가 '그'에게 정종을 건네는 행위는 그의 비극적인 신세타령을 들으며 느낀 연민과 공감의 마음을 표현하는 것이다. 처음에는 거부감을 느꼈던 '나'가 '그'의 이야기에 감화되어 그를 위로하려는 행동으로, 두 사람 사이의 심리적 거리를 좁히고 '나'가 '그'의 개인적 비극을 민족의 비극으로 인식하게 되는 계기를 마련하는 기능을 한다.",
        correctParts: [
            "'나'가 '그'에게 정종을 건네는 행위는",
            "그의 비극적인 신세타령을 들으며 느낀 연민과 공감의 마음을 표현하는 것이다.",
            "처음에는 거부감을 느꼈던 '나'가 '그'의 이야기에 감화되어 그를 위로하려는 행동으로,",
            "두 사람 사이의 심리적 거리를 좁히고",
            "'나'가 '그'의 개인적 비극을 민족의 비극으로 인식하게 되는 계기를 마련하는 기능을 한다."
        ],
        distractors: ["단순히 차 안에서 시간을 보내기 위한 행위이다", "'나'의 경제적 여유를 과시하기 위한 것이다", "'그'를 취하게 하여 이야기를 그만두게 하려는 의도이다"]
    },
    {
        id: 5,
        question: "소설이 진행됨에 따라 '그'를 바라보는 서술자 '나'의 인식이 어떻게 변화하는지 그 과정을 구체적으로 서술하시오.",
        correctAnswer: "처음 '나'는 '그'의 기이한 옷차림과 경박한 태도를 보며 거부감과 불쾌감을 느낀다. 하지만 그가 일자리를 구하러 서울로 간다는 사실에 호기심과 동정을 느끼기 시작한다. 이후 '그'의 비참한 과거 이야기를 들으며 점차 그의 처지에 공감하고 연민을 느끼게 되며, 술을 건네 위로한다. 최종적으로 '그'의 눈물에서 '조선의 얼굴'을 발견하며, 그의 개인적 비극이 곧 식민지 조선 민족 전체의 비극이라는 사회적, 민족적 차원으로 인식을 확장하게 된다.",
        correctParts: [
            "처음 '나'는 '그'의 기이한 옷차림과 경박한 태도를 보며 거부감과 불쾌감을 느낀다.",
            "하지만 그가 일자리를 구하러 서울로 간다는 사실에 호기심과 동정을 느끼기 시작한다.",
            "이후 '그'의 비참한 과거 이야기를 들으며 점차 그의 처지에 공감하고 연민을 느끼게 되며, 술을 건네 위로한다.",
            "최종적으로 '그'의 눈물에서 '조선의 얼굴'을 발견하며,",
            "그의 개인적 비극이 곧 식민지 조선 민족 전체의 비극이라는 사회적, 민족적 차원으로 인식을 확장하게 된다."
        ],
        distractors: ["처음부터 끝까지 '그'에 대한 동정심을 유지한다", "점점 더 '그'를 불편하게 여기며 거리를 둔다", "'그'의 이야기를 의심하며 신뢰하지 않게 된다"]
    },
    {
        id: 6,
        question: "백여 호가 살던 '그'의 고향 마을이 십 년도 안 되어 완전한 폐허가 되기까지의 과정을 인과 관계에 따라 단계적으로 서술하시오.",
        correctAnswer: "(1단계: 원인) 마을의 땅이 모두 동양 척식 회사의 소유가 되고 중간 소작인 제도가 생겨났다. (2단계: 과정) 이로 인해 농민들은 이중으로 수탈당하여 소출의 3할도 얻지 못하는 극심한 가난에 시달리게 되었다. (3단계: 결과) 결국 생계를 이어갈 수 없게 된 마을 사람들이 '남부여대'하여 타처로 유리하면서 마을은 점점 쇠진해졌고, 십 년도 안 되어 아무도 살지 않는 폐허가 되었다.",
        correctParts: [
            "(1단계: 원인) 마을의 땅이 모두 동양 척식 회사의 소유가 되고 중간 소작인 제도가 생겨났다.",
            "(2단계: 과정) 이로 인해 농민들은 이중으로 수탈당하여",
            "소출의 3할도 얻지 못하는 극심한 가난에 시달리게 되었다.",
            "(3단계: 결과) 결국 생계를 이어갈 수 없게 된 마을 사람들이 '남부여대'하여 타처로 유리하면서",
            "마을은 점점 쇠진해졌고, 십 년도 안 되어 아무도 살지 않는 폐허가 되었다."
        ],
        distractors: ["자연재해가 반복되어 농사를 지을 수 없게 되었다", "마을 사람들이 더 나은 기회를 찾아 도시로 이주했다", "일제가 마을을 강제로 철거하여 폐허가 되었다"]
    },
    {
        id: 7,
        question: "'그'와 고향에서 재회한 '옛 여인'의 삶을 요약하고, 두 인물의 만남이 작품의 주제를 어떻게 심화하는지 서술하시오.",
        correctAnswer: "'그'의 옛 여인은 가난 때문에 유곽으로 팔려 갔다가 10년 만에 병든 몸으로 돌아와 일본인 집에서 식모살이를 하는 비참한 삶을 살고 있었다. 이 만남은 '그'가 겪는 고향 상실과 유랑의 비극이 그 개인에게만 국한된 것이 아님을 보여준다. 비슷한 처지의 여인을 통해 당대 조선 민중이 겪는 고통의 보편성을 확인시켜 주며, 일제 강점하 우리 민족의 비참한 삶이라는 작품의 주제를 더욱 심화하고 구체화한다.",
        correctParts: [
            "'그'의 옛 여인은 가난 때문에 유곽으로 팔려 갔다가",
            "10년 만에 병든 몸으로 돌아와 일본인 집에서 식모살이를 하는 비참한 삶을 살고 있었다.",
            "이 만남은 '그'가 겪는 고향 상실과 유랑의 비극이 그 개인에게만 국한된 것이 아님을 보여준다.",
            "비슷한 처지의 여인을 통해 당대 조선 민중이 겪는 고통의 보편성을 확인시켜 주며,",
            "일제 강점하 우리 민족의 비참한 삶이라는 작품의 주제를 더욱 심화하고 구체화한다."
        ],
        distractors: ["두 사람이 재회하여 희망적인 미래를 꿈꾸게 된다", "옛 여인의 성공적인 삶이 '그'에게 동기부여가 된다", "과거의 사랑을 회복하며 새로운 삶을 시작한다"]
    },
    {
        id: 8,
        question: "<보기>를 바탕으로, 이 소설의 '그'가 '전형적 인물'로서 어떤 역할을 하는지 서술하시오.\n\n<보기>\n사실주의 소설에서는 특정 시대나 사회 계층의 보편적인 특징과 삶을 압축적으로 보여주는 '전형적 인물'을 설정하여 현실을 효과적으로 고발한다. 작가는 한 인물의 구체적인 삶을 통해 그가 속한 집단 전체의 목소리를 대변하게 함으로써, 이야기의 사실성과 사회 비판의 설득력을 높인다.",
        correctAnswer: "<보기>에 따르면 '전형적 인물'은 특정 시대와 계층을 대표한다. 소설 속 '그'는 1920년대 일제 강점하에 토지를 빼앗기고 고향을 떠나 만주, 일본 등지를 떠돌며 생존해야 했던 조선 농민의 보편적인 삶을 압축적으로 보여주는 전형적 인물이다. 작가는 '그'라는 한 인물의 기구한 삶의 역정을 통해 당시 수많은 조선 민중이 겪었던 수탈과 유랑의 고통을 사실적으로 고발하고, 이를 통해 식민지 현실에 대한 비판적 메시지를 설득력 있게 전달하는 역할을 한다.",
        correctParts: [
            "<보기>에 따르면 '전형적 인물'은 특정 시대와 계층을 대표한다.",
            "소설 속 '그'는 1920년대 일제 강점하에 토지를 빼앗기고 고향을 떠나 만주, 일본 등지를 떠돌며 생존해야 했던",
            "조선 농민의 보편적인 삶을 압축적으로 보여주는 전형적 인물이다.",
            "작가는 '그'라는 한 인물의 기구한 삶의 역정을 통해 당시 수많은 조선 민중이 겪었던 수탈과 유랑의 고통을 사실적으로 고발하고,",
            "이를 통해 식민지 현실에 대한 비판적 메시지를 설득력 있게 전달하는 역할을 한다."
        ],
        distractors: ["'그'는 특별한 능력으로 시대를 극복한 영웅적 인물이다", "'그'는 개인적 결함 때문에 불행을 겪는 예외적 인물이다", "'그'는 작가의 상상력으로 만들어진 비현실적 인물이다"]
    },
    {
        id: 9,
        question: "'나'가 '그'의 눈물 속에서 '음산하고 비참한 조선의 얼굴'을 보았다고 한 것의 의미는 무엇인지, 작품의 주제와 관련지어 서술하시오.",
        correctAnswer: "'나'가 '그'의 눈물에서 '조선의 얼굴'을 보았다는 것은, '그' 한 개인의 슬픔과 비극을 넘어 그것이 곧 일제 강점기를 살아가는 우리 민족 전체의 보편적인 고통이자 현실임을 깨달았다는 의미이다. 즉, '나'는 '그'의 이야기를 통해 고향을 상실하고 유랑하는 식민지 조선 민중의 암울하고 비참한 모습을 발견한 것이다. 이를 통해 작품은 개인의 문제를 사회, 역사적 차원으로 확장하며 주제 의식을 명확하게 드러낸다.",
        correctParts: [
            "'나'가 '그'의 눈물에서 '조선의 얼굴'을 보았다는 것은,",
            "'그' 한 개인의 슬픔과 비극을 넘어 그것이 곧 일제 강점기를 살아가는 우리 민족 전체의 보편적인 고통이자 현실임을 깨달았다는 의미이다.",
            "즉, '나'는 '그'의 이야기를 통해 고향을 상실하고 유랑하는 식민지 조선 민중의 암울하고 비참한 모습을 발견한 것이다.",
            "이를 통해 작품은 개인의 문제를 사회, 역사적 차원으로 확장하며 주제 의식을 명확하게 드러낸다."
        ],
        distractors: ["'나'가 '그'에게 개인적 동정심을 느꼈다는 의미이다", "'그'의 눈물이 아름답고 감동적이었다는 뜻이다", "'나'도 '그'와 같은 경험을 했음을 회상했다는 의미이다"]
    },
    {
        id: 10,
        question: "이 소설이 사용한 '액자식 구성' 방식이, '그'의 이야기를 독자에게 전달하는 데 어떤 효과를 주는지 서술하시오.",
        correctAnswer: "이 소설의 액자식 구성은 크게 두 가지 효과를 준다. 첫째, 외부 이야기의 서술자인 '나'가 '그'에게 직접 들은 이야기를 전달하는 형식을 취함으로써, 내부 이야기가 마치 실제 있었던 일처럼 느껴지게 만들어 사실성과 신뢰성을 높인다. 둘째, '나'라는 관찰자를 통해 '그'의 비극을 한 단계 거쳐 보게 함으로써 독자가 객관적인 거리를 유지하게 하고, '나'가 '그'의 개인사를 '조선의 얼굴'로 해석하는 결말을 통해 개인의 문제를 민족 전체의 보편적인 문제로 자연스럽게 확장시키는 효과를 준다.",
        correctParts: [
            "이 소설의 액자식 구성은 크게 두 가지 효과를 준다.",
            "첫째, 외부 이야기의 서술자인 '나'가 '그'에게 직접 들은 이야기를 전달하는 형식을 취함으로써,",
            "내부 이야기가 마치 실제 있었던 일처럼 느껴지게 만들어 사실성과 신뢰성을 높인다.",
            "둘째, '나'라는 관찰자를 통해 '그'의 비극을 한 단계 거쳐 보게 함으로써 독자가 객관적인 거리를 유지하게 하고,",
            "'나'가 '그'의 개인사를 '조선의 얼굴'로 해석하는 결말을 통해 개인의 문제를 민족 전체의 보편적인 문제로 자연스럽게 확장시키는 효과를 준다."
        ],
        distractors: ["이야기가 복잡해져 독자의 흥미를 높인다", "여러 시점을 보여주어 다양한 해석을 가능하게 한다", "시간 순서를 자유롭게 조작할 수 있게 한다"]
    }
        ];

        // 5단계 초기화
        function initStage5() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '현진건 <고향>';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stageResults,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `봄봄_워크북_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>