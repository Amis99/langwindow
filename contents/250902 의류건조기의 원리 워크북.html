<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>의류 건조기의 원리 - 딥리서치 학습</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">의류 건조기의 원리</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                {
                    id: 1,
                    text: "열에너지는 항상 _____ 이동하는 성질이 있습니다.",
                    highlight: "열에너지는 항상 (고온에서 저온으로 / 저온에서 고온으로) 이동하는 성질이 있습니다.",
                    options: ["고온에서 저온으로", "저온에서 고온으로"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "수분을 포함한 물체에 열이 전달되면, 물 분자들의 운동 에너지가 _____ 분자 간의 결합력이 약해집니다.",
                    highlight: "수분을 포함한 물체에 열이 전달되면, 물 분자들의 운동 에너지가 (감소하여 / 증가하여) 분자 간의 결합력이 약해집니다.",
                    options: ["감소하여", "증가하여"],
                    correct: 1
                },
                {
                    id: 3,
                    text: "액체 상태의 물이 기체인 수증기로 변하는 _____ 현상",
                    highlight: "액체 상태의 물이 기체인 수증기로 변하는 (응축 / 증발) 현상",
                    options: ["응축", "증발"],
                    correct: 1
                },
                {
                    id: 4,
                    text: "건조 속도는 공기의 온도가 _____ 빨라집니다.",
                    highlight: "건조 속도는 공기의 온도가 (높을수록 / 낮을수록) 빨라집니다.",
                    options: ["높을수록", "낮을수록"],
                    correct: 0
                },
                {
                    id: 5,
                    text: "공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양, 즉 _____이 증가하게 됩니다.",
                    highlight: "공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양, 즉 (포화 수증기량 / 이슬점)이 증가하게 됩니다.",
                    options: ["포화 수증기량", "이슬점"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "공기가 더 많은 수증기를 품을 수 있게 되어 수분 증발이 더욱 _____.",
                    highlight: "공기가 더 많은 수증기를 품을 수 있게 되어 수분 증발이 더욱 (억제됩니다 / 촉진됩니다).",
                    options: ["억제됩니다", "촉진됩니다"],
                    correct: 1
                },
                {
                    id: 7,
                    text: "예열 구간: 건조가 _____ 구간입니다.",
                    highlight: "건조가 (시작되는 / 끝나는) 구간입니다.",
                    options: ["시작되는", "끝나는"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "예열 구간에서 세탁물의 온도가 상승하고, 건조 속도가 점차 _____.",
                    highlight: "세탁물의 온도가 상승하고, 건조 속도가 점차 (느려집니다 / 빨라집니다).",
                    options: ["느려집니다", "빨라집니다"],
                    correct: 1
                },
                {
                    id: 9,
                    text: "예열 구간은 건조 과정의 초반이므로, 세탁물의 함수율이 세 구간 중 가장 _____.",
                    highlight: "세탁물의 함수율이 세 구간 중 가장 (높습니다 / 낮습니다).",
                    options: ["높습니다", "낮습니다"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "항률 건조 구간: 세탁물로 전달된 열에너지가 수분 증발에 _____ 사용됩니다.",
                    highlight: "세탁물로 전달된 열에너지가 수분 증발에 (집중적으로 / 간헐적으로) 사용됩니다.",
                    options: ["집중적으로", "간헐적으로"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "항률 건조 구간: 뜨거운 공기가 계속 유입되어도 세탁물의 온도는 더 이상 상승하지 않고 _____.",
                    highlight: "세탁물의 온도는 더 이상 상승하지 않고 (일정하게 유지됩니다 / 계속 상승합니다).",
                    options: ["일정하게 유지됩니다", "계속 상승합니다"],
                    correct: 0
                },
                {
                    id: 12,
                    text: "항률 건조 구간: 드럼에서 빠져나오는 공기의 _____ 역시 일정하게 유지됩니다.",
                    highlight: "드럼에서 빠져나오는 공기의 (습도 / 온도) 역시 일정하게 유지됩니다.",
                    options: ["습도", "온도"],
                    correct: 0
                },
                {
                    id: 13,
                    text: "항률 건조 구간: 건조 과정에서 열에너지가 소모되므로 드럼에서 빠져나오는 공기의 온도는 유입될 때보다 _____.",
                    highlight: "드럼에서 빠져나오는 공기의 온도는 유입될 때보다 (높아집니다 / 낮아집니다).",
                    options: ["높아집니다", "낮아집니다"],
                    correct: 1
                },
                {
                    id: 14,
                    text: "감률 건조 구간: 세탁물에서 증발할 수 있는 수분이 계속 줄어들어 건조 속도가 점점 _____.",
                    highlight: "건조 속도가 점점 (느려집니다 / 빨라집니다).",
                    options: ["느려집니다", "빨라집니다"],
                    correct: 0
                },
                {
                    id: 15,
                    text: "감률 건조 구간: 수분이 모두 증발하면 건조 속도는 _____이 되고, 더 이상 건조는 진행되지 않습니다.",
                    highlight: "건조 속도는 (0 / 1)이 되고",
                    options: ["0", "1"],
                    correct: 0
                },
                {
                    id: 16,
                    text: "감률 건조 구간: 이때부터는 세탁물의 _____.",
                    highlight: "이때부터는 세탁물의 (온도만 높아집니다 / 함수율만 높아집니다).",
                    options: ["온도만 높아집니다", "함수율만 높아집니다"],
                    correct: 0
                },
                {
                    id: 17,
                    text: "감률 건조 구간: 건조 종료 직전에는 드럼으로 들어가는 공기와 빠져나오는 공기의 온도 차가 _____.",
                    highlight: "공기의 온도 차가 (커집니다 / 줄어듭니다).",
                    options: ["커집니다", "줄어듭니다"],
                    correct: 1
                },
                {
                    id: 18,
                    text: "배기식 건조기: 수증기를 실외로 이어지는 별도의 _____를 통해 외부로 바로 배출하는 방식입니다.",
                    highlight: "별도의 (배기 장치 / 열 교환기)를 통해",
                    options: ["배기 장치", "열 교환기"],
                    correct: 0
                },
                {
                    id: 19,
                    text: "응축식 건조기: 수증기를 다시 _____ 상태로 바꾸어 물통이나 배수구를 통해 배출하는 방식입니다.",
                    highlight: "수증기를 다시 (기체 / 액체) 상태로 바꾸어",
                    options: ["기체", "액체"],
                    correct: 1
                },
                {
                    id: 20,
                    text: "응축식 건조기: 드럼에서 나온 습한 공기가 열 교환기로 이동하여 _____됩니다.",
                    highlight: "열 교환기로 이동하여 (가열 / 냉각)됩니다.",
                    options: ["가열", "냉각"],
                    correct: 1
                },
                {
                    id: 21,
                    text: "응축식 건조기: 수증기가 물로 응결되는 온도인 이슬점까지 낮아지면, 수증기가 물로 _____되어",
                    highlight: "수증기가 물로 (증발 / 응축)되어",
                    options: ["증발", "응축"],
                    correct: 1
                },
                {
                    id: 22,
                    text: "응축식 건조기: 습도가 낮아진 공기는 다시 가열 과정을 거쳐 _____ 유입되며",
                    highlight: "가열 과정을 거쳐 (드럼으로 / 외부로) 유입되며",
                    options: ["드럼으로", "외부로"],
                    correct: 0
                },
                {
                    id: 23,
                    text: "의류 건조기 단점: 건조 과정에서 세탁물이 고온의 공기와 맞닿으며 _____ 수 있고",
                    highlight: "공기와 맞닿으며 (팽창될 / 수축될) 수 있고",
                    options: ["팽창될", "수축될"],
                    correct: 1
                },
                {
                    id: 24,
                    text: "특히 _____는 수축이 더 많이 발생하는 편입니다.",
                    highlight: "특히 (합성 섬유 / 천연 섬유)는 수축이",
                    options: ["합성 섬유", "천연 섬유"],
                    correct: 1
                }
            ],
            fullText: `■ 의류 건조기의 기본 원리

열에너지는 항상 (고온에서 저온으로 / 저온에서 고온으로) 이동하는 성질이 있습니다. 물체와 공기의 온도 차가 클수록 열전달은 더 활발해지죠. 수분을 포함한 물체에 열이 전달되면, 물 분자들의 운동 에너지가 (감소하여 / 증가하여) 분자 간의 결합력이 약해집니다. 이 때문에 액체 상태의 물이 기체인 수증기로 변하는 (응축 / 증발) 현상, 즉 상변화가 활발하게 일어납니다. 이런 원리를 이용해 물체에서 수분을 제거하는 것을 건조라고 합니다.

단위 시간 동안 물체에서 증발하는 수분의 양을 건조 속도라고 부릅니다. 다른 조건이 같다면, 건조 속도는 공기의 온도가 (높을수록 / 낮을수록) 빨라집니다. 또한 공기의 온도가 높아지면, 공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양, 즉 (포화 수증기량 / 이슬점)이 증가하게 됩니다. 그 결과, 공기가 더 많은 수증기를 품을 수 있게 되어 수분 증발이 더욱 (억제됩니다 / 촉진됩니다). 의류 건조기는 바로 이 원리를 이용해 세탁물을 빠르게 건조시키는 기계입니다.

■ 의류 건조의 3단계 과정

의류 건조기 드럼 내부에서 일어나는 건조 과정은 세탁물의 수분 함량 비율인 함수율과 건조 속도의 변화에 따라 세 구간으로 나눌 수 있습니다.

1. 예열 구간

• 건조가 (시작되는 / 끝나는) 구간입니다.

• 고온의 공기가 세탁물에 열을 전달하여 세탁물의 온도가 상승하고, 건조 속도가 점차 (느려집니다 / 빨라집니다).

• 건조 과정의 초반이므로, 세탁물의 함수율이 세 구간 중 가장 (높습니다 / 낮습니다).

2. 항률 건조 구간 (속도가 일정한 구간)

• 세탁물로 전달된 열에너지가 수분 증발에 (집중적으로 / 간헐적으로) 사용됩니다.

• 뜨거운 공기가 계속 유입되어도 세탁물의 온도는 더 이상 상승하지 않고 (일정하게 유지됩니다 / 계속 상승합니다).

• 공급되는 열에너지가 일정하므로 증발하는 수분의 양도 일정하고, 드럼에서 빠져나오는 공기의 (습도 / 온도) 역시 일정하게 유지됩니다.

• 반면, 건조 과정에서 열에너지가 소모되므로 드럼에서 빠져나오는 공기의 온도는 유입될 때보다 (높아집니다 / 낮아집니다).

• 세탁물의 함수율이 점차 감소하다가, 건조 속도가 느려지기 시작하는 시점을 기준으로 다음 구간으로 넘어갑니다.

3. 감률 건조 구간 (속도가 줄어드는 구간)

• 세탁물에서 증발할 수 있는 수분이 계속 줄어들어 건조 속도가 점점 (느려집니다 / 빨라집니다).

• 수분이 모두 증발하면 건조 속도는 (0 / 1)이 되고, 더 이상 건조는 진행되지 않습니다.

• 이때부터는 세탁물의 (온도만 높아집니다 / 함수율만 높아집니다).

• 건조 종료 직전에는 드럼으로 들어가는 공기와 빠져나오는 공기의 온도 차가 (커집니다 / 줄어듭니다). 건조기는 이 온도 차를 감지하여 건조 완료 시점을 예상하고 작동을 멈출 수 있습니다.

■ 의류 건조기의 종류

세탁물에서 증발한 수증기를 건조기 밖으로 배출하는 방식에 따라 두 종류로 나뉩니다.

1. 배기식 건조기

• 드럼에서 빠져나온 수증기를 실외로 이어지는 별도의 (배기 장치 / 열 교환기)를 통해 외부로 바로 배출하는 방식입니다.

2. 응축식 건조기

• 수증기를 다시 (기체 / 액체) 상태로 바꾸어 물통이나 배수구를 통해 배출하는 방식입니다.

• 작동 과정:

  1. 드럼에서 나온 습한 공기가 열 교환기로 이동하여 (가열 / 냉각)됩니다.

  2. 공기의 온도가 수증기가 물로 응결되는 온도인 이슬점까지 낮아지면, 수증기가 물로 (증발 / 응축)되어 공기의 습도가 낮아집니다.

  3. 습도가 낮아진 공기는 다시 가열 과정을 거쳐 (드럼으로 / 외부로) 유입되며, 이 순환 과정이 반복됩니다.

■ 장단점 및 발전 방향

의류 건조기는 상온에서의 자연 건조보다 건조 시간을 크게 줄여주는 장점이 있습니다. 하지만 건조 과정에서 세탁물이 고온의 공기와 맞닿으며 (팽창될 / 수축될) 수 있고, 특히 (합성 섬유 / 천연 섬유)는 수축이 더 많이 발생하는 편입니다. 이러한 의류 손상을 최소화하기 위한 연구가 계속 이루어지고 있습니다.`
        };

        // 2단계 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "열전달",
                meaning: "온도가 높은 곳에서 낮은 곳으로 열이 옮겨가는 현상",
                type: "concept",
                confusors: {
                    word: ["열교환", "열전도", "열복사"],
                    meaning: ["온도가 낮은 곳에서 높은 곳으로 열이 이동하는 현상", "두 물체 사이에서 열이 교체되는 현상", "고체 내부에서만 일어나는 열이동"]
                }
            },
            {
                word: "상변화",
                meaning: "물질이 온도, 압력에 따라 한 상태에서 다른 상태로 변하는 현상",
                type: "concept",
                confusors: {
                    word: ["상태변화", "상전이", "상분리"],
                    meaning: ["물질의 화학적 성질이 변하는 현상", "물질의 물리적 성질만 변하는 현상", "온도와 무관하게 일어나는 물질 변화"]
                }
            },
            {
                word: "건조",
                meaning: "물체에서 수분을 제거하는 것",
                type: "concept",
                confusors: {
                    word: ["탈수", "증발", "승화"],
                    meaning: ["물체에 수분을 추가하는 것", "고체가 액체로 변하는 현상", "열을 가해 수분을 응축시키는 과정"]
                }
            },
            {
                word: "건조 속도",
                meaning: "단위 시간 동안 물체에서 증발하는 수분의 양",
                type: "concept",
                confusors: {
                    word: ["건조 시간", "증발 속도", "수분 함량"],
                    meaning: ["전체 건조에 걸리는 시간", "수분이 액체로 변하는 비율", "물체가 흡수하는 수분의 양"]
                }
            },
            {
                word: "포화 수증기량",
                meaning: "특정 온도에서 공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양",
                type: "concept",
                confusors: {
                    word: ["절대 습도", "상대 습도", "이슬점"],
                    meaning: ["공기 중 수증기의 현재 양", "온도와 무관한 수증기 최대량", "공기가 품을 수 있는 최소 수증기량"]
                }
            },
            {
                word: "함수율",
                meaning: "세탁물에 포함된 수분의 함량 비율",
                type: "concept",
                confusors: {
                    word: ["건조율", "수분율", "습도"],
                    meaning: ["세탁물에서 제거된 수분의 비율", "공기 중 수증기 비율", "세탁물이 건조된 정도"]
                }
            },
            {
                word: "예열 구간",
                meaning: "건조 초반, 세탁물의 온도가 상승하며 건조 속도가 빨라지는 구간",
                type: "구간",
                confusors: {
                    word: ["항률 구간", "감률 구간", "종료 구간"],
                    meaning: ["건조가 일정 속도로 진행되는 구간", "건조 속도가 감소하는 구간", "건조가 완료되는 구간"]
                }
            },
            {
                word: "항률 건조 구간",
                meaning: "전달된 열에너지가 수분 증발에만 쓰여 세탁물의 온도가 일정하게 유지되는 구간",
                type: "구간",
                confusors: {
                    word: ["예열 건조 구간", "감률 건조 구간", "변률 건조 구간"],
                    meaning: ["세탁물 온도가 계속 상승하는 구간", "건조 속도가 계속 증가하는 구간", "열에너지가 온도 상승에만 쓰이는 구간"]
                }
            },
            {
                word: "감률 건조 구간",
                meaning: "수분이 줄어 건조 속도가 점점 느려지는 구간",
                type: "구간",
                confusors: {
                    word: ["증률 건조 구간", "항률 건조 구간", "예열 구간"],
                    meaning: ["건조 속도가 계속 빨라지는 구간", "수분이 증가하는 구간", "건조가 시작되는 구간"]
                }
            },
            {
                word: "이슬점",
                meaning: "수증기가 물로 응결되기 시작하는 온도",
                type: "concept",
                confusors: {
                    word: ["끓는점", "어는점", "빙점"],
                    meaning: ["물이 수증기로 변하는 온도", "액체가 기체로 변하는 최대 온도", "수증기가 최대로 존재할 수 있는 온도"]
                }
            },
            {
                word: "응축",
                meaning: "기체가 냉각되거나 압축되어 액체로 변하는 현상",
                type: "concept",
                confusors: {
                    word: ["증발", "승화", "융해"],
                    meaning: ["액체가 기체로 변하는 현상", "고체가 기체로 변하는 현상", "기체가 고체로 변하는 현상"]
                }
            },
            {
                word: "열 교환기",
                meaning: "뜨거운 유체와 차가운 유체 사이에서 열을 교환하는 장치",
                type: "한자어",
                confusors: {
                    word: ["열 전달기", "냉각기", "가열기"],
                    meaning: ["열을 한 방향으로만 전달하는 장치", "열을 생성하는 장치", "열을 차단하는 장치"]
                }
            }
        ];

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 문장 독해 데이터
        const sentenceData = [
            // 문장 1: 수분을 포함하고 있는 물체로 열전달이...
            {
                sentence: "수분을 포함하고 있는 물체로 열전달이 일어나면 물 분자들의 운동 에너지가 증가하여 분자들 간의 결합력이 약해지기 때문에 기체로의 상변화가 활발해진다.",
                question: "무엇이 '활발해지나요'?",
                correctAnswer: "상변화",
                distractors: ["물 분자들의 운동 에너지", "분자들 간의 결합력", "수분을 포함한 물체"]
            },
            {
                sentence: "수분을 포함하고 있는 물체로 열전달이 일어나면 물 분자들의 운동 에너지가 증가하여 분자들 간의 결합력이 약해지기 때문에 기체로의 상변화가 활발해진다.",
                question: "상변화가 활발해지는 이유는?",
                correctAnswer: "분자들 간의 결합력이 약해지기 때문",
                distractors: ["온도가 낮아지기 때문", "수분이 제거되기 때문", "열전달이 차단되기 때문"]
            },
            // 문장 2: 의류 건조기는 가열 장치를 통해...
            {
                sentence: "의류 건조기는 가열 장치를 통해 공기를 일정 온도까지 가열한 후, 이를 세탁물이 있는 드럼으로 이동시킨다.",
                question: "무엇이 무엇을 '이동시키나요'?",
                correctAnswer: "의류 건조기가 가열된 공기를",
                distractors: ["가열 장치가 세탁물을", "드럼이 공기를", "세탁물이 열을"]
            },
            {
                sentence: "의류 건조기는 가열 장치를 통해 공기를 일정 온도까지 가열한 후, 이를 세탁물이 있는 드럼으로 이동시킨다.",
                question: "'이를'이 가리키는 것은?",
                correctAnswer: "가열된 공기",
                distractors: ["가열 장치", "세탁물", "드럼"]
            },
            // 문장 3: 또한 공기의 온도가 높아지면...
            {
                sentence: "또한 공기의 온도가 높아지면 공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양인 포화 수증기량이 증가한다.",
                question: "무엇이 '증가하나요'?",
                correctAnswer: "포화 수증기량",
                distractors: ["공기의 온도", "수증기", "공기의 부피"]
            },
            {
                sentence: "또한 공기의 온도가 높아지면 공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양인 포화 수증기량이 증가한다.",
                question: "포화 수증기량이란?",
                correctAnswer: "공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양",
                distractors: ["현재 공기 중에 있는 수증기의 양", "최소로 필요한 수증기의 양", "온도와 무관한 고정된 양"]
            },
            {
                sentence: "또한 공기의 온도가 높아지면 공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양인 포화 수증기량이 증가한다.",
                question: "공기 온도와 포화 수증기량의 관계는?",
                correctAnswer: "온도가 높아지면 증가한다",
                distractors: ["온도가 높아지면 감소한다", "서로 무관하다", "온도가 높아지면 일정하다"]
            },
            // 문장 4: 반면 건조 과정에서 열에너지가...
            {
                sentence: "반면 건조 과정에서 열에너지가 소모되어 공기의 온도는 드럼으로 유입될 때보다 드럼에서 빠져나올 때 더 낮아진다.",
                question: "무엇이 '낮아지나요'?",
                correctAnswer: "공기의 온도",
                distractors: ["열에너지", "드럼의 온도", "세탁물의 온도"]
            },
            {
                sentence: "반면 건조 과정에서 열에너지가 소모되어 공기의 온도는 드럼으로 유입될 때보다 드럼에서 빠져나올 때 더 낮아진다.",
                question: "공기 온도가 더 낮은 시점은?",
                correctAnswer: "드럼에서 빠져나올 때",
                distractors: ["드럼으로 유입될 때", "건조 시작 시", "건조 완료 시"]
            },
            // 문장 5-1: 드럼에서 빠져나온 습한 공기가...
            {
                sentence: "드럼에서 빠져나온 습한 공기가 열 교환기로 이동하여 냉각된다.",
                question: "무엇이 '냉각되나요'?",
                correctAnswer: "습한 공기",
                distractors: ["열 교환기", "드럼", "수증기"]
            },
            // 문장 5-2: 수증기가 물로 응결되는...
            {
                sentence: "수증기가 물로 응결되는 온도인 이슬점까지 공기의 온도가 낮아지면 수증기가 물로 응축되어 공기의 습도가 낮아지는데, 이때 응축된 물은 건조기 밖으로 배출된다.",
                question: "무엇이 '배출되나요'?",
                correctAnswer: "응축된 물",
                distractors: ["습한 공기", "수증기", "차가운 공기"]
            },
            {
                sentence: "드럼에서 빠져나온 습한 공기가 열 교환기로 이동하여 냉각된다. 수증기가 물로 응결되는 온도인 이슬점까지 공기의 온도가 낮아지면 수증기가 물로 응축되어 공기의 습도가 낮아지는데, 이때 응축된 물은 건조기 밖으로 배출된다.",
                question: "응축 과정의 순서는?",
                correctAnswer: "열교환기 이동 → 이슬점 도달 → 응축 → 배출",
                distractors: ["이슬점 도달 → 열교환기 이동 → 응축 → 배출", "응축 → 이슬점 도달 → 열교환기 이동 → 배출", "배출 → 응축 → 이슬점 도달 → 열교환기 이동"]
            }
        ];

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            renderPassage();
            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 모든 하이라이트 텍스트를 찾아서 교체
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight, 'g');
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                html = html.replace(regex, highlightHTML);
            });

            // 마크다운 처리
            // 제목 처리
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 볼드 처리 (하이라이트 span 태그 내부는 제외)
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                if (match.includes('<span class="highlight"')) return match; // 이미 하이라이트 처리된 것은 건드리지 않음
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                if (match.includes('<span class="highlight"')) return match;
                return `<div class="subsection">• ${content}</div>`;
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            // 2단계 어휘 학습으로 전환
            currentStage = 2;
            initStage2();
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // 단어 → 뜻 문제
                const wordToMeaning = {
                    type: 'word-to-meaning',
                    question: `"${vocab.word}"의 의미는?`,
                    correct: vocab.meaning,
                    word: vocab.word,
                    options: shuffleArray([
                        vocab.meaning,
                        ...vocab.confusors.meaning.slice(0, 3)
                    ])
                };

                // 뜻 → 단어 문제
                const meaningToWord = {
                    type: 'meaning-to-word',
                    question: `"${vocab.meaning}"를 나타내는 용어는?`,
                    correct: vocab.word,
                    meaning: vocab.meaning,
                    options: shuffleArray([
                        vocab.word,
                        ...vocab.confusors.word.slice(0, 3)
                    ])
                };

                stage2Data.questions.push(wordToMeaning, meaningToWord);
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장과 질문 표시
            document.getElementById('sentence-text').textContent = question.sentence;
            document.getElementById('sentence-question').textContent = `Q. ${question.question}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }

        // ================== 4단계: OX퀴즈 ==================
        const stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],  // 틀린 문제 저장
            startTime: null,
            timeRemaining: 120
        };

        // OX퀴즈 데이터
        const oxQuizData = [
            { question: "의류 건조기는 가열 장치를 통해 공기를 가열한 후, 이를 세탁물이 있는 드럼으로 이동시킨다.", answer: "O" },
            { question: "공기의 온도가 낮을수록 포화 수증기량이 증가한다.", answer: "X", explanation: "공기의 온도가 높을수록 포화 수증기량이 증가한다." },
            { question: "항률 건조 구간에서는 건조 속도가 일정하게 유지된다.", answer: "O" },
            { question: "예열 구간은 건조 과정의 마지막 단계이며, 함수율이 가장 낮다.", answer: "X", explanation: "예열 구간은 건조 과정의 시작 단계이며, 함수율이 가장 높다." },
            { question: "뜨거운 공기와 차가운 세탁물 간의 온도 차이로 인해 열전달이 일어난다.", answer: "O" },
            { question: "건조 과정에서 열에너지가 소모되므로 드럼에서 빠져나올 때의 공기 온도가 유입될 때보다 더 높다.", answer: "X", explanation: "열에너지가 소모되므로 빠져나올 때의 온도가 더 낮다." },
            { question: "감률 건조 구간에서는 건조 속도가 점차 감소한다.", answer: "O" },
            { question: "예열 구간에서는 세탁물의 수분이 계속 감소하여 세탁물의 온도가 점차 낮아진다.", answer: "X", explanation: "수분이 계속 감소하여 세탁물의 온도는 점차 높아진다." },
            { question: "응축식 건조기는 수증기를 냉각시켜 물로 바꾸어 배출한다.", answer: "O" },
            { question: "수증기를 액체 상태로 바꾸는 것은 배기식 건조기와 응축식 건조기 모두의 특징이다.", answer: "X", explanation: "수증기를 액체 상태로 바꾸는 것은 응축식 건조기만의 특징이다." },
            { question: "배기식 건조기는 수증기를 기체 상태 그대로 실외로 배출한다.", answer: "O" },
            { question: "응축식 건조기는 외부 공기를 계속 유입시켜 건조를 진행한다.", answer: "X", explanation: "응축식 건조기는 외부 공기를 유입하는 것이 아니라, 내부 공기를 순환시킨다." },
            { question: "건조기 안의 세탁물은 고온의 공기와 만나면서 수축이 발생할 수 있다.", answer: "O" },
            { question: "히트펌프 건조기는 건조 시간이 길지만, 의류 수축이 발생하지 않는다.", answer: "X", explanation: "건조 시간이 짧지만, 의류 수축이 발생할 수 있다." },
            { question: "열 교환기는 뜨거운 유체와 차가운 유체 사이에서 열을 교환하는 장치이다.", answer: "O" },
            { question: "건조 속도는 감률 구간에서 빨라지고, 항률 건조 구간에서 일정하게 유지되며, 예열 구간에서 느려진다.", answer: "X", explanation: "건조 속도는 예열 구간에서 빨라지고, 항률 건조 구간에서 일정하게 유지되며, 감률 구간에서 느려진다." },
            { question: "물 분자들의 운동 에너지가 증가하면 분자들 간의 결합력이 강해져 상변화가 억제된다.", answer: "X", explanation: "결합력이 약해져야 상변화가 활발해진다." },
            { question: "배기식은 열 교환기를, 응축식은 배기 장치를 사용한다.", answer: "X", explanation: "배기식은 배기 장치를, 응축식은 열 교환기를 사용한다." },
            { question: "항률 건조 구간에서는 세탁물의 온도가 일정하게 유지된다.", answer: "O" },
            { question: "공기의 온도가 높아지면 물 분자들의 운동 에너지가 감소한다.", answer: "X", explanation: "공기의 온도가 높아지면 물 분자들의 운동 에너지가 증가한다." }
        ];

        // 4단계 초기화
        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '의류 건조기의 원리';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 4';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer('O', '${question.answer}', this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === 'O' ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === 'O' ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer('X', '${question.answer}', this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === 'X' ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === 'X' ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected,
                    correctAnswer: correct,
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        if (symbol === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 진짜 원문 표시
            const originalText = `열에너지는 항상 고온에서 저온으로 이동하며, 물체와 공기의 온도 차가 클수록 열전달이 활발해진다. 그런데 수분을 포함하고 있는 물체로 열전달이 일어나면 물 분자들의 운동 에너지가 증가하여 분자들 간의 결합력이 약해지기 때문에 기체로의 상변화가 활발해진다. 이러한 원리를 이용하여 어떤 물체에서 수분을 제거하는 것을 건조라 한다. 단위 시간 동안 물체에서 증발하는 수분의 양을 건조 속도라 하고, 다른 조건이 동일할 때 건조 속도는 공기의 온도가 높을수록 빨라진다. 일상에서 건조 속도를 인위적으로 조절하여 생활의 편의를 ⓐ도모하기도 하는데, 의류 건조기를 그 예로 들 수 있다.
의류 건조기는 가열 장치를 통해 공기를 일정 온도까지 가열한 후, 이를 세탁물이 있는 드럼으로 이동시킨다. 건조가 진행되는 동안 드럼으로 일정한 온도의 뜨거운 공기가 계속 유입되는데, 일반적으로 세탁물의 온도가 공기의 온도보다 낮으므로 세탁물로 열전달이 일어난다. 또한 공기의 온도가 높아지면 공기 1m³ 속에 수증기가 최대로 존재할 수 있는 양인 포화 수증기량이 증가한다. 그 결과 같은 부피 내에 더 많은 수증기를 포함할 수 있게 되어 수분 증발이 촉진된다.
한편, 드럼 내부에서 일어나는 건조 과정은 세탁물의 수분 함량 비율인 함수율과 건조 속도에 따라 예열 구간, 항률 건조 구간, 감률 건조 구간으로 구분할 수 있다. 먼저 예열 구간은 건조가 시작되는 구간으로, 고온의 공기에 의해 세탁물의 온도가 상승하며 건조 속도가 빨라진다. 이 구간은 건조 과정 초반이므로 세탁물의 함수율이 가장 높다.
다음으로 항률 건조 구간에서는 세탁물로 전달된 열에너지가 수분 증발에 집중적으로 쓰여 뜨거운 공기가 유입되어도 세탁물의 온도가 더 이상 상승하지 않고 일정하게 유지된다. 또한 세탁물에 공급되는 열에너지가 일정하므로 증발되는 수분의 양도 일정하고, 이 때문에 드럼에서 빠져나오는 공기의 습도도 일정하다. 반면 건조 과정에서 열에너지가 소모되어 공기의 온도는 드럼으로 유입될 때보다 드럼에서 빠져나올 때 더 낮아진다. 건조가 진행되면서 세탁물의 함수율이 점차 감소하면 어느 시점부터는 건조 속도가 느려지기 시작하는데, 이때를 기점으로 항률 건조 구간에서 감률 건조 구간으로 넘어가게 된다.
감률 건조 구간에서는 세탁물에서 증발할 수 있는 수분이 계속 감소하여 건조 속도가 점점 느려진다. 그러다가 주어진 건조 조건에서 최대로 증발될 수 있는 수분이 모두 증발되면 건조 속도가 0이 되어, 더 이상 건조는 진행되지 않고 세탁물의 온도만 높아진다. 또한 건조 종료 직전에는 세탁물의 온도는 높고 수분 함량은 낮아 드럼으로 유입된 공기가 열에너지를 거의 그대로 유지한 채로 드럼에서 배출된다. 따라서 드럼으로 들어가는 공기와 드럼에서 빠져나오는 공기의 온도 차가 줄어든다. 이를 이용하면 건조가 완료되는 시점을 예상하여 건조기 작동을 마치도록 건조기 시스템을 설정할 수 있다.
세탁물에서 증발한 수분은 완전히 ⓑ사라지는 것이 아니라 수증기 상태로 존재하게 되는데, 이를 건조기 밖으로 배출하는 방식에 따라 의류 건조기를 ㉮배기식 건조기와 ㉯응축식 건조기로 구분할 수 있다. 전자는 드럼에서 빠져나온 수증기가 실외로 ⓒ이어지는 별도의 배기 장치를 통해 배출된다. 반면 후자는 수증기가 다시 액체 상태로 바뀌어 물통이나 배수구를 통해 배출되는데, 그 과정은 다음과 같다. 일단 드럼에서 빠져나온 습한 공기가 열 교환기로 이동하여 냉각된다. 수증기가 물로 응결되는 온도인 이슬점까지 공기의 온도가 낮아지면 수증기가 물로 응축되어 공기의 습도가 낮아지는데, 이때 응축된 물은 건조기 밖으로 배출된다. 습도가 낮아진 공기는 가열 과정을 거쳐 다시 드럼으로 유입되고, 이러한 공기의 순환이 반복되며 건조가 진행된다.
이렇듯 의류 건조기를 사용하면 상온에서의 자연 건조보다 건조 시간을 줄일 수 있다. 하지만 건조 과정에서 세탁물이 고온의 공기와 ⓓ맞닿으며 수축될 수 있고, 특히 천연 섬유는 합성 섬유에 비해 더 많은 수축이 ⓔ생기는 편이다. 그래서 최근에는 의류 손상을 최소화하는 방안에 대한 연구가 진행되는 등 보다 발전된 건조기 개발을 위한 노력이 이루어지고 있다.`;

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
            {
                id: 1,
                question: "의류 건조기가 자연 건조보다 빨래를 빠르게 말릴 수 있는 과학적 원리 두 가지를 지문에 근거하여 서술하시오.",
                correctAnswer: "첫째, 고온의 공기를 사용하여 세탁물과의 온도 차를 크게 만들어 열전달을 활발하게 하고 물 분자의 운동 에너지를 증가시킨다. 둘째, 공기의 온도를 높여 공기가 품을 수 있는 수증기의 최대량(포화 수증기량)을 증가시켜 수분 증발을 촉진한다.",
                correctParts: ["첫째, 고온의 공기를 사용하여 세탁물과의 온도 차를 크게 만들어", "열전달을 활발하게 하고 물 분자의 운동 에너지를 증가시킨다. 둘째, 공기의 온도를 높여", "공기가 품을 수 있는 수증기의 최대량(포화 수증기량)을 증가시켜 수분 증발을 촉진한다."],
                distractors: ["첫째, 저온의 공기를 사용하여 세탁물과의 온도 차를 줄여", "열전달을 억제하고 물 분자의 운동 에너지를 감소시킨다. 둘째, 공기의 습도를 낮춰", "공기가 품을 수 있는 수증기의 최소량(포화 수증기량)을 감소시켜 수분 응축을 방해한다."]
            },
            {
                id: 2,
                question: "'항률 건조 구간'에서 뜨거운 공기가 계속 유입됨에도 세탁물의 온도가 일정하게 유지되는 이유를 '열에너지'의 쓰임과 연관 지어 서술하시오.",
                correctAnswer: "항률 건조 구간에서는 세탁물로 전달되는 열에너지가 세탁물의 온도를 높이는 데 쓰이지 않고, 오직 수분을 증발시키는 데에만 집중적으로 사용되기 때문이다.",
                correctParts: ["항률 건조 구간에서는 세탁물로 전달되는 열에너지가", "세탁물의 온도를 높이는 데 쓰이지 않고,", "오직 수분을 증발시키는 데에만 집중적으로 사용되기 때문이다."],
                distractors: ["감률 건조 구간에서는 세탁물로 전달되는 열에너지가", "세탁물의 온도를 높이는 데 주로 사용되고,", "수분을 응축시키는 데에는 간헐적으로만 사용되기 때문이다."]
            },
            {
                id: 3,
                question: "'배기식 건조기'와 '응축식 건조기'가 수증기를 처리하는 방식의 차이점을 서술하시오.",
                correctAnswer: "배기식 건조기는 수증기를 기체 상태 그대로 별도의 배기 장치를 통해 실외로 배출하는 방식이다. 반면 응축식 건조기는 수증기를 열 교환기에서 냉각시켜 액체 상태의 물로 응축시킨 후, 물통이나 배수구를 통해 배출하는 방식이다.",
                correctParts: ["배기식 건조기는 수증기를 기체 상태 그대로 별도의 배기 장치를 통해 실외로 배출하는 방식이다.", "반면 응축식 건조기는 수증기를 열 교환기에서 냉각시켜 액체 상태의 물로 응축시킨 후,", "물통이나 배수구를 통해 배출하는 방식이다."],
                distractors: ["배기식 건조기는 수증기를 액체 상태로 변환하여 열 교환기를 통해 실내로 순환시키는 방식이다.", "반면 응축식 건조기는 수증기를 가열 장치에서 가열시켜 기체 상태의 수증기로 증발시킨 후,", "압축 장치나 냉각기를 통해 배출하는 방식이다."]
            },
            {
                id: 4,
                question: "'감률 건조 구간'에서 건조가 거의 완료되었을 때, 드럼으로 유입되는 공기와 배출되는 공기의 온도 차가 줄어드는 이유를 서술하시오.",
                correctAnswer: "건조가 완료될 시점에는 세탁물에 증발할 수분이 거의 남아있지 않아 수분 증발에 소모되는 열에너지가 거의 없어진다. 따라서 드럼으로 유입된 뜨거운 공기는 열에너지를 거의 그대로 유지한 채 배출되므로, 들어갈 때와 나올 때의 공기 온도 차가 줄어든다.",
                correctParts: ["건조가 완료될 시점에는 세탁물에 증발할 수분이 거의 남아있지 않아", "수분 증발에 소모되는 열에너지가 거의 없어진다. 따라서 드럼으로 유입된 뜨거운 공기는", "열에너지를 거의 그대로 유지한 채 배출되므로, 들어갈 때와 나올 때의 공기 온도 차가 줄어든다."],
                distractors: ["건조가 시작될 시점에는 세탁물에 증발할 수분이 대량으로 남아있어", "수분 응축에 사용되는 열에너지가 급격히 증가한다. 따라서 드럼으로 유입된 차가운 공기는", "열에너지를 대부분 소모한 채 배출되므로, 들어갈 때와 나올 때의 공기 온도 차가 커진다."]
            },
            {
                id: 5,
                question: "친구가 \"건조기를 돌렸더니 아끼는 면 티셔츠가 줄어들었어.\"라고 말했다. 지문의 내용을 바탕으로 그 원인을 설명하고, 왜 그런 현상이 발생했는지 서술하시오.",
                correctAnswer: "건조 과정에서 세탁물이 고온의 공기와 맞닿으면서 수축될 수 있기 때문이다. 특히 친구의 옷이 면 티셔츠, 즉 천연 섬유이므로 합성 섬유에 비해 더 많은 수축이 발생한 것이다.",
                correctParts: ["건조 과정에서 세탁물이 고온의 공기와 맞닿으면서 수축될 수 있기 때문이다.", "특히 친구의 옷이 면 티셔츠, 즉 천연 섬유이므로", "합성 섬유에 비해 더 많은 수축이 발생한 것이다."],
                distractors: ["냉각 과정에서 세탁물이 저온의 공기와 분리되면서 팽창될 수 있기 때문이다.", "특히 친구의 옷이 폴리에스테르, 즉 합성 섬유이므로", "천연 섬유에 비해 더 많은 팽창이 발생한 것이다."]
            },
            {
                id: 6,
                question: "'응축식 건조기'가 드럼 내부의 습한 공기를 제습하여 다시 건조에 활용하는 과정을 순서대로 서술하시오.",
                correctAnswer: "먼저 드럼에서 나온 습한 공기가 열 교환기로 이동하여 냉각된다. 공기 온도가 이슬점까지 낮아지면 수증기가 물로 응축되어 공기의 습도가 낮아진다. 이렇게 습기가 제거된 공기는 다시 가열 과정을 거쳐 드럼으로 유입된다.",
                correctParts: ["먼저 드럼에서 나온 습한 공기가 열 교환기로 이동하여 냉각된다.", "공기 온도가 이슬점까지 낮아지면 수증기가 물로 응축되어 공기의 습도가 낮아진다.", "이렇게 습기가 제거된 공기는 다시 가열 과정을 거쳐 드럼으로 유입된다."],
                distractors: ["먼저 드럼에서 나온 건조한 공기가 가열 장치로 이동하여 가열된다.", "공기 온도가 비등점까지 높아지면 물이 수증기로 증발되어 공기의 습도가 높아진다.", "이렇게 습기가 추가된 공기는 다시 냉각 과정을 거쳐 드럼으로 배출된다."]
            },
            {
                id: 7,
                question: "만약 건조기의 가열 장치가 고장 나 뜨거운 공기를 만들지 못하고 상온의 공기만 드럼으로 보낸다면, 건조 과정은 어떻게 달라질지 '건조 속도'와 '건조 시간'의 측면에서 서술하시오.",
                correctAnswer: "상온의 공기는 세탁물과의 온도 차가 작아 열전달이 비효율적이고 포화 수증기량도 낮다. 따라서 건조 속도가 매우 느려지고, 자연 건조와 비슷한 수준으로 건조 시간이 매우 길어질 것이다.",
                correctParts: ["상온의 공기는 세탁물과의 온도 차가 작아 열전달이 비효율적이고 포화 수증기량도 낮다.", "따라서 건조 속도가 매우 느려지고,", "자연 건조와 비슷한 수준으로 건조 시간이 매우 길어질 것이다."],
                distractors: ["고온의 공기는 세탁물과의 온도 차가 커서 열전달이 매우 효율적이고 포화 수증기량도 높다.", "따라서 건조 속도가 매우 빨라지고,", "인공 건조와 완전히 다른 수준으로 건조 시간이 매우 짧아질 것이다."]
            },
            {
                id: 8,
                question: "지문의 그래프(<보기>)에서 B구간(항률 건조 구간)이 수평선 모양을 띠는 이유를 '건조 속도'와 '열에너지' 개념을 사용하여 서술하시오.",
                correctAnswer: "B구간(항률 건조 구간)에서는 세탁물에 공급되는 열에너지가 일정하고, 이 에너지가 모두 일정한 양의 수분을 증발시키는 데 사용된다. 따라서 단위 시간당 증발하는 수분의 양, 즉 건조 속도가 일정하게 유지되므로 그래프가 수평선 모양을 띤다.",
                correctParts: ["B구간(항률 건조 구간)에서는 세탁물에 공급되는 열에너지가 일정하고,", "이 에너지가 모두 일정한 양의 수분을 증발시키는 데 사용된다.", "따라서 단위 시간당 증발하는 수분의 양, 즉 건조 속도가 일정하게 유지되므로 그래프가 수평선 모양을 띤다."],
                distractors: ["A구간(감률 건조 구간)에서는 세탁물에 공급되는 열에너지가 계속 변화하고,", "이 에너지가 부분적으로 불규칙한 양의 수분을 응축시키는 데 사용된다.", "따라서 단위 시간당 응축되는 수분의 양, 즉 건조 속도가 계속 변화하므로 그래프가 곡선 모양을 띤다."]
            },
            {
                id: 9,
                question: "건조기 사용 설명서에 \"건조기 주변은 환기가 잘 되도록 공간을 확보해주세요.\"라는 문구가 있었다. 특히 '응축식 건조기'의 '열 교환기' 원리와 관련지어 이 문구가 필요한 이유를 추론하여 서술하시오.",
                correctAnswer: "응축식 건조기의 열 교환기는 주변 공기를 이용해 내부의 뜨겁고 습한 공기를 냉각시키는 역할을 한다. 만약 주변 환기가 잘 되지 않아 건조기 주변 온도가 높아지면, 열 교환기의 냉각 효율이 떨어져 수증기를 물로 응축시키는 능력이 저하될 수 있기 때문이다.",
                correctParts: ["응축식 건조기의 열 교환기는 주변 공기를 이용해 내부의 뜨겁고 습한 공기를 냉각시키는 역할을 한다.", "만약 주변 환기가 잘 되지 않아 건조기 주변 온도가 높아지면,", "열 교환기의 냉각 효율이 떨어져 수증기를 물로 응축시키는 능력이 저하될 수 있기 때문이다."],
                distractors: ["배기식 건조기의 가열 장치는 주변 공기를 차단해 외부의 차갑고 건조한 공기를 가열시키는 역할을 한다.", "만약 주변 환기가 너무 잘 되어 건조기 주변 온도가 낮아지면,", "가열 장치의 가열 효율이 높아져 공기를 기체로 증발시키는 능력이 향상될 수 있기 때문이다."]
            },
            {
                id: 10,
                question: "<보기>를 참고하여, '히트펌프 건조기'가 기존 '응축식 건조기'와 가지는 공통점과 차이점을 '에너지 활용' 측면에서 서술하시오.\n\n<보기>\n최신형 의류 건조기에는 '히트펌프' 기술이 적용되기도 한다. 이 기술은 응축식 건조기의 원리를 활용하되, 공기를 냉각시키는 과정에서 발생하는 뜨거운 열(응축열)을 버리지 않고 다시 공기를 데우는 데 재활용한다. 따라서 기존의 가열 장치(히터)만 사용하는 방식보다 에너지 효율이 높다.\n",
                correctAnswer: "공통점은 열 교환기를 통해 수증기를 물로 응축시켜 제습한다는 점이다. 차이점은 기존 응축식 건조기가 공기를 냉각시킬 때 발생한 열을 외부로 버리는 반면, 히트펌프 건조기는 그 열을 다시 공기 가열에 재활용하여 에너지 효율을 높인다는 점이다.",
                correctParts: ["공통점은 열 교환기를 통해 수증기를 물로 응축시켜 제습한다는 점이다.", "차이점은 기존 응축식 건조기가 공기를 냉각시킬 때 발생한 열을 외부로 버리는 반면,", "히트펌프 건조기는 그 열을 다시 공기 가열에 재활용하여 에너지 효율을 높인다는 점이다."],
                distractors: ["공통점은 배기 장치를 통해 공기를 기체로 증발시켜 가습한다는 점이다.", "차이점은 기존 배기식 건조기가 공기를 가열시킬 때 발생한 냉기를 내부에 보관하는 반면,", "히트펌프 건조기는 그 냉기를 바로 공기 냉각에 낭비하여 에너지 효율을 낮춘다는 점이다."]
            }
        ];

        // 5단계 초기화
        function initStage5() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '의류 건조기의 원리';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 15px; margin-bottom: 40px; color: white;">
                        <h2 style="margin-bottom: 25px; font-size: 24px;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; text-align: center;">
                                <div style="font-size: 14px; margin-bottom: 10px; opacity: 0.9;">총점</div>
                                <div style="font-size: 32px; font-weight: bold;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">/ 50.0점</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; text-align: center;">
                                <div style="font-size: 14px; margin-bottom: 10px; opacity: 0.9;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; text-align: center;">
                                <div style="font-size: 14px; margin-bottom: 10px; opacity: 0.9;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #4ade80;">${totalCorrect}개</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; text-align: center;">
                                <div style="font-size: 14px; margin-bottom: 10px; opacity: 0.9;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #f87171;">${totalWrong}개</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; text-align: center;">
                                <div style="font-size: 14px; margin-bottom: 10px; opacity: 0.9;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px;">
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
            // 학습 완료 버튼 추가
            if (typeof addCompleteLearningButton === 'function') {
                setTimeout(() => addCompleteLearningButton(), 500);
            }
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stageResults,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>