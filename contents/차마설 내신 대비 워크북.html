<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이곡 &lt;차마설&gt; 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">이곡 &lt;차마설&gt;</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                {
                    id: 1,
                    text: "이 작품은 구체적 경험에서 보편적 이치를 끌어내는 _____ 형식의 한문 수필입니다.",
                    highlight: "(설 / 기)",
                    options: ["설", "기"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "글은 '말을 빌려 탄 경험'을 통해 _____에 대한 철학적 성찰로 나아갑니다.",
                    highlight: "(소유의 본질 / 말의 중요성)",
                    options: ["소유의 본질", "말의 중요성"],
                    correct: 0
                },
                {
                    id: 3,
                    text: "작가는 진정한 소유란 없음을 경계하며 _____을 지닐 것을 강조합니다.",
                    highlight: "(겸손한 삶의 자세 / 물질적 욕망)",
                    options: ["겸손한 삶의 자세", "물질적 욕망"],
                    correct: 0
                },
                {
                    id: 4,
                    text: "이 작품의 갈래에는 고전 수필, 한문 수필, 그리고 _____이 포함됩니다.",
                    highlight: "(설 / 전)",
                    options: ["설", "전"],
                    correct: 0
                },
                {
                    id: 5,
                    text: "글의 성격은 교훈적, 철학적이며 특히 _____ 성격을 지닙니다.",
                    highlight: "(체험적 / 허구적)",
                    options: ["체험적", "허구적"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "시간적 배경은 고려 후기이며 공간적 배경은 _____으로 제시됩니다.",
                    highlight: "(구체적 장소 / 보편적 일상)",
                    options: ["구체적 장소", "보편적 일상"],
                    correct: 1
                },
                {
                    id: 7,
                    text: "주제는 _____에 근거한 겸손한 삶의 자세 강조입니다.",
                    highlight: "(만물차용설 / 유유자적)",
                    options: ["만물차용설", "유유자적"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "이 작품은 _____의 전형적인 '설' 구조를 보여 줍니다.",
                    highlight: "(경험 → 깨달음 → 일반화 / 서사 → 묘사 → 서술)",
                    options: ["경험 → 깨달음 → 일반화", "서사 → 묘사 → 서술"],
                    correct: 0
                },
                {
                    id: 9,
                    text: "노둔한 말과 준마의 경험을 대비시켜 주제를 부각하는 데 사용된 기법은 _____입니다.",
                    highlight: "(대조 / 열거)",
                    options: ["대조", "열거"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "개인적 경험에서 세상의 이치로 사고를 확장하는 방식은 _____ 사고입니다.",
                    highlight: "(귀납적 / 연역적)",
                    options: ["귀납적", "연역적"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "\"더 말해 무엇하겠는가\"와 같은 표현은 _____을 활용한 예입니다.",
                    highlight: "(설의법 / 반어법)",
                    options: ["설의법", "반어법"],
                    correct: 0
                },
                {
                    id: 12,
                    text: "글의 말미에서 인용된 사상가는 _____입니다.",
                    highlight: "(맹자 / 공자)",
                    options: ["맹자", "공자"],
                    correct: 0
                },
                {
                    id: 13,
                    text: "작가는 집이 가난해 말이 없어 늘 _____을 빌려 탑니다.",
                    highlight: "(남의 말 / 자신의 말)",
                    options: ["남의 말", "자신의 말"],
                    correct: 0
                },
                {
                    id: 14,
                    text: "노둔한 말을 탈 때 작가는 도랑을 만나면 _____ 걷습니다.",
                    highlight: "(말에 탄 채 / 말에서 내려)",
                    options: ["말에 탄 채", "말에서 내려"],
                    correct: 1
                },
                {
                    id: 15,
                    text: "조심스러운 태도 덕분에 노둔한 말을 탈 때는 _____ 안전했습니다.",
                    highlight: "(위험하게 떨어져 / 후회하는 일 없이)",
                    options: ["위험하게 떨어져", "후회하는 일 없이"],
                    correct: 1
                },
                {
                    id: 16,
                    text: "노둔한 말을 탈 때의 심리는 교만이 아니라 _____한 마음입니다.",
                    highlight: "(교만 / 전전긍긍)",
                    options: ["교만", "전전긍긍"],
                    correct: 1
                },
                {
                    id: 17,
                    text: "준마를 얻었을 때 작가는 _____ 방자하게 채찍을 휘두릅니다.",
                    highlight: "(의기양양하여 / 겸손하여)",
                    options: ["의기양양하여", "겸손하여"],
                    correct: 0
                },
                {
                    id: 18,
                    text: "준마를 탔을 때 종종 겪는 위험은 말에서 _____ 못한다는 점입니다.",
                    highlight: "(떨어지는 환란 / 큰 재물)",
                    options: ["떨어지는 환란", "큰 재물"],
                    correct: 0
                },
                {
                    id: 19,
                    text: "준마를 탈 때의 심리는 경계가 아닌 _____으로 요약됩니다.",
                    highlight: "(방심 / 경계)",
                    options: ["방심", "경계"],
                    correct: 0
                },
                {
                    id: 20,
                    text: "작가는 잠깐 빌린 말에도 감정이 달라지는 것을 보고, 만약 그것이 _____라면 방자함이 더 심해질 것이라 경계합니다.",
                    highlight: "(진짜 자기 소유 / 다른 사람의 소유)",
                    options: ["진짜 자기 소유", "다른 사람의 소유"],
                    correct: 0
                },
                {
                    id: 21,
                    text: "이 깨달음은 _____가 인간의 감정과 태도를 흔드는 요소라는 생각으로 이어집니다.",
                    highlight: "(소유 / 무소유)",
                    options: ["소유", "무소유"],
                    correct: 0
                },
                {
                    id: 22,
                    text: "작가는 _____ 가운데 남에게 빌리지 않은 것이 없다고 주장합니다.",
                    highlight: "(사람이 가지고 있는 것 / 사람이 가지고 있지 않은 것)",
                    options: ["사람이 가지고 있는 것", "사람이 가지고 있지 않은 것"],
                    correct: 0
                },
                {
                    id: 23,
                    text: "만물차용설에 따르면 _____은 백성으로부터 힘을 빌립니다.",
                    highlight: "(임금 / 신하)",
                    options: ["임금", "신하"],
                    correct: 0
                },
                {
                    id: 24,
                    text: "그리고 _____은 임금으로부터 권세를 빌린다고 설명됩니다.",
                    highlight: "(신하 / 백성)",
                    options: ["신하", "백성"],
                    correct: 0
                },
                {
                    id: 25,
                    text: "사람들은 빌린 것임을 잊고 _____ 여기게 되는 '미혹된 일'에 빠집니다.",
                    highlight: "(자기가 본래 가지고 있는 것처럼 / 잠시 빌린 것처럼)",
                    options: ["자기가 본래 가지고 있는 것처럼", "잠시 빌린 것처럼"],
                    correct: 0
                },
                {
                    id: 26,
                    text: "'미혹된 일'이 비판하는 태도는 _____입니다.",
                    highlight: "(소유에 집착하는 행위 / 깨달음을 얻는 행위)",
                    options: ["소유에 집착하는 행위", "깨달음을 얻는 행위"],
                    correct: 0
                },
                {
                    id: 27,
                    text: "빌렸던 것을 돌려줄 때 만방의 임금도 _____가 된다고 경고합니다.",
                    highlight: "(독부 / 권신)",
                    options: ["독부", "권신"],
                    correct: 0
                },
                {
                    id: 28,
                    text: "같은 맥락에서 백승의 대부도 _____이 되는 법이라 설명합니다.",
                    highlight: "(고신 / 충신)",
                    options: ["고신", "충신"],
                    correct: 0
                },
                {
                    id: 29,
                    text: "작가는 글의 권위를 더하기 위해 _____의 말을 인용합니다.",
                    highlight: "(공자 / 맹자)",
                    options: ["공자", "맹자"],
                    correct: 1
                },
                {
                    id: 30,
                    text: "결론에서 작가는 모든 것이 빌린 것임을 깨닫고 _____ 자세로 살아야 한다고 강조합니다.",
                    highlight: "(겸손하고 조심하는 / 당당하고 호탕한)",
                    options: ["겸손하고 조심하는", "당당하고 호탕한"],
                    correct: 0
                }
            ],
            fullText: `## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**

**[작품 해제]**

이 작품은 고려 후기의 문신 이곡이 지은 한문 수필입니다. 구체적인 경험이나 사물에 대한 관찰을 통해 얻은 깨달음을 보편적인 이치나 교훈으로 확장하여 서술하는 글의 양식인 (설 / 기)의 대표작입니다. '말을 빌려 탄 경험'에서 시작하여 (소유의 본질 / 말의 중요성)에 대한 깊이 있는 철학적 성찰로 나아가며, 진정한 소유란 없음을 경계하고 (겸손한 삶의 자세 / 물질적 욕망)을 가질 것을 역설하는 교훈적인 작품입니다.

**[핵심 정리 표]**

| 구분 | 내용 |
| :---- | :---- |
| **갈래** | 고전 수필, 한문 수필, (설 / 전) |
| **성격** | 교훈적, 철학적, (체험적 / 허구적), 성찰적 |
| **배경** | 시간적: 고려 후기 공간적: (구체적 장소 / 보편적 일상) |
| **주제** | (만물차용설 / 유유자적)에 근거한 겸손한 삶의 자세 강조 |
| **특징** | 1. (경험 → 깨달음 → 일반화 / 서사 → 묘사 → 서술)의 전형적인 '설' 구조. 2. 노둔한 말과 잘 달리는 준마의 상반된 경험을 (대조 / 열거)하여 주제를 부각. 3. 개인적 경험에서 세상의 이치로 (귀납적 / 연역적) 사고를 확장. 4. "더 말해 무엇하겠는가"와 같은 (설의법 / 반어법)을 사용. 5. 글의 말미에 (맹자 / 공자)의 말을 인용해 논지의 권위를 더함. |

**[전체 내용 및 출제 포인트]**

[서사] 말을 빌려 탄 두 가지 상반된 경험

작가는 집이 가난해서 말이 없기 때문에 (남의 말 / 자신의 말)을 빌려 탄다.

* 노둔하고 야윈 말  
  * 경험: 말이 금방이라도 쓰러질 듯하여 채찍을 대지 못하고, 개천이나 도랑을 만나면 (말에 탄 채 / 말에서 내려) 걷는다.  
  * 결과: 늘 조심했기 때문에 (위험하게 떨어져 / 후회하는 일 없이) 안전했다.  
  * 심리: (교만 / 전전긍긍)하고 경계함.  
* 발굽이 높고 귀가 쫑긋하며 잘 달리는 준마  
  * 경험: 준마를 얻었을 때 (의기양양하여 / 겸손하여) 방자하게 채찍을 갈기고 고삐를 놓는다.  
  * 결과: 매우 유쾌하게 질주하지만, 간혹 위험하게 말에서 (떨어지는 환란 / 큰 재물)을 면하지 못한다.  
  * 심리: (방심 / 경계)하고 자만함.

[의론] 경험의 일반화와 교훈의 도출

* 1단계 깨달음: 소유에 대한 인간의 감정  
  * 작가는 잠깐 빌린 말에도 감정이 이처럼 달라지는 것을 보고, 만약 그것이 (진짜 자기 소유 / 다른 사람의 소유)라면 방자함이 얼마나 더 심해질 것인가를 탄식한다.  
  * 이는 (소유 / 무소유)가 인간의 감정과 태도를 어떻게 흔드는지에 대한 질문을 던진다.  
* 2단계 깨달음: 만물차용설(萬物借用說)  
  * 작가는 (사람이 가지고 있는 것 / 사람이 가지고 있지 않은 것) 가운데 남에게 빌리지 않은 것이 없다고 주장한다.  
  * (임금 / 신하)은 백성으로부터 힘을 빌리고, (신하 / 백성)은 임금으로부터 권세를 빌린다.  
  * 대부분의 사람들은 이 모든 것이 빌린 것임을 잊고 (자기가 본래 가지고 있는 것처럼 / 잠시 빌린 것처럼) 여기는 '미혹된 일'에 빠진다.  
  * '미혹된 일'은 (소유에 집착하는 행위 / 깨달음을 얻는 행위)을 의미한다.  
* 최종 교훈: 경계와 겸손  
  * 빌렸던 것을 돌려주는 일(죽음, 실각 등)이 생기면, 만방의 임금도 (독부 / 권신)가 되고 대부도 (고신 / 충신)이 된다.  
  * 작가는 마지막에 (공자 / 맹자)의 말을 인용하며, 모든 것이 빌린 것임을 깨닫고 항상 (겸손하고 조심하는 / 당당하고 호탕한) 자세로 살아야 한다는 교훈을 전달한다.`
        };


        // 2단계: 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "만물차용설(萬物借用說)",
                meaning: "세상의 모든 것은 잠시 빌려 쓰는 것에 불과하다는 이곡의 철학적 주장.",
                type: "핵심 사상",
                confusors: {
                    word: ["무소유(無所有)", "만물연기설(萬物緣起說)", "유물론(唯物論)"],
                    meaning: ["아예 소유하지 않음을 이상으로 삼는 태도.", "모든 존재가 인연으로 생겨남을 강조한 불교 사상.", "물질을 근본으로 삼아 정신을 부차적이라고 보는 철학." ]
                }
            },
            {
                word: "미혹(迷惑)",
                meaning: "사리에 어두워 옳고 그름을 분별하지 못하고 집착하는 상태.",
                type: "핵심 개념",
                confusors: {
                    word: ["각성(覺醒)", "통찰(洞察)", "깨우침"],
                    meaning: ["잘못을 뉘우치고 정신을 차림.", "사물의 구조와 본질을 꿰뚫어 봄.", "새로운 사실이나 이치를 알아차림." ]
                }
            },
            {
                word: "고신(孤臣)",
                meaning: "의지할 곳 없이 외롭게 된 신하, 권세를 잃은 대부를 비유함.",
                type: "인물/신분",
                confusors: {
                    word: ["충신(忠臣)", "권신(權臣)", "열사(烈士)"],
                    meaning: ["임금에게 충성을 다하는 신하.", "권력을 잡고 국정을 좌우하는 신하.", "의로운 일에 목숨을 바친 사람." ]
                }
            },
            {
                word: "독부(獨夫)",
                meaning: "백성의 지지를 잃고 홀로 남은 임금을 비유한 표현.",
                type: "인물/신분",
                confusors: {
                    word: ["천자(天子)", "재상(宰相)", "태수(太守)"],
                    meaning: ["천하를 다스리는 임금이라는 존칭.", "나라의 정사를 총괄하던 고위 관직.", "한 고을을 다스리던 지방 관리." ]
                }
            },
            {
                word: "준마(駿馬)",
                meaning: "힘이 좋고 빨리 달리는 훌륭한 말.",
                type: "소재의 상징",
                confusors: {
                    word: ["노둔마(駑鈍馬)", "역마(驛馬)", "애마(愛馬)"],
                    meaning: ["둔하고 느린 말.", "역참에서 공문을 나르는 데 쓰던 말.", "특별히 아끼는 말." ]
                }
            },
            {
                word: "노둔마(駑鈍馬)",
                meaning: "둔하고 힘이 약해 잘 달리지 못하는 말.",
                type: "소재의 상징",
                confusors: {
                    word: ["준마(駿馬)", "군마(軍馬)", "천리마(千里馬)"],
                    meaning: ["힘이 좋고 빨리 달리는 말.", "군대에서 사용하는 말.", "하루에 천리를 달린다고 비유되는 아주 빠른 말." ]
                }
            },
            {
                word: "환란(患亂)",
                meaning: "근심과 재앙을 아울러 이르는 말.",
                type: "사건/상황",
                confusors: {
                    word: ["길상(吉祥)", "안녕(安寧)", "평화"],
                    meaning: ["좋은 징조나 상서로운 기운.", "걱정이나 근심 없이 편안함.", "전쟁이나 다툼이 없이 조화로운 상태." ]
                }
            },
            {
                word: "전전긍긍(戰戰兢兢)",
                meaning: "몹시 두려워하여 조심하는 태도.",
                type: "정서/태도",
                confusors: {
                    word: ["태연자약(泰然自若)", "호기롭다", "활달하다"],
                    meaning: ["마음이 편안하여 조금도 두려워하거나 놀라지 않음.", "기운차고 씩씩하여 두려운 기색이 없음.", "성격이 활발하고 거리낌이 없음." ]
                }
            },
            {
                word: "비복(婢僕)",
                meaning: "계집종과 사내종을 아울러 이르는 말.",
                type: "고전 어휘",
                confusors: {
                    word: ["사환(使喚)", "서리(胥吏)", "사족(士族)"],
                    meaning: ["잡일을 시키거나 심부름을 하는 하인.", "조선 시대에 문서 업무를 맡던 하급 관리.", "벼슬하거나 선비로 살던 양반 계층." ]
                }
            }
        ];

        // 3단계 문장 독해 데이터
        const sentenceData = [
            {
                sentence: "노둔하고 야윈 말을 얻었을 경우에는 일이 아무리 급해도 감히 채찍을 대지 못한 채 금방이라도 쓰러지고 넘어질 것처럼 전전긍긍하기 일쑤요, 개천이나 도랑이라도 만나면 또 말에서 내리곤 한다.",
                question: "이 문장에서 '말에서 내리곤 한다' 행동이 드러내는 태도는 무엇인가요?",
                correctAnswer: "작은 위험도 경계하며 환란을 피하려는 조심스러운 마음",
                distractors: [
                    "노둔한 말을 단련시켜 더 빠르게 만들려는 계획",
                    "노둔한 말을 버리고 새 말을 구하려는 계산",
                    "말 주인에게 잘 보이려는 체면 의식"
                ]
            },
            {
                sentence: "반면에 발굽이 높고 귀가 쫑긋하며 잘 달리는 준마를 얻었을 경우에는 의기양양하여 방자하게 채찍을 갈기기도 하고 고삐를 놓기도 하면서 언덕과 골짜기를 모두 평지로 간주한 채 매우 유쾌하게 질주하곤 한다.",
                question: "이 문장에서 '환란을 면하지 못한' 근본적인 원인은 무엇인가요?",
                correctAnswer: "의기양양한 교만과 방심이 겹친 태도",
                distractors: [
                    "준마의 체력이 바닥난 상태",
                    "험한 지형 때문에 생긴 우연한 사고",
                    "동행자가 고삐를 잡아당긴 방해"
                ]
            },
            {
                sentence: "아, 사람의 감정이라는 것이 어쩌면 이렇게까지 달라지고 뒤바뀔 수가 있단 말인가. 남의 물건을 빌려서 잠깐 동안 쓸 때에도 오히려 이와 같은데, 하물며 진짜로 자기가 가지고 있는 경우야 더 말해 무엇하겠는가.",
                question: "이 탄식이 대비하는 두 가지 감정의 조합은 무엇인가요?",
                correctAnswer: "노둔마를 탈 때의 전전긍긍과 준마를 탈 때의 의기양양",
                distractors: [
                    "노둔마를 탈 때의 분노와 준마를 탈 때의 절망",
                    "노둔마를 탈 때의 환희와 준마를 탈 때의 허무",
                    "노둔마를 탈 때의 태연과 준마를 탈 때의 혼란"
                ]
            },
            {
                sentence: "그렇긴 하지만 사람이 가지고 있는 것 가운데 남에게 빌리지 않은 것이 또 뭐가 있다고 하겠는가.",
                question: "이 문장이 선언하는 핵심 철학은 무엇인가요?",
                correctAnswer: "만물차용설, 곧 모든 소유가 잠시 빌린 것이라는 통찰",
                distractors: [
                    "인간은 스스로 서야 한다는 자립 사상",
                    "권력은 나눠 쓸수록 커진다는 통치 이론",
                    "자연으로 돌아가야 한다는 순응 사상"
                ]
            },
            {
                sentence: "대부분 자기가 본래 가지고 있는 것처럼 여기기만 할 뿐 끝내 돌이켜 보려고 하지 않는다. 이 어찌 미혹된 일이 아니겠는가.",
                question: "여기서 '미혹된 일'이 비판하는 태도는 무엇인가요?",
                correctAnswer: "빌린 것을 자기 소유로 착각하여 집착하는 어리석음",
                distractors: [
                    "남에게 베푸는 일을 지나치게 즐기는 습성",
                    "새로운 지식을 알려고 하지 않는 무관심",
                    "과거의 실수를 잊어버리는 낙천성"
                ]
            },
            {
                sentence: "그러다가 혹 잠깐 사이에 그동안 빌렸던 것을 돌려주는 일이 생기게 되면, 만방의 임금도 독부가 되고 백승의 대부도 고신이 되는 법인데, 더군다나 미천한 자의 경우야 더 말해 무엇하겠는가.",
                question: "'빌렸던 것을 돌려주는 일'이 상징하는 현실은 무엇인가요?",
                correctAnswer: "죽음이나 권력 상실처럼 소유가 끝나는 순간",
                distractors: [
                    "새로운 재물을 얻는 기회",
                    "타인을 용서하고 화해하는 순간",
                    "몰래 숨겨 둔 보물을 드러내는 일"
                ]
            },
            {
                sentence: "맹자가 말하기를 \"오래도록 차용하고서 반환하지 않았으니, 그들이 자기의 소유가 아니라는 것을 어떻게 알았겠는가.\"라고 하였다.",
                question: "작가는 왜 이 맹자의 말을 인용했나요?",
                correctAnswer: "개인적 경험을 보편적 진리로 격상시키며 논지에 권위를 부여하려고",
                distractors: [
                    "맹자를 비판하여 새로운 학설을 제시하려고",
                    "독자에게 한문 번역 실력을 보여 주려고",
                    "당대 유학자들과 우정을 과시하려고"
                ]
            }
        ];

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 4단계 전용 변수
        let stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],
            startTime: 0,
            timeRemaining: 120,
            maxTime: 120
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            renderPassage();
            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 마크다운 처리 (하이라이트 처리 전에 먼저 실행)
            // 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (마크다운 테이블을 HTML 테이블로 변환)
            const tableRegex = /^\|.+\|$/gm;
            const tableMatches = [];
            let match;
            while ((match = tableRegex.exec(html)) !== null) {
                tableMatches.push(match.index);
            }

            if (tableMatches.length > 0) {
                // 테이블 라인들을 찾아서 그룹화
                let i = 0;
                while (i < tableMatches.length) {
                    let tableStart = tableMatches[i];
                    let tableEnd = tableMatches[i];
                    let j = i + 1;

                    // 연속된 테이블 라인 찾기
                    while (j < tableMatches.length && tableMatches[j] - tableEnd < 100) {
                        tableEnd = tableMatches[j];
                        j++;
                    }

                    // 테이블 텍스트 추출
                    let beforeTable = html.substring(0, tableStart);
                    let afterTable = html.substring(tableEnd + html.substring(tableEnd).indexOf('\n') + 1);
                    let tableText = html.substring(tableStart, tableEnd + html.substring(tableEnd).indexOf('\n'));

                    const lines = tableText.split('\n').filter(line => line.trim().startsWith('|'));

                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0;">';
                    let rowIndex = 0;

                    lines.forEach((line) => {
                        // 구분선 스킵
                        if (line.match(/^\|\s*:?-+:?\s*\|/)) return;

                        const cells = line.split('|').slice(1, -1); // 첫번째와 마지막 빈 요소 제거
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f8f9fa; font-weight: 600;' : '';

                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<${tag} style="border: 1px solid #ddd; padding: 12px; text-align: left; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHTML += '</tr>';
                        rowIndex++;
                    });

                    tableHTML += '</table>';
                    html = beforeTable + tableHTML + afterTable;

                    i = j;
                }
            }

            // 볼드 처리
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                return `<div class="subsection">• ${content}</div>`;
            });

            // 하이라이트 처리 (마지막에 실행 - HTML 변환된 내용에 적용)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                } else if (currentStage === 5) {
                    stage5Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            } else if (currentStage === 5) {
                stage5Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            } else if (currentStage === 5) {
                stage5Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            // 2단계 어휘 학습으로 전환
            currentStage = 2;
            initStage2();
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // 단어 → 뜻 문제
                const wordToMeaning = {
                    type: 'word-to-meaning',
                    question: `"${vocab.word}"의 의미는?`,
                    correct: vocab.meaning,
                    word: vocab.word,
                    options: shuffleArray([
                        vocab.meaning,
                        ...vocab.confusors.meaning.slice(0, 3)
                    ])
                };

                // 뜻 → 단어 문제
                const meaningToWord = {
                    type: 'meaning-to-word',
                    question: `"${vocab.meaning}"를 나타내는 용어는?`,
                    correct: vocab.word,
                    meaning: vocab.meaning,
                    options: shuffleArray([
                        vocab.word,
                        ...vocab.confusors.word.slice(0, 3)
                    ])
                };

                stage2Data.questions.push(wordToMeaning, meaningToWord);
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장과 질문 표시
            document.getElementById('sentence-text').textContent = question.sentence;
            document.getElementById('sentence-question').textContent = `Q. ${question.question}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }


        const oxQuizData = [
            { question: "작가는 노둔마를 얻었을 때 후회하는 일이 거의 없었다.", answer: true, explanation: "조심스럽게 말을 다루었기에 후회할 상황이 생기지 않았다고 회상한다." },
            { question: "준마를 탔을 때 의기양양했던 것은 작가가 본래 오만한 성격이었음을 보여준다.", answer: false, explanation: "교만은 성격이 아니라 소유 조건이 바뀌면서 생긴 태도 변화로 묘사된다." },
            { question: "노둔마와 준마에 대한 경험은 인간의 이중적인 감정을 대조적으로 보여준다.", answer: true, explanation: "두 마리에 대한 상반된 태도를 통해 감정의 변화가 극명하게 대비된다." },
            { question: "작가는 남의 물건을 빌려서 쓰는 경우보다 자기 물건일 때 더 조심하게 된다고 생각했다.", answer: false, explanation: "오히려 자기 소유라고 여기면 더 방자해질 것이라고 경계한다." },
            { question: "'임금은 백성으로부터 힘을 빌리는 것'에서 만물차용설의 논리를 엿볼 수 있다.", answer: true, explanation: "권력 역시 타인에게 빌린 것이라는 만물차용설의 확장을 보여 준다." },
            { question: "'미혹된 일'은 빌린 것을 돌려줘야 할 순간을 잊고 소유에 집착하는 태도를 의미한다.", answer: true, explanation: "빌린 것을 자기 것처럼 여기는 어리석은 집착을 비판한다." },
            { question: "작가는 자신이 말이 없기 때문에 노둔마를 탔을 때 더 방자하게 굴었다고 고백한다.", answer: false, explanation: "노둔마를 탈 때는 전전긍긍하며 더욱 조심했다고 서술한다." },
            { question: "노둔마를 탔을 때 '전전긍긍'한 것은 말에서 떨어져 다칠 것을 두려워한 심리 때문이다.", answer: true, explanation: "말이 쓰러지면 자신도 환란을 겪을까 두려워한 마음이 담겨 있다." },
            { question: "'언덕과 골짜기를 모두 평지로 간주'한 태도는 준마의 뛰어난 성능에 대한 겸손한 반응이다.", answer: false, explanation: "평지로 여기고 질주하는 모습은 교만과 방심을 드러낸다." },
            { question: "'빌렸던 것을 돌려주는 일'은 권력의 상실이나 죽음을 비유하는 표현이다.", answer: true, explanation: "소유가 끝나는 순간을 가리켜 만물차용설의 경고를 강조한다." },
            { question: "'독부'와 '고신'은 모두 소유물을 잃고 외로운 처지가 된 임금과 대부를 비유한다.", answer: true, explanation: "힘과 권세를 잃은 최고 신분의 비참한 결말을 상징한다." },
            { question: "맹자의 말을 인용한 것은 자신의 주장을 보편적인 진리로 확장하고 권위를 부여하기 위함이다.", answer: true, explanation: "고전 인용으로 논지의 설득력과 보편성을 강화한다." },
            { question: "준마를 얻었을 때에도 말에서 떨어지는 '환란'을 겪는 것은 방자한 태도의 결과이다.", answer: true, explanation: "교만하게 고삐를 놓고 채찍을 휘두른 탓에 환란이 찾아온다." },
            { question: "작가는 '말을 빌려 탄 경험'을 통해 '소유의 본질'이라는 일반적 진리를 귀납적으로 도출한다.", answer: true, explanation: "구체적 체험에서 만물차용설이라는 보편적 이치를 끌어낸다." },
            { question: "이 글은 경험 → 일반화의 2단 구성을 취하며, 일상적 경험에 대한 철학적 성찰을 담고 있다.", answer: true, explanation: "경험을 제시한 뒤 일반화로 나아가는 '설'의 전형을 따른다." },
            { question: "'자식은 어버이에게서, 지어미는 지아비에게서' 빌리는 것이 많다는 것은 만물차용설과 관련이 없다.", answer: false, explanation: "가족 관계 역시 빌림의 예로 들며 만물차용설을 뒷받침한다." },
            { question: "작가는 준마를 탈 때 느낀 유쾌함을 긍정하며 독자에게도 자유로운 삶을 살 것을 권유한다.", answer: false, explanation: "유쾌함보다 환란을 경계해야 한다는 교훈을 강조한다." },
            { question: "'전전긍긍'한 태도는 작가가 궁극적으로 추구해야 할 겸손한 자세와 연결된다.", answer: true, explanation: "조심스러움이야말로 겸손한 삶의 태도라고 제시된다." },
            { question: "노둔마를 탔을 때 개천이나 도랑에서 말에서 내린 것은 말이 상할까 봐 걱정했기 때문이다.", answer: true, explanation: "말과 자신 모두의 안전을 위해 내려 걷는 행동이었다." },
            { question: "'오래도록 차용하고서 반환하지 않았으니'라는 맹자의 말은 소유에 대한 인간의 방자함을 비판한다.", answer: true, explanation: "빌린 것을 자기 것이라 착각하는 태도를 꾸짖는 인용이다." }
        ];

        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '이곡 <차마설>';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 진짜 원문 표시
            const originalText = `대구에서 서울로 올라오는 차중에서 생긴 일이다. 나는 나와 마주 앉은 그를 매우 흥미있게 바라보고 또 바라보았다. 두루마기 격으로 기모노를 둘렀고, 그 안에서 옥양목 저고리가 내어 보이며 아랫도리엔 중국식 바지를 입었다. 그것은 그네들이 흔히 입는 유지 모양으로 번질번질한 암갈색 피륙으로 지은 것이었다. 그리고 발은 감발을 하였는데 짚신을 신었고, 고무가리로 깎은 머리엔 모자도 쓰지 않았다. 우연히 이따금 기묘한 모임을 꾸민 것이다. 우리가 자리를 잡은 찻간에는 공교롭게 세 나라 사람이 다 모였으니, 내 옆에는 중국 사람이 기대었다. 그의 옆에는 일본 사람이 앉아 있었다. 그는 동양 삼국옷을 한몸에 감은 보람이 있어 일본말도 곧잘 철철 대이거니와 중국말에도 그리 서툴지 않은 모양이었다.

"고꼬마데 오이데 데스까?(어디까지 가십니까?)"하고 첫마디를 걸더니만, 도꼬가 어떠니, 오사까가 어떠니, 조선 사람은 고추를 끔찍이 많이 먹는다는 둥, 일본 음식은 너무 싱거워서 처음에는 속이 뉘엿걸다는 둥, 횡설수설 지껄이다가 일본 사람이 엄지와 검지 손가락으로 짧게 끊은 꼿꼿한 윗수염을 비비면서 마지못해 까땍까땍하는 고개와 함께 "소데스까(그렇습니까)"란 한 마디로 코대답을 할 따름이요, 잘 받아 주지 않으매, 그는 또 중국인을 붙들고서 실랑이를 하였다. "니상나열취……" "니싱섬마"하고 덤벼 보았으나 중국인 또한 그 기름낀 뚜우한 얼굴에 수수께끼 같은 웃음을 띨 뿐이요 별로 대구를 하지 않았건만, 그래도 무어라고 연해 웅얼거리면서 나를 보고 웃어 보였다.

그것은 마치 짐승을 놀리는 요술장이가 구경꾼을 바라볼 때처럼 훌륭한 재주를 갈채해 달라는 웃음이었다. 나는 쌀쌀하게 그의 시선을 피해 버렸다. 그 주적대는 꼴이 어줍지 않고 밉살스러웠다. 그는 잠깐 입을 닫치고 무료한 듯이 머리를 덕억덕억 긁기도 하며, 손톱을 이로 물어뜯기도 하고, 멀거니 창 밖을 내다보기도 하다가, 암만해도 중절대지 않고는 못 참겠던지 문득 나에게로 향하며, "어디꺼정 가는 기오?"라고 경상도 사투리로 말을 붙인다.

"서울까지 가요."

"그런기오. 참 반갑구마. 나도 서울꺼정 가는데. 그러면 우리 동행이 되겠구마."

나는 이 지나치게 반가와하는 말씨에 대하여 무어라고 대답할 말도 없고, 또 굳이 대답하기도 싫기에 덤덤히 입을 닫쳐 버렸다.

"서울에 오래 살았는기요?" 그는 또 물었다.

"육칠년이나 됩니다." 조금 성가시다 싶었으되, 대꾸 않을 수도 없었다.

"에이구, 오래 살았구마, 나는 처음길인데 우리 같은 막벌이군이 차를 내려서 어디로 찾아가야 되겠는기요? 일본으로 말하면 기전야도 같은 것이 있는기오?"

하고 그는 답답한 제 신세를 생각했던지 찡그려 보았다. 그때 나는 그의 얼굴이 웃기보다 찡그리기에 가장 적당한 얼굴임을 발견하였다. 군데군데 찢어진 겅성드뭇한 눈썹이 올올이 일어서며, 아래로 축 처지는 서슬에 양미간에는 여러 가닥 주름이 잡히고, 광대뼈 위로 뺨살이 실룩실룩 보이자 두 볼은 쪽 빨아든다. 입은 소태나 먹은 것처럼 왼편으로 삐뚤어지게 찢어 올라가고, 죄던 눈엔 눈물이 괸 듯 삼십 세밖에 안되어 보이는 그 얼굴이 10년 가량은 늙어진 듯하였다. 나는 그 신산스러운 표정에 얼마쯤 감동이 되어서 그에게 대한 반감이 풀려지는 듯하였다.

"글쎄요, 아마 노동 숙박소란 것이 있지요."

노동 숙박소에 대해서 미주알고주알 묻고 나서,

"시방 가면 무슨 일자리를 구하겠는기오?"라고 그는 매달리는 듯이 또 꽤쳤다.

"글쎄요, 무슨 일자리를 구할 수 있을는지요." 나는 내 대답이 너무 냉랭하고 불친절한 것이 죄송스러웠다. 그러나 일자리에 대하여 아무 지식이 없는 나로서는 이외에 더 좋은 대답을 해 줄 수가 없었던 것이다. 그 대신 나는 은근하게 물었다.

"어디서 오시는 길입니까?"

"흠, 고향에서 오누마."하고 그는 휘 한숨을 쉬었다. 그러자, 그의 신세타령의 실마리는 풀려 나왔다. 그의 고향은 대구에서 멀지 않은 K군 H란 외따른 동리였다. 한 백호 남짓한 그곳 주님은 전부가 역둔토를 파먹고 살았는데, 역둔토로 말하면 사삿집 땅을 부치는 것보다 떨어지는 것이 후하였다. 그러므로 넉넉지는 못할망정 평화로운 농촌으로 남부럽지 않게 지낼 수 있었다. 그러나 세상이 뒤바뀌자 그 땅은 전부가 동양 척식 회사의 소유에 들어가고 말았다. 직접으로 회사에 소작료를 바치게 되었으면 그래도 나으련만 소위 중간 소작인이란 것이 생겨나서 저는 손에 흙 한 번 만져 보지도 않고 동척엔 소작인 노릇을 하며, 실지인에게는 지주 행세를 하게 되었다. 동척에 소작료를 물고 나서 또 중간 소작료인에게 긁히고 보니, 실작인의 손에는 소출이 3할도 떨어지지 않았다. 그후로 \<죽겠다, 못 살겠다\>하는 소리는 중이 염불하듯 그들의 입길에서 오르내리게 되었다. 남부여대하고 타처로 유리하는 사람만 늘고 동리는 점점 쇠진해갔다.

지금으로부터 9년 전, 그가 열일곱 살 되던 해 봄에(그의 나이는 실상 스물여섯이었다. 가난과 고생이 얼마나 사람을 늙히는가?) 그의 집안은 살기 좋다는 바람에 서간도로 이사를 갔었다. 쫓겨가는 운명이거든 어디를 간들 신신하랴. 그곳의 비옥한 전야도 그들을 위하여 열려질 리 없었다. 조금 좋은 땅은 먼저 간 이가 모조리 차지하였고 황무지는 비록 많다 하나 그곳 당도하던 날부터 아침거리 저녁거리 걱정이랴. 무슨 행세로 적어도 1년이란 장구한 세월을 먹고 입어 가며 거친 땅을 풀 수가 있으랴. 남의 밑천을 얻어서 농사를 짓고 보니, 가을이 되어 얻는 것은 빈주먹뿐이었다. 이태 동안을 사는 것이 아니라 억지로 버티어 갈 제, 그의 아버지는 망연히 병을 얻어 타국의 외로운 혼이 되고 말았다. 열아홉 살밖에 안된 그가 홀어머니를 보시고 악으로 악으로 모진 목숨을 이어가는 중 4년이 못되어 영양 부족한 몸이 심한 노동에 지친 탓으로 그의 어머니 또한 죽고 말았다.

"모친까장 돌아갔구마." "돌아가실 때 흰죽 한 모금도 못 자셨구마."하고 이야기하던 이는 문득 말을 뚝 끊는다. 나는 무엇이라고 위로할 말을 몰랐다. 한동안 머뭇머뭇이 있다가 나는 차를 탈 때에 친구들이 사준 정종병 마개를 빼었다. 찻잔에 부어서 그도 마시고 나도 마셨다. 악착한 운명이 던져 준 깊은 슬픔을 술로 녹이려는 듯이 연거푸 다섯 잔을 마시는 그는 다시 말을 계속하였다. 그후 그는 부모 잃은 땅에 오래 머물기 싫었다. 신의주로, 안동현으로 품을 팔다가 일본으로 또 벌이를 찾아가게 되었다. 규슈 탄광에 있어도 보고, 오사까 철공장에도 몸을 담아 보았다. 벌이는 조금 나았으나 외롭고 젊은 몸은 자연히 방탕해졌다. 돈을 모으려야 모을 수 없고 이따금 울화만 치받치기 때문에 한곳에 주접을 하고 있을 수 없었다. 화도 나고 고국 산천이 그립기도 하여서 훌쩍 뛰어나왔다가 오래간만에 고향을 둘러보고 벌이를 구할 겸 서울로 올라가는 길이라 했다.

"고향에 가시니 반가워하는 사람이 있습디까?" 나는 탄식하였다.

"반가워하는 사람이 다 뮌기오, 고향이 통 없어졌더마."

"그렇겠지요. 9년 동안이나 퍽 변했겠지요."

"변하고 뭐고 간에 아무것도 없더마. 집도 없고, 사람도 없고, 개 한 마리도 얼씬을 않더마."

"그러면, 아주 폐농이 되었단 말씀이오?"

"흥, 그렇구마. 무너지다 만 담만 즐비하게 남았드마. 우리 살던 집도 터야 안 남았는기오, 암만 찾아도 못 찾겠더마. 사람 살던 동리가 그렇게 된 것을 혹 구경했는기오?"

하고 그의 짜는 듯 한 목은 높아졌다.

"썩어 넘어진 서까래, 뚤뚤 구르는 주추는\! 꼭 무덤을 파서 해골을 헐어 젖혀놓은 것 같더마. 세상에 이런 일도 있는기오? 백여호 살던 동리가 10년이 못 되어 통 없어지는 수도 있는기오, 후\!"

하고 그는 한숨을 쉬며, 그때의 광경을 눈앞에 그리는 듯이 멀거니 먼산을 보다가 내가 따라 준 술을 꿀꺽 들이켜고,

"참\! 가슴이 터지더마, 가슴이 터져"

하자마자 굵직한 눈물 둬 방울이 뚝뚝 떨어진다.

나는 그 눈물 가운데 음산하고 비참한 조선의 얼굴을 똑똑히 본 듯 싶었다.

이윽고 나는 이런 말을 물었다.

"그래, 이번 길에 고향 사람은 하나도 못 만났습니까?"

"하나 만났구마, 단지 하나."

"친척되는 분이던가요?"

"아니구마, 한 이웃에 살던 사람이구마."하고 그의 얼굴은 더욱 침울했다.

"여간 반갑지 않으셨지어요."

"반갑다마다, 죽은 사람을 만난 것 같더마. 더구나 그 사람은 나와 까닭도 좀 있던 사람인데……"

"까닭이라니?"

"나와 혼인 말이 있던 여자구마."

"하아\!" 나는 놀란 듯이 벌린 입이 닫혀지지 않았다.

"그 신세도 내 신세만 하구마."

하고 그는 또 이야기를 계속하였다. 그 여자는 자기보다 나이 두 살 위였는데, 한이웃에 사는 탓으로 같이 놀기도 하고 싸우기도 하며 자라났다. 그가 열 네살 적부터 그들 부모들 사이에 혼인 말이 있었고 그도 어린 마음에 매우 탐탁하게 생각하였었다. 그런데 그 처녀가 열일곱 살 된 겨울에 별안간 간 곳을 모르게 되었다. 알고 보니, 그 아버지되는 자가 20원을 받고 대구 유곽에 팔아먹은 것이었다. 그 소문이 퍼지자 그 차녀 가족은 그 동리에서 못 살고 멀리 이사를 갔는데 그 후로는 물론 피차에 한 번 만나 보지도 못하였다. 이번에야 빈터만 남은 고향을 구경하고 돌아오는 길에 읍내에서 그 아내될 뻔한 댁과 마주치게 되었다.

처녀는 어떤 일본 사람 집에서 아이를 보고 있었다. 궐녀는 20원 몸값을 10년을 두고 갚았건만 그래도 주인에게 빚이 60원이나 남았었는데, 몸에 몹쓸 병이 들어 나이 늙어져서 산송장이 되니까. 주인되는 자가 특별히 빚을 탕감해 주고, 작년 가을에야 놓아 준 것이었다.

궐녀도 자기와 같이 10년 동안이나 그리던 고향에 찾아오니까 거기에는 집도 없고, 부모도 없고 쓸쓸한 돌무더기만 눈물을 자아낼 뿐이었다. 하루해를 울어 보내고 읍내로 들어와서 돌아다니다가, 10년 동안에 한 마디 두 마디 배워 두었던 일본말 덕택으로 그 일본 집에 있게 되었던 것이다.

"암만 사람이 변하기로 어째 그렇게도 변하는기오? 그 숱 많던머리가 훌렁 다 벗을졌두마. 눈을 푹 들어가고 그 이들이들하던 얼굴빛도 마치 유산을 끼얹은 듯하더마."

"서로 붙잡고 많이 우셨겠지요"

"눈물도 안 나오더마. 일본 우동집에 들어가서 둘이서 정종만 열병 때려뉘고 헤어졌구마."

하고 가슴을 짜는 듯한 괴로운 한숨을 쉬더니만 그는 지난 슬픔을 새록새록 자아내어 마음을 새기기에 지쳤음이더라.

"이야기를 다하면 뭐하는기오."

하고 쓸쓸하게 입을 다문다.

나 또한 너무도 참혹한 사람살이를 듣기에 쓴물이 났다.

"자, 우리 술이나 마자 먹읍시다."

하고 우리는 주거니받거니 한되 병을 다 말리고 말았다. 그는 취흥에 겨워서 우리가 어릴 때 멋모르고 부르던 노래를 읊조렸다.

볏섬이나 나는 전토는

신작로가 되고요……

말마디나 하는 친구는

감옥소로 가고요……

담뱃대나 떠는 노인은

공동묘지 가고요……

인물이나 좋은 계집은

유곽으로 가고요……`;

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="initStage5()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
            {
                id: 1,
                question: "작가는 '노둔한 말'과 '준마'를 탈 때 드러나는 '나'의 태도가 어떻게 대조되는지 설명하고, 이 대비가 작품의 주제 의식에 어떤 기여를 하는지 서술하시오.",
                correctAnswer: "노둔한 말을 탈 때 '나'는 말이 다칠까 봐 전전긍긍하며 채찍을 대지 않는 겸손하고 조심스러운 태도를 보인다. 반대로 준마를 얻으면 의기양양하여 방자하게 채찍을 휘두르고 언덕과 골짜기를 평지처럼 질주하는 오만한 태도로 변한다. 이러한 극명한 대비는 소유물의 질에 따라 인간의 감정이 얼마나 쉽게 교만으로 기울 수 있는지를 보여 주어, 만물차용설에 근거한 겸손의 주제를 강조한다.",
                correctParts: [
                    "노둔한 말을 탈 때는 말이 다칠까 봐 전전긍긍하며 채찍을 대지 않는 겸손한 태도를 보였다.",
                    "준마를 얻으면 의기양양하여 방자하게 채찍을 휘두르고 평지처럼 질주하는 오만한 태도로 변한다.",
                    "이 대비가 만물차용설에 근거한 겸손의 주제를 부각한다."
                ],
                distractors: [
                    "두 상황 모두 끝까지 일관된 겸손함을 보여 준다고 설명한다.",
                    "태도 변화는 주변 인물의 비난 때문이며 작품의 주제와는 무관하다고 본다.",
                    "결국 자유롭게 질주하는 삶을 권유하는 긍정적 메시지를 찾는다."
                ]
            },
            {
                id: 2,
                question: "이 작품이 '말을 빌려 탄 경험'에서 '만물차용설'이라는 보편적 진리로 나아가는 과정을 유추(類推)의 관점에서 설명하시오.",
                correctAnswer: "작가는 노둔마와 준마를 번갈아 탄 개인적 경험에서 서술을 시작한다. 이어서 임금과 신하, 가족과 비복 등 사회 전반의 관계를 예로 들며 모든 것이 잠시 빌린 것임을 주장한다. 즉, 말을 대하는 태도를 세상의 모든 소유물을 대하는 자세로 확장시켜 경험에서 진리로 나아가는 유추의 방식을 사용한다.",
                correctParts: [
                    "글은 노둔마와 준마를 번갈아 탄 개인적 경험에서 출발한다.",
                    "그 경험을 임금·신하, 가족·비복 등 사회 전반의 관계로 확장한다.",
                    "개별 경험을 보편적 진리로 잇는 유추의 방식을 사용한다."
                ],
                distractors: [
                    "처음부터 추상적 교훈을 제시한 뒤 예시를 덧붙였다고 설명한다.",
                    "논증이 연역적 삼단논법으로 전개된다고 본다.",
                    "경험과 진리 사이에 아무런 연결 고리가 없다고 주장한다."
                ]
            },
            {
                id: 3,
                question: "만물차용설을 뒷받침하는 구체적 예시를 두 가지 이상 제시하고, 이 사상이 당시 지배층을 향해 던지는 비판적 의미를 설명하시오.",
                correctAnswer: "작가는 임금은 백성에게서 힘을 빌리고 신하는 임금에게서 권세를 빌린다고 말한다. 또한 자식, 지어미, 비복 등 모든 인간관계가 서로에게 빌린 것임을 강조한다. 이러한 예시는 지배층이 영원한 소유라 믿었던 권력과 재물이 사실은 빌린 것에 불과함을 드러내어, 언제든 잃을 수 있다는 경고로서 그들의 교만을 비판한다.",
                correctParts: [
                    "임금은 백성에게서 힘을 빌리고 신하는 임금에게서 권세를 빌린다고 제시한다.",
                    "자식·지어미·비복 등 가족과 주종 관계도 서로에게 빌린 것임을 강조한다.",
                    "결국 언제든 잃을 수 있다는 경고로 교만한 지배층을 비판한다."
                ],
                distractors: [
                    "만물차용설은 평민들만 적용된다고 주장한다.",
                    "예시는 자연 현상 위주이며 인간 관계는 언급하지 않는다고 설명한다.",
                    "사상적 결론이 지배층을 칭송하는 방향으로 마무리된다고 본다."
                ]
            },
            {
                id: 4,
                question: "작가가 맹자의 말을 인용한 이유와 그 인용이 논지 전개에 주는 효과를 서술하시오.",
                correctAnswer: "작가는 빌린 것을 반환하지 않으면 자기 소유가 아니라는 맹자의 말을 빌려 만물차용설을 객관화한다. 고전 권위를 불러와 개인적 경험에서 얻은 깨달음이 보편적 진리임을 강조하고, 논지의 설득력을 높이기 위한 장치로 사용한다.",
                correctParts: [
                    "맹자의 '차용하고서 반환하지 않으면 자기 것이 아니다'라는 말을 인용한다.",
                    "이를 통해 만물차용설이 단순한 개인 감상이 아니라는 점을 객관화한다.",
                    "고전 권위를 빌려 논지의 설득력과 보편성을 강화한다."
                ],
                distractors: [
                    "맹자의 사상을 비판하기 위해 대비적으로 인용했다고 본다.",
                    "독자에게 한문 해석 능력을 자랑하려는 목적이라고 설명한다.",
                    "맹자 인용이 작품의 논지와 무관한 장식이라고 평가한다."
                ]
            },
            {
                id: 5,
                question: "'빌렸던 것을 돌려주는 일'과 '독부·고신'이라는 표현이 상징하는 바를 설명하고, 이를 통해 작가가 전하려는 경고를 정리하시오.",
                correctAnswer: "'빌렸던 것을 돌려주는 일'은 죽음이나 권력·재물의 상실처럼 소유가 끝나는 순간을 뜻한다. 이때 임금도 독부, 대부도 고신이 되어 모든 것을 잃은 외로운 처지가 된다. 작가는 가장 존귀한 이들조차 소유를 잃으면 비참한 결말을 맞는다는 경고를 통해, 현세의 소유에 집착하지 말고 겸손해야 한다고 일깨운다.",
                correctParts: [
                    "'빌렸던 것을 돌려주는 일'은 죽음이나 권력·재물 상실 등 소유가 끝나는 순간을 가리킨다.",
                    "그때 임금도 독부, 대부도 고신이 되어 외로운 처지로 전락한다.",
                    "따라서 현세의 소유에 집착하지 말고 겸손해야 함을 일깨운다."
                ],
                distractors: [
                    "돌려줌은 더 큰 부귀를 얻는 기회라고 해석한다.",
                    "독부와 고신이 서로의 힘을 합쳐 세력을 키운다는 결론을 내린다.",
                    "경고의 대상이 평민들뿐이라고 한정한다."
                ]
            },
            {
                id: 6,
                question: "준마를 얻은 뒤 겪은 '환란'과 노둔마를 탔을 때의 결과를 비교하여, 작품이 전하려는 교훈을 설명하시오.",
                correctAnswer: "준마를 얻은 '나'는 의기양양하여 고삐를 놓고 채찍을 마구 휘둘러 결국 말에서 떨어지는 환란을 겪었다. 반면 노둔마를 탈 때는 전전긍긍하며 채찍을 대지 않아 후회할 일이 없었다. 두 경험의 대비를 통해 작가는 소유물 자체가 아니라 그것을 대하는 교만한 태도가 불행을 부른다는 교훈을 제시한다.",
                correctParts: [
                    "준마를 얻자 의기양양해져 고삐를 놓고 달리다 환란을 겪는다.",
                    "노둔마를 탈 때는 전전긍긍하여 후회할 일이 없었다.",
                    "결국 교만한 태도가 불행을 초래한다는 교훈을 제시한다."
                ],
                distractors: [
                    "준마의 사고는 우연한 기상 악화 때문이라고 설명한다.",
                    "노둔마를 탈 때도 동일한 환란이 반복되었다고 주장한다.",
                    "교훈이 빠르게 질주하는 즐거움을 찬양하는 데 있다고 본다."
                ]
            },
            {
                id: 7,
                question: "노둔마를 탈 때 '나'가 도랑을 만나면 말에서 내리곤 한 이유를 두 가지 측면에서 설명하시오.",
                correctAnswer: "첫째, 둔한 말이 넘어져 다칠까 염려하여 말을 아끼려는 마음 때문이다. 둘째, 말이 쓰러지면 자신도 다칠 것을 우려해 미리 환란을 피하려는 조심스러운 태도 때문이다.",
                correctParts: [
                    "노둔한 말이 다칠까 염려하여 말을 아끼려는 마음이 있었다.",
                    "말이 넘어지면 자신도 다칠 것을 우려해 미리 환란을 피하고자 했다.",
                    "따라서 조심스러움과 자기 보호가 내려 걷게 한 핵심 이유다."
                ],
                distractors: [
                    "말을 버리고 혼자 빨리 가기 위해서라고 설명한다.",
                    "도랑을 건너면서 말을 훈련시키려는 의도였다고 본다.",
                    "주인의 눈을 피해 몰래 말을 훔치려는 계획 때문이라고 말한다."
                ]
            },
            {
                id: 8,
                question: "노둔마를 탈 때와 준마를 탈 때 감정이 극단적으로 달라지는 근본 원인을 '소유 형태'의 측면에서 설명하시오.",
                correctAnswer: "감정 변화의 근본 원인은 '남의 물건을 빌려 쓴다'는 소유 형태에 있다. 빌린 물건의 상태가 조심해야 할지, 방자하게 다뤄도 될지를 결정하고, 그 판단이 전전긍긍과 의기양양이라는 심리 변화를 낳는다.",
                correctParts: [
                    "감정 변화의 뿌리는 남의 물건을 빌려 쓴다는 소유 형태에 있다.",
                    "빌린 물건의 질이 조심해야 할지 방자해도 될지를 결정한다.",
                    "이 판단이 전전긍긍과 의기양양이라는 심리 변화를 낳는다."
                ],
                distractors: [
                    "감정은 날씨와 기후가 좌우한다고 설명한다.",
                    "말의 주인이 꾸짖었기 때문에 태도가 바뀌었다고 본다.",
                    "소유 형태와 무관하게 기분이 무작위로 변한다고 주장한다."
                ]
            },
            {
                id: 9,
                question: "임금·신하 관계와 가족·주종 관계를 비교하여, 만물차용설이 공적 영역과 사적 영역 모두에 어떻게 적용되는지 설명하시오.",
                correctAnswer: "임금과 신하의 관계는 힘과 권세라는 공적 자원을 서로에게서 빌리는 예다. 가족과 비복의 관계는 생명과 사랑, 노동력 같은 사적 요소를 빌린 예다. 작가는 공적 권력뿐 아니라 개인적 삶마저 빌린 것임을 강조하여 만물차용설의 범위를 확장한다.",
                correctParts: [
                    "임금·신하 관계는 힘과 권세 같은 공적 자원을 서로에게서 빌리는 예다.",
                    "가족·비복 관계는 생명·사랑·노동력 등 사적 요소를 빌리는 예다.",
                    "이를 통해 만물차용설의 적용 범위를 사회 전반으로 확장한다."
                ],
                distractors: [
                    "만물차용설은 공적 영역에만 적용되고 사적 관계와는 무관하다고 말한다.",
                    "사적 관계는 영원한 소유이므로 빌림의 논리에서 제외된다고 주장한다.",
                    "공적 권력은 빌림의 관계가 아니라 타고난 신분이라고 해석한다."
                ]
            },
            {
                id: 10,
                question: "이 작품이 '설'의 구조와 주제 도출 방식에서 보여 주는 특징 두 가지를 정리하시오.",
                correctAnswer: "첫째, '말을 빌려 탄 경험→소유에 대한 깨달음→맹자 인용과 교훈'으로 이어지는 '설'의 단계적 구성을 충실히 따른다. 둘째, 구체적이고 일상적인 말의 경험에서 출발해 만물차용설이라는 보편적 진리를 이끌어내는 유추적 사고가 돋보인다.",
                correctParts: [
                    "'말을 빌려 탄 경험→소유에 대한 깨달음→맹자 인용과 교훈'이라는 '설'의 단계를 충실히 따른다.",
                    "구체적인 말의 경험에서 보편적 진리를 끌어내는 전개가 특징이다.",
                    "경험을 일반화로 확장하는 유추적 사고가 돋보인다."
                ],
                distractors: [
                    "이 작품은 자유시 형식으로 전개되어 일정한 구조가 없다고 본다.",
                    "주제는 처음부터 추상적 명제로만 제시되고 경험은 배제된다고 설명한다.",
                    "결론에서 만물차용설을 부정하며 다른 교훈을 제시한다고 주장한다."
                ]
            },
        ];

        // 5단계 초기화
        function initStage5() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '이곡 <차마설>';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제 (카드 배열)';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; color: white; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">
                            ✨ 5단계 서술형 문제: ${question.correctParts.length}개의 정답 카드를 순서대로 배열하세요!
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const totalAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);

            // 전체 문제 수 계산 (실제 문제 배열 기반)
            const stage2Questions = vocabularyData.length * 2;  // 단어당 2문제 (단어→뜻, 뜻→단어)
            const stage3Questions = sentenceData.length;
            const totalAllQuestions = learningData.questions.length + stage2Questions + stage3Questions + oxQuizData.length + writingQuestions.length;
            const answeredQuestions = totalCorrect + totalWrong;
            const progress = totalAllQuestions > 0
                ? Math.round((answeredQuestions / totalAllQuestions) * 100)
                : 100;

            // 각 스테이지에 totalQuestions 추가
            const stagesDetailWithTotal = {
                stage1: {
                    ...stageResults.stage1,
                    totalQuestions: learningData.questions.length
                },
                stage2: {
                    ...stageResults.stage2,
                    totalQuestions: stage2Questions  // 19 단어 × 2 = 38문제
                },
                stage3: {
                    ...stageResults.stage3,
                    totalQuestions: stage3Questions  // 8문제
                },
                stage4: {
                    ...stageResults.stage4,
                    totalQuestions: oxQuizData.length
                },
                stage5: {
                    ...stageResults.stage5,
                    totalQuestions: writingQuestions.length
                }
            };

            console.log('=== sendFinalDataToParent 호출됨 ===');
            console.log('전체 문제 수:', totalAllQuestions, '/ 푼 문제 수:', answeredQuestions, '/ 진행률:', progress + '%');

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stagesDetailWithTotal,
                        totalQuestions: totalAllQuestions,
                        answeredQuestions: answeredQuestions,
                        correctAnswers: totalCorrect,
                        wrongAnswers: totalWrong,
                        progress: progress,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `차마설_워크북_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
