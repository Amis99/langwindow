<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>서시 (윤동주) - 종합 학습</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px; /* Fixed header spacing */
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            white-space: pre-wrap;
            word-break: keep-all;
        }

        .poem-section {
            margin: 30px 0;
            padding: 30px;
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            border-radius: 8px;
        }

        /* 확인 학습에서 텍스트 선택 지원 */
        #poem-content {
            -webkit-user-select: text;
            user-select: text;
            -webkit-touch-callout: default;
            cursor: text;
        }

        .poem-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .commentary-section {
            margin: 30px 0;
        }

        .commentary-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 14px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 400px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        @media (max-width: 768px) {
            /* 독해학습 모달 10% 추가 축소 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 12px;
                transform: scale(0.9);
                transform-origin: center center;
            }

            .modal-question {
                font-size: 12px;
            }

            .option-button {
                padding: 6px 10px;
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            .question-modal {
                width: 90vw;
                max-height: 60vh;
                padding: 10px;
            }
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 13px;
            line-height: 1.5;
            color: #34495e;
            margin-bottom: 15px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .option-button {
            padding: 8px 14px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px; /* 1pt 증가 */
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* MCQ 단계에서 더 큰 폰트 */
        .mcq-container .option-button {
            font-size: 19px; /* 18px에서 1pt 증가 */
            padding: 20px 25px;
            border-radius: 10px;
            width: 100%;
            line-height: 1.7;
        }

        /* 모바일에서 MCQ 글자 크기 30% 축소 */
        @media (max-width: 768px) {
            .mcq-question {
                font-size: 14px !important; /* 20px * 0.7 = 14px */
            }

            .mcq-container .option-button {
                font-size: 13px !important; /* 19px * 0.7 = 13.3px ≈ 13px */
                padding: 15px 18px;
            }
        }

        .option-number {
            width: 20px;
            height: 20px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            flex-shrink: 0;
        }

        .option-button:hover {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
            animation: correctAnswer 0.6s ease;
        }

        .option-button.incorrect {
            background: #f8d7da;
            border-color: #e74c3c;
            animation: incorrectAnswer 0.6s ease;
        }

        @keyframes correctAnswer {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes incorrectAnswer {
            0%, 20%, 40%, 60%, 80%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            15%, 35%, 55%, 75%, 95% { transform: translateX(5px); }
        }

        /* Find Stage Styles */
        .find-question-modal {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 14px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-width: 280px;
            z-index: 1000;
            cursor: move;
            display: none;
        }

        .find-counter {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .selection-badge {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: bold;
            margin: 0 2px;
        }

        .text-selection {
            background: rgba(52, 152, 219, 0.3);
            position: relative;
        }

        /* Review Stage Styles */
        .cards-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 30px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            position: relative;
            min-height: 450px;
        }

        .summary-card {
            background: white;
            padding: 15px 20px; /* 30% 감소 */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid #e0e0e0;
            white-space: pre-line;
            font-size: 14px; /* 30% 감소 */
            line-height: 1.6;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
            width: 100%;
        }

        /* 모바일에서 복기학습 카드 20% 축소 */
        @media (max-width: 768px) {
            .summary-card {
                padding: 12px 16px; /* 80% 크기 */
                font-size: 11px; /* 80% 크기 */
                line-height: 1.5;
            }

            .card-number {
                font-size: 10px !important;
                width: 18px !important;
                height: 18px !important;
            }
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0,0,0,0.15);
        }

        .summary-card.dragging {
            opacity: 0.95;
            cursor: grabbing;
            z-index: 1000;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        .summary-card.drag-placeholder {
            background: #f0f0f0;
            border: 2px dashed #999;
            opacity: 0.5;
        }

        .summary-card.correct {
            border-color: #27ae60;
            background: #d4edda;
            animation: cardCorrect 0.6s ease;
        }

        .summary-card.incorrect {
            border-color: #e74c3c;
            background: #f8d7da;
            animation: cardIncorrect 0.6s ease;
        }

        @keyframes cardCorrect {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes cardIncorrect {
            0%, 20%, 40%, 60%, 80%, 100% { transform: rotate(0); }
            10%, 30%, 50%, 70%, 90% { transform: rotate(-2deg); }
            15%, 35%, 55%, 75%, 95% { transform: rotate(2deg); }
        }

        .card-number {
            display: inline-block;
            width: 24px; /* 30% 감소 */
            height: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: bold;
            font-size: 12px;
            margin-right: 10px;
            margin-bottom: 0;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            vertical-align: middle;
        }

        @keyframes numberUpdate {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.3) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        .card-number.updating {
            animation: numberUpdate 0.5s ease;
        }

        /* MCQ Stage Styles */
        .mcq-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .mcq-question {
            font-size: 24px;
            line-height: 1.9;
            color: #2c3e50;
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 5px solid #3498db;
            text-align: center;
        }

        .mcq-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .mcq-options {
                grid-template-columns: 1fr;
            }
        }

        /* Results Panel */
        .results-panel {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            max-width: 600px;
            margin: 120px auto 40px; /* Add top margin for fixed header */
            text-align: center;
            display: none;
            position: relative;
        }

        .results-title {
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .results-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
            transform: translateY(-2px);
        }

        /* View Passage Button */
        .view-passage-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #3498db;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
        }

        .view-passage-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
        }

        /* Passage Modal */
        .passage-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
        }

        .passage-modal-overlay.active {
            display: block;
        }

        .passage-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 560px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }

        .passage-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ecf0f1;
        }

        .passage-modal-title {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
        }

        .close-modal {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #e74c3c;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal:hover {
            background: #c0392b;
        }

        .passage-modal-content {
            font-size: 14px;
            line-height: 1.8;
            color: #2c3e50;
            white-space: pre-wrap;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .fade-in {
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes correctGlow {
            0% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.8), 0 0 30px rgba(76, 175, 80, 0.5); }
            100% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-15px) rotateZ(-2deg); }
            20% { transform: translateX(15px) rotateZ(2deg); }
            30% { transform: translateX(-15px) rotateZ(-2deg); }
            40% { transform: translateX(15px) rotateZ(2deg); }
            50% { transform: translateX(0); }
        }

        .correct-animation {
            animation: correctGlow 0.6s ease-in-out, pulse 0.6s ease-in-out;
        }

        .incorrect-animation {
            animation: incorrectShake 0.6s ease-in-out;
            background-color: #ffebee !important;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Submit Button for Review Stage */
        .submit-btn {
            margin: 30px auto;
            display: block;
            background: #27ae60;
            color: white;
            padding: 14px 40px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submit-btn:hover {
            background: #229954;
            transform: translateY(-2px);
        }

        .submit-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        /* Mobile Responsive */
        /* Tablet styles */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .timer-container {
                width: 100%;
                height: 20px;
            }

            .question-counter {
                font-size: 16px;
            }

            .main-content {
                margin-top: 140px;
                padding: 20px;
            }
        }

        /* Mobile portrait styles */
        @media (max-width: 480px) and (orientation: portrait) {
            .header {
                padding: 10px;
            }

            .title {
                font-size: 16px;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .timer-container {
                height: 16px;
            }

            .question-counter {
                font-size: 14px;
            }

            .main-content {
                margin-top: 100px;
                padding: 15px;
            }

            .passage-container {
                font-size: 14px;
                line-height: 1.7;
            }

            .poem-section {
                padding: 15px;
                margin: 15px 0;
            }

            .poem-title {
                font-size: 16px;
            }

            /* Results panel adjustment for mobile */
            .results-panel {
                margin-top: 110px !important;
                padding: 20px;
            }

            .results-title {
                font-size: 20px;
            }

            .results-stats {
                gap: 10px;
            }

            .stat-card {
                padding: 10px;
            }

            .stat-value {
                font-size: 20px;
            }

            .stat-label {
                font-size: 11px;
            }
        }

        /* Very small mobile screens */
        @media (max-width: 360px) {
            .header {
                padding: 8px;
            }

            .title {
                font-size: 14px;
            }

            .subtitle {
                display: none; /* Hide subtitle on very small screens */
            }

            .main-content {
                margin-top: 85px;
            }

            .results-panel {
                margin-top: 95px !important;
            }

            .question-modal {
                min-width: 85vw;
                max-width: 85vw;
                left: 7.5%;
                right: 7.5%;
            }

            .find-question-modal {
                max-width: 85vw;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">서시 - 윤동주</div>
                <div class="subtitle">문학 독해 종합 학습</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active" data-stage="reading"></div>
                    <div class="stage-dot" data-stage="find"></div>
                    <div class="stage-dot" data-stage="review"></div>
                    <div class="stage-dot" data-stage="mcq"></div>
                </div>
                <div class="question-counter">
                    문제 <span id="current-question">1</span> / <span id="total-questions">28</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <!-- Content will be dynamically loaded here -->
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>

        <!-- Find Question Modal -->
        <div class="find-question-modal" id="find-question-modal">
            <div class="modal-header">확인 학습</div>
            <div class="modal-question" id="find-question-text"></div>
            <div style="text-align: center; margin: 10px 0; color: #3498db; font-weight: bold;">
                정답 글자수: <span id="answer-char-count" style="font-size: 18px;">0</span>글자
            </div>
            <div class="find-counter">
                선택: <span id="find-selection-count">0</span> / <span id="find-required-count">1</span>
            </div>
        </div>

        <!-- Results Panel -->
        <div class="results-panel" id="results-panel">
            <div class="results-title">학습 결과</div>
            <div class="results-stats" id="results-stats"></div>
            <div class="results-actions">
                <button class="btn btn-secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="btn btn-primary" onclick="nextStage()">다음으로</button>
            </div>
        </div>

        <!-- View Passage Button -->
        <button class="view-passage-btn" onclick="showPassageModal()" style="display: none;">지문 보기</button>

        <!-- Passage Modal -->
        <div class="passage-modal-overlay" id="passage-modal-overlay">
            <div class="passage-modal">
                <div class="passage-modal-header">
                    <div class="passage-modal-title">전체 지문 보기</div>
                    <button class="close-modal" onclick="closePassageModal()">×</button>
                </div>
                <div class="passage-modal-content" id="passage-modal-content"></div>
            </div>
        </div>
    </div>

    <script>
        // 기본 변수 설정
        let currentStage = 'reading';
        let currentQuestionIndex = 0;
        let score = 0;
        let correctAnswers = 0;
        let wrongAttempts = 0; // 독해 학습 틀린 횟수
        let findWrongAttempts = 0; // 확인 학습 틀린 횟수
        let reviewWrongAttempts = 0; // 복기 학습 틀린 횟수
        let reviewCorrectCards = 0; // 복기 학습 누적 정답 카드 수
        let mcqWrongAttempts = 0; // 단답형 학습 틀린 횟수
        let totalQuestions = 0;
        let timeRemaining = 100; // percentage
        let timerInterval = null;
        let lastModalPosition = null; // 마지막 모달 위치 저장
        let stageStartTime = 0; // 각 단계 시작 시간
        let globalStartTime = 0; // 전체 학습 시작 시간

        // 학습 단계별 결과 저장
        let stageResults = {
            reading: { correct: 0, wrong: 0, score: 0, time: 0, attempts: 0, elapsedTime: 0 },
            find: { correct: 0, wrong: 0, score: 0, time: 0, attempts: 0, elapsedTime: 0 },
            review: { correct: 0, wrong: 0, score: 0, time: 0, attempts: 0, elapsedTime: 0 },
            mcq: { correct: 0, wrong: 0, score: 0, time: 0, attempts: 0, elapsedTime: 0 }
        };

        // 누적 데이터 제거됨

        // 시간을 분:초 형식으로 변환
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}분 ${secs}초`;
        }

        // 마크다운 파서 함수
        function parseMarkdown(text) {
            return text
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')  // **굵은 글씨**
                .replace(/__(.+?)__/g, '<u>$1</u>')                // __밑줄__
                .replace(/\*([^*]+?)\*/g, '<em>$1</em>');          // *이탤릭*
        }

        // 퍼지 매칭 함수 (한 글자 차이, 구두점 차이 허용)
        function fuzzyMatch(text1, text2) {
            // 공백 정규화
            const normalize = (str) => {
                return str.replace(/\s+/g, ' ').trim()
                    .replace(/[.,!?;:]/g, '') // 구두점 제거
                    .replace(/[''""「」『』]/g, ''); // 특수 따옴표 제거
            };

            const norm1 = normalize(text1);
            const norm2 = normalize(text2);

            // 완전 일치
            if (norm1 === norm2) return true;

            // 길이 차이 확인 (1글자 차이만 허용)
            if (Math.abs(norm1.length - norm2.length) > 1) return false;

            // Levenshtein 거리 계산 (1 이하만 허용)
            const dp = Array(norm2.length + 1).fill(null).map(() => Array(norm1.length + 1).fill(0));

            for (let i = 0; i <= norm1.length; i++) dp[0][i] = i;
            for (let j = 0; j <= norm2.length; j++) dp[j][0] = j;

            for (let j = 1; j <= norm2.length; j++) {
                for (let i = 1; i <= norm1.length; i++) {
                    if (norm1[i - 1] === norm2[j - 1]) {
                        dp[j][i] = dp[j - 1][i - 1];
                    } else {
                        dp[j][i] = Math.min(
                            dp[j - 1][i] + 1,
                            dp[j][i - 1] + 1,
                            dp[j - 1][i - 1] + 1
                        );
                    }
                }
            }

            return dp[norm2.length][norm1.length] <= 1;
        }

        // 어절 단위 선택 검사 함수
        function checkWordSelection(selectedText, correctAnswer) {
            // 1. 기존 퍼지 매칭으로 먼저 검사 (정확히 일치 또는 1글자 차이)
            if (fuzzyMatch(selectedText, correctAnswer)) return true;

            // 2. 어절 단위 검사
            const selectedWords = selectedText.split(/\s+/);
            const answerWords = correctAnswer.split(/\s+/);

            // 경우 1: 단일 어절 정답
            // 예: 정답 '나'일 때
            if (answerWords.length === 1) {
                // 반드시 단일 어절만 선택해야 함
                // '나는' 선택 - 정답 (정답이 포함된 단일 어절)
                // '나는 괴로워했다' 선택 - 오답 (여러 어절 선택)
                if (selectedWords.length === 1 && selectedWords[0].includes(correctAnswer)) {
                    return true;
                }
                return false;
            }

            // 경우 2: 복수 어절 정답
            // 예: 정답 '하늘을 우러러'일 때
            // '하늘을 우러러' 선택 - 정답
            // '죽는 날까지 하늘을 우러러' 선택 - 오답 (정답 외 어절 포함)
            if (answerWords.length > 1) {
                // 선택된 모든 어절이 정답 어절에 속해야 함
                // 정답에 없는 어절이 하나라도 있으면 오답

                for (let selectedWord of selectedWords) {
                    let foundInAnswer = false;

                    for (let answerWord of answerWords) {
                        // 선택 어절이 정답 어절과 일치하거나 부분 일치
                        if (selectedWord === answerWord ||
                            answerWord.includes(selectedWord) ||
                            selectedWord.includes(answerWord)) {
                            foundInAnswer = true;
                            break;
                        }
                    }

                    // 정답에 없는 어절이 선택되었으면 오답
                    if (!foundInAnswer) {
                        return false;
                    }
                }

                // 모든 정답 어절이 선택에 포함되어야 함
                for (let answerWord of answerWords) {
                    let foundInSelection = false;

                    for (let selectedWord of selectedWords) {
                        if (selectedWord === answerWord ||
                            selectedWord.includes(answerWord) ||
                            answerWord.includes(selectedWord)) {
                            foundInSelection = true;
                            break;
                        }
                    }

                    // 정답 어절이 선택에 없으면 오답
                    if (!foundInSelection) {
                        return false;
                    }
                }

                // 모든 조건을 만족하면 정답
                return true;
            }

            return false;
        }

        // 전체 학습 데이터
        const learningData = {
            // 시 본문 (원고 그대로)
            poem: `서시

죽는 날까지 하늘을 우러러
한 점 부끄럼이 없기를,
잎새에 이는 바람에도
나는 괴로워했다.

별을 노래하는 마음으로
모든 죽어가는 것을 사랑해야지
그리고 나한테 주어진 길을
걸어가야겠다.

오늘 밤에도 별이 바람에 스치운다.`,

            // 해설 본문들 (원고 그대로)
            commentary: [
                {
                    title: "해설 1 어두운 시대, 별을 노래한 시인",
                    text: `문학은 그 시대의 아픔과 희망을 담는 그릇과 같다. 일제강점기라는 어두운 시대에 활동한 윤동주 시인의 「서시」는 절망적인 현실 속에서도 굴복하지 않는 젊은 지식인의 마음을 보여주는 대표작이다. 시인의 유고 시집 『하늘과 바람과 별과 시』의 서문 역할을 하는 이 시에는, 그의 문학 세계를 이해하는 핵심 정서인 **'부끄러움'**이 잘 나타나 있다.
윤동주가 느끼는 부끄러움은 단순히 개인의 잘못에서 비롯된 감정이 아니다. 이는 나라를 잃은 시대에 적극적으로 저항하지 못하고 시를 쓰는 일에 머무는 자신을 끊임없이 돌아보는 고결한 성찰의 결과물이다. '잎새에 이는 바람에도 괴로워했다'는 구절은 이러한 작고 섬세한 양심을 상징적으로 보여준다. 이러한 부끄러움은 좌절에 머무르지 않고, '모든 죽어가는 것'으로 표현된 고통받는 민족에 대한 깊은 사랑과 연민으로 이어진다.
결국 시인은 이 사랑을 실천하기 위해 자신에게 '주어진 길'을 운명으로 받아들인다. 여기서 길이란, 민족의 아픔을 대신 짊어지려는 희생적 태도를 의미한다. 따라서 윤동주의 부끄러움은 무력한 지식인의 고뇌를 넘어, 자신의 희생을 통해 어두운 시대를 밝히려는 위대한 결심으로 승화되는 것이다.`
                },
                {
                    title: "해설 2  시어 속에 숨겨진 의미",
                    text: `시인은 직접적인 표현보다는 상징을 통해 자신의 마음을 전달하는 경우가 많다. 윤동주의 「서시」도 여러 상징적인 단어들을 사용하여 시의 깊은 뜻을 효과적으로 드러낸다.
시에 나오는 '하늘'은 화자가 자신의 모든 행동과 마음을 비추어보는 절대적인 기준이다. 부끄러움 없는 삶을 살고 싶을 때 우러러보는 도덕적인 거울과 같은 존재이다. '바람'은 두 가지 의미를 지닌다. 첫째는 깨끗하게 살고 싶은 화자의 마음을 흔드는 내면의 고민과 갈등이다. 둘째는 시인을 억압하는 일제강점기의 차가운 현실, 즉 외부에서 오는 시련을 상징한다. 어두운 밤하늘에서 빛나는 '별'은 암담한 현실 속에서도 사라지지 않는 희망을 의미한다. 동시에 시인이 간직하고 싶은 순수한 양심과 그가 꿈꾸는 이상적인 세계를 나타낸다. '오늘 밤'은 화자가 처해 있는 일제강점기의 절망적인 상황 그 자체를 뜻한다. 그리고 '길'은 이러한 고통스러운 현실 속에서도 앞으로 나아가야 할 시인의 사명과 삶의 자세를 보여준다.
이처럼 윤동주 시인은 단순한 자연물을 통해 자신의 복잡한 내면세계와 시대의 아픔을 깊이 있게 표현했다.`
                },
                {
                    title: "해설 3 과거, 미래, 현재를 오가는 구성",
                    text: `문학 작품은 시간의 흐름을 효과적으로 활용하여 주제 의식을 깊이 있게 드러낸다. 「서시」는 과거, 미래, 현재를 넘나드는 입체적인 시간 구성을 통해 화자의 내면을 생생하게 보여주는 작품이다.
1연은 과거의 삶을 스스로 돌아보는 시간이다. 화자는 지금까지 한 점 부끄럼 없는 삶을 살기 위해 아주 작은 바람에도 괴로워할 만큼 자신을 진지하게 살피며 살아왔음을 고백한다.
2연은 미래를 향한 굳은 다짐을 보여준다. 화자는 순수한 꿈을 간직한 채 고통받는 모든 것을 사랑하고, 자신에게 주어진 특별한 길을 조용히 걸어가겠다는 의지를 다진다.
3연은 다시 어둡고 힘든 현재로 돌아와 화자가 놓인 상황을 상징적으로 보여준다. 여전히 현실을 뜻하는 '밤'은 어둡고 차가우며, 지켜야 할 소중한 꿈인 '별'은 바깥의 어려움을 뜻하는 '바람'에 위태롭게 흔들리고 있다.
이처럼 과거를 돌아본 것을 바탕으로 미래를 다짐하고, 그 힘으로 힘든 현재를 견뎌내는 짜임새 있는 구성은 화자의 깊은 생각과 의지를 효과적으로 보여준다.`
                }
            ],

            // 전체 지문 (시 + 해설)
            fullPassage: function() {
                let passage = this.poem + '\n\n';
                this.commentary.forEach(comm => {
                    passage += comm.title + '\n\n' + comm.text + '\n\n';
                });
                return passage;
            }
        };

        // 독해 학습 문제들 (28개)
        learningData.readingQuestions = [
            {
                text: "죽는 날까지 하늘을 우러러",
                question: "'죽는 날까지 하늘을 우러러'보겠다는 화자의 태도로 가장 적절한 것은?",
                correct: "평생 순수하고 도덕적인 삶의 기준을 지향하며 살아가겠다.",
                wrong: [
                    "하늘에 소원을 빌어 현재의 어려운 상황이 끝나기를 기원하겠다.",
                    "자연의 아름다움을 감상하며 현실의 고통을 잠시나마 잊겠다.",
                    "앞으로 닥칠지 모를 불행을 미리 걱정하며 대비하겠다.",
                    "위대한 존재 앞에서 자신의 나약함을 인정하고 용서를 구하겠다.",
                    "죽음에 대한 공포를 이겨내기 위해 초월적인 세계를 갈망하겠다.",
                    "세속적인 욕심을 버리고 자연과 하나가 되는 삶을 추구하겠다."
                ]
            },
            {
                text: "한 점 부끄럼이 없기를,",
                question: "화자가 바라는 '한 점 부끄럼이 없는' 상태는 어떤 의미인가?",
                correct: "양심에 비추어 보았을 때 티끌만 한 잘못도 없는 완벽한 도덕적 결백",
                wrong: [
                    "다른 사람들에게 자신의 실수나 약점을 감추고 싶은 마음",
                    "과거의 실패에 얽매이지 않고 미래를 향해 나아가려는 의지",
                    "어떤 상황에서도 당당함을 잃지 않는 대담하고 용기 있는 자세",
                    "세상의 비난이나 평가에 신경 쓰지 않는 초연한 태도",
                    "자신의 행동에 대해 후회나 미련을 남기지 않으려는 다짐",
                    "남들보다 뛰어난 능력을 갖추어 자신감을 얻고 싶은 소망"
                ]
            },
            {
                text: "잎새에 이는 바람에도",
                question: "이 구절의 '잎새에 이는 바람'이 상징하는 바로 가장 적절한 것은?",
                correct: "화자의 내면을 흔드는 사소하고 미세한 갈등이나 시련",
                wrong: [
                    "견디기 힘든 거대하고 압도적인 시대적 폭력",
                    "새로운 시대가 다가오고 있음을 알리는 긍정적인 변화의 조짐",
                    "평화롭고 아름다운 자연의 서정적인 풍경",
                    "화자의 마음을 편안하게 만드는 부드러운 위로",
                    "잊을 수 없는 과거의 충격적인 사건이나 기억",
                    "화자가 동경하는 순수하고 이상적인 세계의 모습"
                ]
            },
            {
                text: "나는 괴로워했다.",
                question: "화자가 '괴로워했다'고 고백하는 이유로 가장 적절한 것은?",
                correct: "아주 작은 허물조차 용납하지 않으려는 고결한 양심을 지녔기 때문에",
                wrong: [
                    "가난하고 암울한 시대 현실 속에서 살아가야만 했기 때문에",
                    "병약한 신체를 가지고 있어 작은 날씨 변화에도 민감하기 때문에",
                    "자신의 뜻과 상관없이 흘러가는 시간에 대해 무력감을 느끼기 때문에",
                    "다른 사람들과 어울리지 못하고 외롭게 지내는 자신의 처지 때문에",
                    "미래에 대한 불안감과 불확실성으로 인해 마음이 흔들리기 때문에",
                    "저질렀던 큰 잘못에 대한 죄책감에서 벗어나지 못했기 때문에"
                ]
            },
            {
                text: "별을 노래하는 마음으로",
                question: "'별을 노래하는 마음'에 담긴 화자의 심정으로 가장 적절한 것은?",
                correct: "순수한 희망과 이상적인 세계에 대한 소망을 간직한 태도",
                wrong: [
                    "아름다운 자연의 풍경에 대한 예술가적 감탄",
                    "현실의 고통을 잊기 위한 낭만적인 생각",
                    "멀리 있는 대상에 대한 막연한 그리움과 동경",
                    "자신의 미래가 밝게 빛날 것이라는 맹목적인 믿음",
                    "사랑하는 사람과 함께 밤하늘을 보았던 과거의 추억",
                    "천문학적 지식을 바탕으로 별자리를 관찰하는 탐구심"
                ]
            },
            {
                text: "모든 죽어가는 것을 사랑해야지",
                question: "'모든 죽어가는 것을 사랑해야지'라는 다짐에 담긴 의미로 가장 적절한 것은?",
                correct: "시대의 아픔 속에서 희생되고 고통받는 존재에 대한 연민과 애정",
                wrong: [
                    "생명이 있는 모든 것은 결국 죽는다는 사실에 대한 겸허한 수용",
                    "낡고 오래된 것들을 소중히 여기는 복고주의적인 태도",
                    "연약하고 보잘것없는 존재들을 보살피려는 동정심",
                    "슬픔에 빠진 사람들을 위로하고 감정을 공유하려는 공감 능력",
                    "죽음이라는 운명 앞에서 모든 존재는 평등하다는 깨달음",
                    "자신의 유한한 삶을 소중히 여기고 사랑하려는 마음"
                ]
            },
            {
                text: "그리고 나한테 주어진 길을",
                question: "화자가 인식하는 '나한테 주어진 길'의 성격으로 가장 적절한 것은?",
                correct: "시대와 민족 앞에서 자신이 마땅히 감당해야 할 숙명적인 사명",
                wrong: [
                    "다른 사람들이 모두 부러워하는 영광스럽고 특별한 운명",
                    "스스로의 노력으로 새롭게 개척해야 할 도전적인 과제",
                    "여러 선택지 중에서 신중하게 골라야 할 인생의 기회",
                    "벗어나고 싶지만 어쩔 수 없이 따라야만 하는 강제적인 명령",
                    "누구나 평범하게 걸어가는 보편적이고 일반적인 삶의 과정",
                    "종교적 믿음에 따라 신이 정해준 절대적인 계율"
                ]
            },
            {
                text: "걸어가야겠다.",
                question: "'걸어가야겠다'는 표현에 드러난 화자의 태도로 가장 적절한 것은?",
                correct: "주어진 운명을 회피하지 않고 정면으로 맞서 이겨내려는 결연한 태도",
                wrong: [
                    "어쩔 수 없는 현실에 체념하고 순응하려는 소극적인 자세",
                    "힘든 상황이 빨리 끝나기를 바라는 간절한 소망",
                    "자신의 선택에 대한 확신이 없어 망설이는 마음",
                    "미래에 대한 막연한 기대를 안고 앞으로 나아가려는 낙관적 생각",
                    "다른 사람의 도움 없이 혼자서 모든 것을 해결하려는 고집",
                    "현실의 고통에서 벗어나 이상적인 세계로 떠나고 싶은 심정"
                ]
            },
            {
                text: "오늘 밤에도 별이 바람에 스치운다.",
                question: "마지막 행이 암시하는 화자의 현재 상황으로 가장 적절한 것은?",
                correct: "암담한 현실 속에서 희망을 지키기 위한 힘겨운 노력이 계속되고 있음",
                wrong: [
                    "오랜 시련 끝에 드디어 밝은 미래가 찾아왔음",
                    "모든 내적 갈등을 해소하고 완전한 평온을 되찾았음",
                    "거센 현실의 저항에 부딪혀 결국 이상을 포기하게 되었음",
                    "아름다운 밤 풍경을 감상하며 서정적인 감상에 젖어 있음",
                    "자신이 겪는 고통의 원인을 외부 환경 탓으로 돌리고 있음",
                    "시대적 상황을 외면한 채 개인적인 슬픔에만 몰두하고 있음"
                ]
            },
            {
                text: "문학은 그 시대의 아픔과 희망을 담는 그릇과 같다.",
                question: "이 문장에서 '문학'을 '그릇'에 비유한 이유로 가장 적절한 것은?",
                correct: "한 시대의 사회상과 사람들의 정신을 온전히 담아내는 역할을 하기 때문에",
                wrong: [
                    "독자에게 특정한 교훈이나 지식을 전달하는 수단이기 때문에",
                    "현실의 문제에 대한 구체적인 해결책을 제시하기 때문에",
                    "아름다운 언어로 독자에게 예술적 즐거움을 주기 때문에",
                    "작가의 개인적인 감정을 자유롭게 표현하는 도구이기 때문에",
                    "상상 속의 세계를 통해 독자를 현실로부터 벗어나게 하기 때문에",
                    "시대가 지나도 변하지 않는 보편적인 진리를 담고 있기 때문에"
                ]
            }
        ];

        // 독해 학습 문제 11-20
        learningData.readingQuestions.push(
            {
                text: "일제강점기라는 어두운 시대에 활동한 윤동주 시인의 「서시」는 절망적인 현실 속에서도 굴복하지 않는 젊은 지식인의 마음을 보여주는 대표작이다.",
                question: "이 문장을 통해 알 수 있는 「서시」의 특징으로 가장 적절한 것은?",
                correct: "시대적 고난에 맞서는 저항 정신과 고결한 의지를 담고 있다.",
                wrong: [
                    "일제강점기의 생활상을 사실적으로 기록한 역사적 가치가 있다.",
                    "젊은 지식인으로서 겪었던 개인적인 사랑과 이별을 노래하고 있다.",
                    "현실의 어려움 때문에 느꼈던 절망과 무력감을 주로 표현하고 있다.",
                    "자연의 아름다움을 예찬하며 현실 도피적인 성격을 보여주고 있다.",
                    "당대 사회의 부조리한 모습을 날카롭게 풍자하고 비판하고 있다.",
                    "난해한 상징과 표현을 사용하여 독자의 다양한 해석을 유도하고 있다."
                ]
            },
            {
                text: "시인의 유고 시집 『하늘과 바람과 별과 시』의 서문 역할을 하는 이 시에는, 그의 문학 세계를 이해하는 핵심 정서인 **'부끄러움'**이 잘 나타나 있다.",
                question: "이 문장의 내용에 대한 이해로 가장 적절한 것은?",
                correct: "「서시」는 윤동주 문학의 핵심 정서인 '부끄러움'을 담고 있으며, 사후에 출간된 시집의 서문으로 기능한다.",
                wrong: [
                    "「서시」는 '부끄러움'이란 정서를 극복하려는 의지를 직접적으로 드러낸다.",
                    "『하늘과 바람과 별과 시』는 「서시」의 내용을 상세히 해설하기 위한 시집이다.",
                    "윤동주 문학 세계의 핵심 정서는 시대에 따라 계속해서 변화해왔다.",
                    "「서시」는 『하늘과 바람과 별과 시』의 마지막을 장식하는 작품이다.",
                    "'부끄러움'은 윤동주 시인만이 느끼는 매우 개인적이고 특수한 감정이다.",
                    "『하늘과 바람과 별과 시』는 윤동주 시인이 생전에 직접 출간한 첫 시집이다."
                ]
            },
            {
                text: "윤동주가 느끼는 부끄러움은 단순히 개인의 잘못에서 비롯된 감정이 아니다.",
                question: "이 문장이 강조하는 '윤동주의 부끄러움'의 성격으로 가장 적절한 것은?",
                correct: "개인의 윤리적 문제를 넘어선, 보다 근원적이고 시대적인 차원의 감정이다.",
                wrong: [
                    "다른 사람에게 피해를 준 구체적인 행동 때문에 느끼는 양심의 가책이다.",
                    "어린 시절의 트라우마에서 시작된 무의식적인 감정이다.",
                    "오직 시인 자신만이 이해하고 설명할 수 있는 고유한 감정이다.",
                    "시간이 지나면 자연스럽게 잊힐 수 있는 일시적인 감정이다.",
                    "타인의 시선이나 평가를 과도하게 의식하는 데서 비롯된 감정이다.",
                    "자신의 문학적 재능이 부족하다고 느끼는 데서 오는 예술가적 고뇌이다."
                ]
            },
            {
                text: "이는 나라를 잃은 시대에 적극적으로 저항하지 못하고 시를 쓰는 일에 머무는 자신을 끊임없이 돌아보는 고결한 성찰의 결과물이다.",
                question: "문맥상 '이는'이 가리키는 대상과 그 형성 이유를 가장 바르게 짝지은 것은?",
                correct: "대상: 부끄러움 / 이유: 시대에 적극적으로 저항하지 못하는 자신에 대한 성찰",
                wrong: [
                    "대상: 개인의 잘못 / 이유: 소극적인 태도로 현실을 외면한 것에 대한 반성",
                    "대상: 고결한 성찰 / 이유: 시를 쓰는 행위 자체를 무가치하게 여긴 점",
                    "대상: 나라를 잃은 시대 / 이유: 암울한 현실 속에서 희망을 찾지 못한 절망",
                    "대상: 시를 쓰는 일 / 이유: 문학이 현실 변화에 기여하지 못한다는 무력감",
                    "대상: 적극적인 저항 / 이유: 다른 독립운동가들의 희생에 대한 부채감",
                    "대상: 결과물 / 이유: 오랜 문학 활동 끝에 도달하게 된 최종적인 깨달음"
                ]
            },
            {
                text: "'잎새에 이는 바람에도 괴로워했다'는 구절은 이러한 작고 섬세한 양심을 상징적으로 보여준다.",
                question: "이 문장에서 '이러한 작고 섬세한 양심'이 구체적으로 의미하는 바로 가장 적절한 것은?",
                correct: "현실에 적극적으로 참여하지 못하는 자신을 돌아보는 성찰적 태도",
                wrong: [
                    "자연의 미세한 변화까지도 놓치지 않는 예민한 예술가적 감수성",
                    "불확실한 미래 때문에 사소한 일에도 쉽게 불안해하는 마음",
                    "타인의 사소한 결점도 용납하지 않으려는 완벽주의적 성향",
                    "신체적으로 허약하여 작은 외부 자극에도 쉽게 고통을 느끼는 상태",
                    "자신의 말과 행동이 남에게 미칠 영향을 지나치게 걱정하는 소심함",
                    "세상의 불의를 보면 참지 못하고 즉각적으로 분노하는 정의감"
                ]
            },
            {
                text: "이러한 부끄러움은 좌절에 머무르지 않고, '모든 죽어가는 것'으로 표현된 고통받는 민족에 대한 깊은 사랑과 연민으로 이어진다.",
                question: "이 문장에서 설명하는 '부끄러움'의 발전 방향으로 가장 적절한 것은?",
                correct: "자기 성찰에서 비롯된 감정이 민족 전체를 향한 사랑으로 확대된다.",
                wrong: [
                    "현실에 대한 깊은 좌절감과 무력감으로 변하게 된다.",
                    "개인적인 슬픔을 극복하고 내면의 평화를 찾는 과정으로 나아간다.",
                    "자신을 괴롭히는 외부 세계에 대한 날카로운 비판 의식으로 바뀐다.",
                    "예술을 통해 현실의 고통을 미적으로 승화시키려는 노력으로 이어진다.",
                    "종교적 믿음을 통해 부끄러움의 감정을 해소하려 한다.",
                    "시대적 상황을 외면하고 개인의 삶에만 집중하는 태도로 변모한다."
                ]
            },
            {
                text: "결국 시인은 이 사랑을 실천하기 위해 자신에게 '주어진 길'을 운명으로 받아들인다.",
                question: "문맥상 '이 사랑'을 실천하기 위한 시인의 행동으로 가장 적절한 것은?",
                correct: "민족의 고통을 외면하지 않고 자신이 감당해야 할 희생의 길을 걷는 것",
                wrong: [
                    "사랑하는 사람과의 행복한 미래를 위해 안정적인 삶을 추구하는 것",
                    "아름다운 시를 써서 사람들의 마음을 위로하고 감동을 주는 것",
                    "불의한 현실에 맞서 무장 투쟁과 같은 적극적인 저항에 나서는 것",
                    "부모님의 기대에 부응하여 학업에만 전념하는 것",
                    "모든 생명을 소중히 여기며 자연 친화적인 삶을 살아가는 것",
                    "자신의 감정을 솔직하게 표현하여 사람들의 공감을 얻는 것"
                ]
            },
            {
                text: "여기서 길이란, 민족의 아픔을 대신 짊어지려는 희생적 태도를 의미한다.",
                question: "이 문장에서 정의하는 '길'의 핵심적인 속성으로 가장 적절한 것은?",
                correct: "공동체를 위해 자신의 고통을 감수하려는 자기희생적 자세",
                wrong: [
                    "자신의 목표를 이루기 위해 인내하며 노력하는 과정",
                    "누구나 한 번은 겪게 되는 보편적인 삶의 여정",
                    "올바른 깨달음을 얻기 위한 힘들고 고독한 구도의 길",
                    "과거의 잘못을 뉘우치고 새로운 삶을 시작하려는 결심",
                    "정해진 운명에 순응하며 살아가는 체념적인 태도",
                    "고향으로 돌아가 평화로운 삶을 살고 싶은 소망"
                ]
            },
            {
                text: "따라서 윤동주의 부끄러움은 무력한 지식인의 고뇌를 넘어, 자신의 희생을 통해 어두운 시대를 밝히려는 위대한 결심으로 승화되는 것이다.",
                question: "이 문장의 '승화'라는 단어가 의미하는 바로 가장 적절한 것은?",
                correct: "개인의 소극적인 감정이 공동체를 위한 숭고한 의지로 한 단계 발전함",
                wrong: [
                    "복잡했던 감정이 시간이 지나면서 점차 희미하게 사라짐",
                    "억눌려 있던 감정이 예기치 않은 순간에 폭발적으로 표출됨",
                    "외부의 충격으로 인해 긍정적인 감정이 부정적으로 변함",
                    "현실의 어려움 때문에 추상적인 이상을 결국 포기하게 됨",
                    "여러 감정들이 뒤섞여 무엇이 진짜 감정인지 혼란스러워짐",
                    "감정을 숨기고 이성적인 판단에 따라 냉정하게 행동함"
                ]
            },
            {
                text: "시인은 직접적인 표현보다는 상징을 통해 자신의 마음을 전달하는 경우가 많다.",
                question: "이 문장에서 설명하는 '상징'의 역할로 가장 적절한 것은?",
                correct: "작가의 추상적인 내면세계를 구체적인 사물에 빗대어 표현하는 것",
                wrong: [
                    "독자의 이해를 돕기 위해 어려운 내용을 쉽게 풀어 설명하는 것",
                    "작품의 주제를 독자에게 명확하고 직설적으로 주장하는 것",
                    "현실에 없는 상상의 세계를 만들어 독자의 흥미를 유발하는 것",
                    "사회의 부조리한 모습을 간접적으로 비판하고 풍자하는 것",
                    "독자의 감정을 격렬하게 자극하여 즉각적인 반응을 이끌어내는 것",
                    "과거의 역사적 사건을 정확하게 재현하여 사실성을 높이는 것"
                ]
            }
        );
        // 독해 학습 문제 21-28
        learningData.readingQuestions.push(
            {
                text: "윤동주의 「서시」도 여러 상징적인 단어들을 사용하여 시의 깊은 뜻을 효과적으로 드러낸다.",
                question: "이 문장을 통해 알 수 있는 「서시」의 표현상 특징은 무엇인가?",
                correct: "시어의 함축적인 의미를 활용하여 주제를 깊이 있게 전달한다.",
                wrong: [
                    "일상적인 대화체를 사용하여 독자와의 친밀감을 높인다.",
                    "토속적인 방언을 사용하여 향토적인 분위기를 조성한다.",
                    "감각적인 이미지를 나열하여 선명한 장면을 묘사한다.",
                    "영웅적인 인물의 행동을 묘사하여 숭고한 감정을 불러일으킨다.",
                    "반어적인 표현을 통해 현실의 모순을 날카롭게 비판한다.",
                    "시간의 흐름을 뒤섞어 사건의 긴장감을 고조시킨다."
                ]
            },
            {
                text: "시에 나오는 '하늘'은 화자가 자신의 모든 행동과 마음을 비추어보는 절대적인 기준이다. 부끄러움 없는 삶을 살고 싶을 때 우러러보는 도덕적인 거울과 같은 존재이다.",
                question: "이 설명에서 '하늘'을 '도덕적인 거울'에 비유한 이유로 가장 적절한 것은?",
                correct: "자신의 삶이 올바른지를 끊임없이 되돌아보게 하는 성찰의 매개체이기 때문에",
                wrong: [
                    "미래에 일어날 일을 미리 보여주는 예언적인 능력을 지녔기 때문에",
                    "인간의 힘으로는 도달할 수 없는 초월적인 공간이기 때문에",
                    "진실과 거짓을 명확하게 구분해 주는 절대적인 심판자이기 때문에",
                    "화자의 슬픈 마음을 그대로 투영하여 보여주는 대상이기 때문에",
                    "바라보는 것만으로도 마음의 평화와 위안을 주기 때문에",
                    "현실의 모든 것을 왜곡 없이 그대로 비추어주기 때문에"
                ]
            },
            {
                text: "'바람'은 두 가지 의미를 지닌다. 첫째는 깨끗하게 살고 싶은 화자의 마음을 흔드는 내면의 고민과 갈등이다. 둘째는 시인을 억압하는 일제강점기의 차가운 현실, 즉 외부에서 오는 시련을 상징한다.",
                question: "이 설명에 따를 때, '바람'이 상징하는 두 가지 의미를 가장 바르게 짝지은 것은?",
                correct: "내면적 갈등과 외면적 시련",
                wrong: [
                    "과거의 후회와 미래의 불안",
                    "개인의 슬픔과 시대의 희망",
                    "육체적 고통과 정신적 성숙",
                    "자연의 위협과 문명의 혜택",
                    "운명에 대한 순응과 저항",
                    "현실 도피와 이상 추구"
                ]
            },
            {
                text: "어두운 밤하늘에서 빛나는 '별'은 암담한 현실 속에서도 사라지지 않는 희망을 의미한다. 동시에 시인이 간직하고 싶은 순수한 양심과 그가 꿈꾸는 이상적인 세계를 나타낸다.",
                question: "이 설명의 내용으로 보아, '별'이 상징하는 의미로 적절하지 않은 것은?",
                correct: "과거의 행복했던 시절에 대한 그리움",
                wrong: [
                    "절망적인 상황에서도 포기하지 않는 희망",
                    "지키고 싶은 깨끗하고 순수한 마음",
                    "화자가 도달하고 싶은 이상향",
                    "어두운 시대를 이겨낼 수 있는 정신적 가치",
                    "시인이 추구하는 절대적인 선과 아름다움",
                    "고통스러운 현실을 극복하려는 굳은 의지"
                ]
            },
            {
                text: "'오늘 밤'은 화자가 처해 있는 일제강점기의 절망적인 상황 그 자체를 뜻한다.",
                question: "이 설명에 따를 때, '오늘 밤'이라는 시어가 자아내는 분위기로 가장 적절한 것은?",
                correct: "희망을 찾기 어려운 암울하고 억압적인 현실",
                wrong: [
                    "모든 갈등이 해소된 평화롭고 고요한 시간",
                    "그리운 사람을 떠올리는 낭만적이고 서정적인 분위기",
                    "내일에 대한 기대로 가득 찬 희망적인 저녁",
                    "신비로운 초자연적 현상이 일어날 것 같은 긴장감",
                    "모든 활동이 멈춘 휴식과 재충전의 시간",
                    "과거를 반성하고 새로운 시작을 준비하는 성찰의 밤"
                ]
            },
            {
                text: "그리고 '길'은 이러한 고통스러운 현실 속에서도 앞으로 나아가야 할 시인의 사명과 삶의 자세를 보여준다.",
                question: "이 문장에서 설명하는 '길'의 의미로 가장 적절한 것은?",
                correct: "어려운 현실을 외면하지 않고 자신의 운명을 받아들이려는 숙명적 태도",
                wrong: [
                    "성공적인 미래로 나아가기 위한 구체적인 계획이나 방법",
                    "과거의 잘못을 반복하지 않으려는 굳은 다짐과 노력",
                    "다른 사람의 도움 없이 혼자 힘으로 살아가려는 독립적인 정신",
                    "인생의 여러 갈림길에서 올바른 선택을 해야 하는 고뇌",
                    "현실의 고통을 피해 숨을 수 있는 안전한 도피처",
                    "정해진 규칙이나 관습에서 벗어나려는 자유로운 의지"
                ]
            },
            {
                text: "이처럼 윤동주 시인은 단순한 자연물을 통해 자신의 복잡한 내면세계와 시대의 아픔을 깊이 있게 표현했다.",
                question: "이 문장을 통해 알 수 있는 윤동주 시의 전반적인 특징으로 가장 적절한 것은?",
                correct: "평범한 소재에 상징적인 의미를 부여하여 작가의 고뇌와 시대 현실을 드러낸다.",
                wrong: [
                    "자연의 아름다움을 사실적으로 묘사하여 서정성을 극대화한다.",
                    "역사적 인물의 일대기를 서술하여 민족적 자긍심을 고취한다.",
                    "일상생활의 모습을 그대로 보여주어 독자의 공감을 유도한다.",
                    "사회의 부조리한 모습을 해학적으로 풍자하여 비판한다.",
                    "격정적인 어조를 사용하여 현실에 대한 분노를 직접적으로 표출한다.",
                    "종교적인 깨달음을 바탕으로 구원의 메시지를 전달한다."
                ]
            },
            {
                text: "「서시」는 과거, 미래, 현재를 넘나드는 입체적인 시간 구성을 통해 화자의 내면을 생생하게 보여주는 작품이다.",
                question: "이 문장을 통해 알 수 있는 「서시」의 구성상 특징으로 가장 적절한 것은?",
                correct: "시간의 순서를 따르지 않고 과거, 현재, 미래를 오가며 시상을 전개한다.",
                wrong: [
                    "오직 현재의 순간에만 집중하여 화자의 감정을 강렬하게 표현한다.",
                    "시간의 흐름에 따라 화자의 내면이 점차 성장하는 과정을 보여준다.",
                    "과거의 사건을 중심으로 화자의 그리움과 후회의 정서를 드러낸다.",
                    "미래에 대한 긍정적인 전망을 통해 현재의 고통을 극복하려 한다.",
                    "동일한 시간대가 계속 반복되면서 화자의 혼란스러운 내면을 강조한다.",
                    "두 개의 다른 시간과 공간을 교차하여 보여주며 주제를 부각한다."
                ]
            }
        );
        // 확인 학습 문제들 (8개)
        learningData.findQuestions = [
            {
                question: "시에서 자신을 성찰하고 의지를 다지는 주체는?",
                answer: "나",
                type: "OR"
            },
            {
                question: "화자가 삶의 기준으로 삼는 대상은?",
                answer: "하늘",
                type: "OR"
            },
            {
                question: "화자가 바라는 소망을 직접적으로 드러낸 구절은?",
                answer: "한 점 부끄럼이 없기를",
                type: "OR"
            },
            {
                question: "화자의 섬세한 양심을 드러내며 그를 괴롭게 한 것은?",
                answer: "잎새에 이는 바람",
                type: "OR"
            },
            {
                question: "화자가 사랑하기로 다짐한 대상은?",
                answer: "모든 죽어가는 것",
                type: "OR"
            },
            {
                question: "화자가 숙명으로 받아들이고 걸어가야 할 것은?",
                answer: "나한테 주어진 길",
                type: "OR"
            },
            {
                question: "화자가 간직하려는 희망과 이상을 상징하는 시어는?",
                answer: "별",
                type: "OR"
            },
            {
                question: "화자의 이상이 현실의 시련을 겪고 있음을 암시하는 구절은?",
                answer: "오늘 밤에도 별이 바람에 스치운다",
                type: "OR"
            }
        ];
        // 단답형 학습 문제들 (20개)
        learningData.mcqQuestions = [
            {
                question: "(해설 1) 윤동주 시인처럼 시대의 아픔을 노래하고 불의에 맞서는 시인을 무엇이라고 부르는가?",
                correct: "저항 시인",
                wrong: ["순수 시인", "모더니즘 시인", "생명파 시인", "민중 시인", "자연주의 시인", "상징주의 시인"]
            },
            {
                question: "(해설 1) 「서시」는 윤동주 시인의 어떤 시집에서 서문 역할을 하는가?",
                correct: "『하늘과 바람과 별과 시』",
                wrong: ["『자화상』", "『또 다른 고향』", "『십자가』", "『새로운 길』", "『흰 그림자』", "『별 헤는 밤』"]
            },
            {
                question: "(해설 1) 이 글에서 설명하는 윤동주 문학 세계의 핵심 정서는 무엇인가?",
                correct: "부끄러움",
                wrong: ["그리움", "외로움", "분노", "절망", "희망", "체념"]
            },
            {
                question: "(해설 1) 윤동주가 느끼는 부끄러움은 무엇에 대한 성찰의 결과물인가?",
                correct: "적극적으로 저항하지 못하고 시 쓰는 일에 머무는 자신의 모습",
                wrong: [
                    "가난한 조국의 현실을 외면하고 유학 생활을 하는 자신의 모습",
                    "문학적인 재능이 부족하여 훌륭한 작품을 쓰지 못하는 자신의 모습",
                    "사랑하는 사람에게 자신의 마음을 제대로 표현하지 못하는 자신의 모습",
                    "부모님의 기대를 저버리고 문학의 길을 선택한 자신의 모습",
                    "어린 시절의 잘못된 행동에 대해 용서받지 못했다는 죄책감",
                    "다른 독립운동가들처럼 직접적인 투쟁에 나서지 못하는 비겁함"
                ]
            },
            {
                question: "(해설 1) 시인의 섬세한 양심을 상징적으로 보여주는 구절은 무엇인가?",
                correct: "'잎새에 이는 바람에도 괴로워했다'",
                wrong: [
                    "'죽는 날까지 하늘을 우러러'",
                    "'별을 노래하는 마음으로'",
                    "'나한테 주어진 길을 걸어가야겠다'",
                    "'오늘 밤에도 별이 바람에 스치운다'",
                    "'모든 죽어가는 것을 사랑해야지'",
                    "'한 점 부끄럼이 없기를'"
                ]
            },
            {
                question: "(해설 1) 시인의 부끄러움은 어떤 감정으로 이어지는가?",
                correct: "고통받는 민족에 대한 깊은 사랑과 연민",
                wrong: [
                    "현실에 대한 극심한 절망과 무력감",
                    "자신을 억압하는 시대에 대한 강한 분노",
                    "이상적인 세계에 대한 막연한 동경",
                    "과거의 삶에 대한 깊은 후회와 반성",
                    "개인의 내면적 평화를 추구하는 태도",
                    "현실을 초월하려는 종교적인 믿음"
                ]
            },
            {
                question: "(해설 1) 시인이 사랑하고자 다짐한 '모든 죽어가는 것'은 누구를 가리키는가?",
                correct: "고통받는 민족",
                wrong: [
                    "멸종 위기에 처한 동식물",
                    "희망을 잃어버린 시인 자신",
                    "낡고 사라져 가는 전통문화",
                    "전쟁으로 죽어간 무고한 생명들",
                    "병들고 쇠약해진 모든 노인",
                    "가난으로 굶주리는 아이들"
                ]
            },
            {
                question: "(해설 1) 시에서 '주어진 길'은 어떤 태도를 의미하는가?",
                correct: "민족의 아픔을 대신 짊어지려는 희생적 태도",
                wrong: [
                    "개인의 안락한 삶을 추구하려는 현실적 태도",
                    "정해진 운명에 순응하려는 체념적 태도",
                    "훌륭한 시인이 되고자 노력하는 예술가적 태도",
                    "현실을 떠나 자연 속에서 살아가려는 도피적 태도",
                    "신의 뜻에 따라 살아가려는 종교적 태도",
                    "부모의 뜻을 거역하지 않으려는 순종적 태도"
                ]
            },
            {
                question: "(해설 2) 화자가 삶의 기준으로 삼는, 절대적 순수함을 상징하는 시어는 무엇인가?",
                correct: "하늘",
                wrong: ["바람", "별", "길", "잎새", "밤", "마음"]
            },
            {
                question: "(해설 2) 화자를 괴롭게 하는 내적 갈등과 외적 시련을 동시에 상징하는 시어는 무엇인가?",
                correct: "바람",
                wrong: ["하늘", "별", "길", "잎새", "밤", "마음"]
            }
        ];

        // 단답형 학습 문제 11-20 추가
        learningData.mcqQuestions.push(
            {
                question: "(해설 2) 암울한 현실 속에서도 잃지 않으려는 희망과 순수한 이상을 상징하는 시어는 무엇인가?",
                correct: "별",
                wrong: ["하늘", "바람", "길", "잎새", "밤", "마음"]
            },
            {
                question: "(해설 2) 화자가 처한 절망적인 시대를 상징하는 시간적 배경은 무엇인가?",
                correct: "오늘 밤",
                wrong: ["죽는 날", "과거", "미래", "새벽", "저녁", "한낮"]
            },
            {
                question: "(해설 2) 화자가 묵묵히 걸어가야 할 숙명적인 삶의 자세를 비유하는 시어는 무엇인가?",
                correct: "길",
                wrong: ["하늘", "바람", "별", "잎새", "밤", "마음"]
            },
            {
                question: "(해설 2) 이 시에서 '바람'은 구체적으로 어떤 시대 현실을 상징하는가?",
                correct: "일제 강점기",
                wrong: ["해방 직후의 혼란기", "한국 전쟁의 비극", "군부 독재 시대", "급격한 산업화 시대", "민주화 운동 시대", "외환 위기 시대"]
            },
            {
                question: "(해설 2) 눈에 보이지 않는 추상적인 생각이나 의미를 눈에 보이는 구체적인 사물로 대신 나타내는 표현 방법을 무엇이라고 하는가?",
                correct: "상징",
                wrong: ["비유", "반어", "역설", "풍자", "과장", "의인"]
            },
            {
                question: "(해설 3) 「서시」는 어떤 시간 구성을 통해 화자의 내면을 보여주고 있는가?",
                correct: "과거, 미래, 현재를 넘나드는 입체적인 시간 구성",
                wrong: [
                    "시간의 흐름에 따라 순차적으로 전개하는 순행적 구성",
                    "현재에서 과거로 거슬러 올라가는 역순행적 구성",
                    "여러 이야기가 동시에 진행되는 병렬적 구성",
                    "중심 사건을 가운데 두고 주변 이야기를 늘어놓는 방사형 구성",
                    "비슷한 사건이 계속 반복되는 순환적 구성",
                    "하나의 이야기 속에 다른 이야기가 들어있는 액자식 구성"
                ]
            },
            {
                question: "(해설 3) 시에 나오는 1연은 어떤 시간에 해당하며, 화자가 무엇을 하는 시간인가?",
                correct: "과거에 해당하며, 자신의 삶을 스스로 돌아보는 시간이다.",
                wrong: [
                    "현재에 해당하며, 눈앞의 상황을 묘사하는 시간이다.",
                    "미래에 해당하며, 앞으로의 계획을 다짐하는 시간이다.",
                    "과거에 해당하며, 즐거웠던 추억을 회상하는 시간이다.",
                    "현재에 해당하며, 미래에 대한 불안감을 느끼는 시간이다.",
                    "미래에 해당하며, 희망적인 상상을 펼치는 시간이다.",
                    "특정 시간이 아닌, 영원한 진리를 노래하는 시간이다."
                ]
            },
            {
                question: "(해설 3) 2연에서 화자가 미래를 향해 다짐하는 의지 두 가지는 무엇인가?",
                correct: "고통받는 모든 것을 사랑하는 것과 자신에게 주어진 길을 걸어가는 것.",
                wrong: [
                    "한 점 부끄럼 없이 사는 것과 하늘을 우러르는 것.",
                    "별을 노래하는 것과 바람에 괴로워하는 것.",
                    "어두운 시대를 밝히는 것과 희생적인 태도를 갖는 것.",
                    "적극적으로 저항하는 것과 시를 쓰는 일에 머무는 것.",
                    "순수한 꿈을 간직하는 것과 좌절에 머무르지 않는 것.",
                    "자신의 양심을 지키는 것과 고통을 이겨내는 것."
                ]
            },
            {
                question: "(해설 3) 3연은 어떤 시간으로 돌아오며, 무엇을 상징적으로 보여주고 있는가?",
                correct: "현재로 돌아오며, 화자가 놓인 상황을 상징적으로 보여준다.",
                wrong: [
                    "과거로 돌아가며, 후회의 원인을 분석적으로 보여준다.",
                    "미래로 나아가며, 희망적인 결말을 암시적으로 보여준다.",
                    "현재로 돌아오며, 모든 갈등이 해결되었음을 보여준다.",
                    "과거로 돌아가며, 행복했던 시절을 감각적으로 보여준다.",
                    "미래로 나아가며, 앞으로 겪게 될 시련을 예고한다.",
                    "현재를 떠나며, 이상적인 세계의 모습을 환상적으로 보여준다."
                ]
            },
            {
                question: "(해설 3) 3연의 현재 상황에서, 지켜야 할 꿈인 '별'은 무엇에 의해 위태롭게 흔들리고 있는가?",
                correct: "'바람'",
                wrong: ["'밤'", "'하늘'", "'길'", "'잎새'", "'부끄럼'", "'괴로움'"]
            }
        );

        // 학습 단계 관리 함수들
        function startLearning() {
            currentStage = 'reading';
            currentQuestionIndex = 0;
            score = 0;
            correctAnswers = 0;
            timeRemaining = 100;
            globalStartTime = Date.now();
            stageStartTime = Date.now();
            startTimer();
            loadReadingStage();
        }

        // 타이머 관리
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;
                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    clearInterval(timerInterval);
                    showTimeUpModal();
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const timerBar = document.getElementById('timer-bar');
            if (timerBar) {
                timerBar.style.width = timeRemaining + '%';

                // 색상 변경
                if (timeRemaining < 20) {
                    timerBar.style.background = 'linear-gradient(90deg, #e74c3c, #c0392b)';
                } else if (timeRemaining < 50) {
                    timerBar.style.background = 'linear-gradient(90deg, #f39c12, #e67e22)';
                } else {
                    timerBar.style.background = 'linear-gradient(90deg, #3498db, #2ecc71)';
                }
            }
        }

        function addTime(seconds) {
            timeRemaining = Math.min(100, timeRemaining + (seconds * 2)); // 2% per second
            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - (seconds * 2));
            updateTimerBar();
        }

        // 독해 학습 단계
        function loadReadingStage() {
            // 새 스테이지 시작 시 모달 위치 초기화
            lastModalPosition = null;
            if (!stageStartTime) stageStartTime = Date.now();

            const mainContent = document.getElementById('main-content');
            const questions = learningData.readingQuestions;

            // 전체 지문 표시
            let html = `
                <div class="passage-container">
                    <div class="poem-section">
                        <div class="poem-title">서시</div>
                        <div id="poem-content">${parseMarkdown(learningData.poem)}</div>
                    </div>
            `;

            learningData.commentary.forEach((comm, index) => {
                html += `
                    <div class="commentary-section">
                        <div class="commentary-title">${comm.title}</div>
                        <div id="commentary-${index}">${parseMarkdown(comm.text)}</div>
                    </div>
                `;
            });

            html += '</div>';
            mainContent.innerHTML = html;

            // 문제 수 업데이트
            document.getElementById('total-questions').textContent = questions.length;

            // 첫 문제 하이라이트
            setTimeout(() => highlightNextQuestion(), 1000);
        }

        function highlightNextQuestion() {
            if (currentQuestionIndex >= learningData.readingQuestions.length) {
                showStageComplete('reading');
                return;
            }

            const question = learningData.readingQuestions[currentQuestionIndex];

            // 이전 하이라이트 제거
            document.querySelectorAll('.highlight').forEach(el => {
                el.classList.remove('highlight', 'active');
            });

            // 새 하이라이트 추가
            highlightText(question.text);

            // 문제 모달 표시
            showQuestionModal(question);

            // 카운터 업데이트
            document.getElementById('current-question').textContent = currentQuestionIndex + 1;
        }

        function highlightText(text) {
            const content = document.getElementById('main-content');
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            while (node = walker.nextNode()) {
                if (node.nodeValue.includes(text)) {
                    const span = document.createElement('span');
                    span.className = 'highlight active';
                    const parent = node.parentNode;
                    const textBefore = node.nodeValue.substring(0, node.nodeValue.indexOf(text));
                    const textAfter = node.nodeValue.substring(node.nodeValue.indexOf(text) + text.length);

                    if (textBefore) {
                        parent.insertBefore(document.createTextNode(textBefore), node);
                    }
                    span.textContent = text;
                    parent.insertBefore(span, node);
                    if (textAfter) {
                        parent.insertBefore(document.createTextNode(textAfter), node);
                    }
                    parent.removeChild(node);

                    // 스크롤
                    span.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    break;
                }
            }
        }

        function showQuestionModal(question) {
            const modal = document.getElementById('question-modal');
            const questionText = document.getElementById('modal-question-text');
            const optionsContainer = document.getElementById('modal-options');
            const questionNum = document.getElementById('modal-question-num');

            // 문제 번호 설정
            questionNum.textContent = currentQuestionIndex + 1;

            // 문제 텍스트 설정
            questionText.textContent = question.question;

            // 선택지 생성 (정답 1개 + 오답 3개 랜덤)
            const wrongOptions = shuffleArray([...question.wrong]).slice(0, 3);
            const allOptions = shuffleArray([question.correct, ...wrongOptions]);

            optionsContainer.innerHTML = '';
            allOptions.forEach((option, index) => {
                const button = document.createElement('div');
                button.className = 'option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span>${option}</span>
                `;
                button.onclick = () => handleAnswer(option === question.correct, button);
                optionsContainer.appendChild(button);
            });

            // 모달 표시 및 하이라이트 근처 위치 설정
            modal.classList.add('active');
            positionModalNearHighlight(modal);

            // 드래그 가능하게 만들기
            makeDraggable(modal);
        }

        function handleAnswer(isCorrect, button) {
            // 모든 버튼 비활성화
            document.querySelectorAll('.option-button').forEach(btn => {
                btn.style.pointerEvents = 'none';
            });

            if (isCorrect) {
                button.classList.add('correct', 'correct-animation');
                correctAnswers++;
                score += 1.0;
                addTime(15);

                // 하이라이트 영역에 성공 애니메이션
                const highlight = document.querySelector('.highlight.active');
                if (highlight) {
                    highlight.style.animation = 'correctGlow 0.6s ease-in-out';
                }

                setTimeout(() => {
                    currentQuestionIndex++;
                    document.getElementById('question-modal').classList.remove('active');
                    highlightNextQuestion();
                }, 1500);
            } else {
                button.classList.add('incorrect', 'incorrect-animation');
                wrongAttempts++; // 틀린 횟수 증가
                subtractTime(6);

                // 모달에 실패 애니메이션
                const modal = document.getElementById('question-modal');
                modal.style.animation = 'incorrectShake 0.6s ease-in-out';

                setTimeout(() => {
                    modal.style.animation = '';
                    document.querySelectorAll('.option-button').forEach(btn => {
                        btn.style.pointerEvents = 'auto';
                        btn.classList.remove('incorrect', 'incorrect-animation');
                    });
                }, 1000);
            }
        }

        // 확인 학습 단계
        function loadFindStage() {
            stageStartTime = Date.now();
            currentQuestionIndex = 0;
            const mainContent = document.getElementById('main-content');

            // 시 본문만 표시
            mainContent.innerHTML = `
                <div class="passage-container">
                    <div class="poem-section">
                        <div class="poem-title">서시</div>
                        <div id="poem-content">${parseMarkdown(learningData.poem)}</div>
                    </div>
                </div>
            `;

            // 문제 수 업데이트
            document.getElementById('total-questions').textContent = learningData.findQuestions.length;

            // 첫 문제 표시
            showFindQuestion();
        }

        function showFindQuestion() {
            if (currentQuestionIndex >= learningData.findQuestions.length) {
                showStageComplete('find');
                return;
            }

            const question = learningData.findQuestions[currentQuestionIndex];
            const modal = document.getElementById('find-question-modal');
            const questionText = document.getElementById('find-question-text');
            const charCountEl = document.getElementById('answer-char-count');

            questionText.textContent = question.question;
            modal.style.display = 'block';

            // 정답 글자수 표시
            const answerLength = question.answer.replace(/\s/g, '').length; // 공백 제외한 글자수
            charCountEl.textContent = answerLength;

            // 텍스트 선택 기능 활성화
            enableTextSelection(question.answer);

            // 카운터 업데이트
            document.getElementById('current-question').textContent = currentQuestionIndex + 1;
            document.getElementById('find-required-count').textContent = 1;
            document.getElementById('find-selection-count').textContent = 0;

            makeDraggable(modal);
        }

        function showCorrectAnswer(correctAnswer) {
            const content = document.getElementById('poem-content');
            const text = content.textContent;
            const index = text.indexOf(correctAnswer);

            if (index !== -1) {
                const before = text.substring(0, index);
                const after = text.substring(index + correctAnswer.length);

                content.innerHTML = before +
                    `<span class="correct-answer-highlight" style="background-color: #FFD700; padding: 2px 4px; border-radius: 4px; animation: pulse 1s ease-in-out infinite;">${correctAnswer}</span>` +
                    after;
            }
        }

        function enableTextSelection(correctAnswer) {
            const content = document.getElementById('poem-content');
            let selectedText = '';

            function handleSelection() {
                const selection = window.getSelection();
                selectedText = selection.toString().trim();

                if (selectedText && checkWordSelection(selectedText, correctAnswer)) {
                    // 정답
                    const range = selection.getRangeAt(0);
                    const span = document.createElement('span');
                    span.className = 'text-selection correct-animation';
                    span.style.backgroundColor = '#4CAF50';
                    span.style.color = 'white';
                    span.style.padding = '2px 4px';
                    span.style.borderRadius = '4px';
                    span.innerHTML = `${selectedText} <span class="selection-badge" style="animation: pulse 0.6s ease-in-out 2;">✓</span>`;
                    range.deleteContents();
                    range.insertNode(span);

                    correctAnswers++;
                    score += 0.5;
                    addTime(9);

                    content.removeEventListener('mouseup', handleSelection);
                    content.removeEventListener('touchend', handleSelection);

                    // 모달에 성공 애니메이션
                    const modal = document.getElementById('find-question-modal');
                    modal.classList.add('correct-animation');

                    setTimeout(() => {
                        // 정답 표시 제거
                        const selections = document.querySelectorAll('.text-selection');
                        selections.forEach(sel => {
                            const text = sel.textContent.replace(' ✓', '');
                            const textNode = document.createTextNode(text);
                            sel.parentNode.replaceChild(textNode, sel);
                        });
                        modal.classList.remove('correct-animation');
                        currentQuestionIndex++;
                        showFindQuestion();
                    }, 1500);
                } else if (selectedText) {
                    // 오답
                    findWrongAttempts++; // 틀린 횟수 증가
                    subtractTime(4);
                    selection.removeAllRanges();

                    // 모달에 실패 애니메이션
                    const modal = document.getElementById('find-question-modal');
                    modal.classList.add('incorrect-animation');

                    // 정답 표시
                    showCorrectAnswer(correctAnswer);

                    // 이벤트 리스너 제거
                    content.removeEventListener('mouseup', handleSelection);
                    content.removeEventListener('touchend', handleSelection);

                    setTimeout(() => {
                        modal.classList.remove('incorrect-animation');
                        // 정답 표시 제거하고 다음 문제로
                        const correctSpan = document.querySelector('.correct-answer-highlight');
                        if (correctSpan) {
                            const textNode = document.createTextNode(correctSpan.textContent);
                            correctSpan.parentNode.replaceChild(textNode, correctSpan);
                        }
                        currentQuestionIndex++;
                        showFindQuestion();
                    }, 3000);
                }
            }

            // 마우스와 터치 이벤트 모두 지원
            content.addEventListener('mouseup', handleSelection);
            content.addEventListener('touchend', handleSelection);
        }

        // 복기 학습 단계
        function loadReviewStage() {
            stageStartTime = Date.now();
            reviewCorrectCards = 0;
            reviewWrongAttempts = 0;
            const mainContent = document.getElementById('main-content');

            // 시의 주요 구절들로 카드 생성 (원문 그대로)
            const poemLines = [
                "죽는 날까지 하늘을 우러러\n한 점 부끄럼이 없기를",
                "잎새에 이는 바람에도\n나는 괴로워했다.",
                "별을 노래하는 마음으로\n모든 죽어가는 것을 사랑해야지",
                "그리고 나한테 주어진 길을\n걸어가야겠다.",
                "오늘 밤에도 별이 바람에 스치운다."
            ];

            // 카드 생성 및 셔플
            const shuffledCards = shuffleArray(poemLines.map((text, index) => ({
                text: text,
                originalIndex: index
            })));

            let html = `
                <div style="text-align: center; margin-bottom: 30px;">
                    <h2>문장을 올바른 순서로 배열하세요</h2>
                    <p style="color: #7f8c8d;">드래그하여 카드를 이동시킬 수 있습니다.</p>
                </div>
                <div class="cards-container" id="cards-container">
            `;

            shuffledCards.forEach((card, index) => {
                html += `
                    <div class="summary-card" draggable="true" data-original="${card.originalIndex}" data-current="${index}">
                        <span class="card-number">${index + 1}</span>
                        <span>${card.text}</span>
                    </div>
                `;
            });

            html += `
                </div>
                <button class="submit-btn" onclick="checkCardOrder()">제출하기</button>
                <button class="view-passage-btn" onclick="showPassageModal()" style="display: block; position: static; margin: 20px auto;">지문 다시 보기</button>
            `;

            mainContent.innerHTML = html;

            // 문제 수 업데이트
            document.getElementById('total-questions').textContent = '1';
            document.getElementById('current-question').textContent = '1';

            // 드래그 앤 드롭 설정
            setupDragAndDrop();
        }

        function setupDragAndDrop() {
            const container = document.getElementById('cards-container');
            const cards = document.querySelectorAll('.summary-card');
            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            cards.forEach((card) => {
                card.draggable = false; // 기본 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시)
                placeholder = document.createElement('div');
                placeholder.style.height = rect.height + 'px';
                placeholder.style.background = 'linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0)';
                placeholder.style.backgroundSize = '10px 10px';
                placeholder.style.backgroundPosition = '0 0, 5px 5px';
                placeholder.style.borderRadius = '8px';
                placeholder.style.border = '2px dashed #ccc';
                placeholder.style.opacity = '0.5';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.transform = 'scale(1.05) rotate(2deg)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    if (elemBelow && elemBelow.classList.contains('summary-card') && elemBelow !== draggedCard) {
                        const rect = elemBelow.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;

                        if (clientY < midpoint) {
                            // 위쪽에 삽입
                            elemBelow.parentNode.insertBefore(placeholder, elemBelow);
                            elemBelow.parentNode.insertBefore(draggedCard, placeholder);
                        } else {
                            // 아래쪽에 삽입
                            if (elemBelow.nextSibling) {
                                elemBelow.parentNode.insertBefore(placeholder, elemBelow.nextSibling);
                                elemBelow.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                elemBelow.parentNode.appendChild(placeholder);
                                elemBelow.parentNode.appendChild(draggedCard);
                            }
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 카드 번호 업데이트
                    updateCardNumbers();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 카드 번호 업데이트 함수
        function updateCardNumbers() {
            const cards = document.querySelectorAll('.summary-card');
            cards.forEach((card, index) => {
                const numberEl = card.querySelector('.card-number');
                if (numberEl) {
                    const oldNumber = numberEl.textContent;
                    const newNumber = (index + 1).toString();

                    if (oldNumber !== newNumber) {
                        numberEl.textContent = newNumber;
                        numberEl.classList.add('updating');
                        setTimeout(() => {
                            numberEl.classList.remove('updating');
                        }, 500);
                    }
                }
            });
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.summary-card:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;

                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function checkCardOrder() {
            const cards = document.querySelectorAll('.summary-card');
            let correctCount = 0;
            let wrongCount = 0;

            cards.forEach((card, index) => {
                const originalIndex = parseInt(card.getAttribute('data-original'));
                if (originalIndex !== index) {
                    wrongCount++;
                    card.classList.add('incorrect');
                } else {
                    correctCount++;
                    card.classList.add('correct');
                }
            });

            // 정답수와 오답수 업데이트
            reviewCorrectCards += correctCount;
            reviewWrongAttempts += wrongCount;

            // 모두 정답인 경우
            if (wrongCount === 0) {
                correctAnswers = 1; // 복기 학습 성공
                score += 2.0;
                addTime(30);
                setTimeout(() => {
                    showStageComplete('review');
                }, 2000);
            } else {
                // 일부라도 틀린 경우
                subtractTime(10);

                // 누적 정답률 표시 업데이트
                const accuracy = (reviewCorrectCards + reviewWrongAttempts) > 0 ?
                    Math.round((reviewCorrectCards / (reviewCorrectCards + reviewWrongAttempts)) * 100) : 0;
                const accuracyElem = document.getElementById('accuracy');
                if (accuracyElem) {
                    accuracyElem.textContent = accuracy + '%';
                }

                setTimeout(() => {
                    cards.forEach(card => {
                        card.classList.remove('correct', 'incorrect');
                    });
                }, 2000);
            }
        }

        // 단답형 학습 단계
        function loadMCQStage() {
            stageStartTime = Date.now();
            currentQuestionIndex = 0;
            const questions = shuffleArray([...learningData.mcqQuestions]);
            learningData.currentMCQQuestions = questions;

            // 문제 수 업데이트
            document.getElementById('total-questions').textContent = questions.length;

            showMCQQuestion();
        }

        function showMCQQuestion() {
            if (currentQuestionIndex >= learningData.currentMCQQuestions.length) {
                showStageComplete('mcq');
                return;
            }

            const question = learningData.currentMCQQuestions[currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 선택지 생성
            const wrongOptions = shuffleArray([...question.wrong]).slice(0, 3);
            const allOptions = shuffleArray([question.correct, ...wrongOptions]);

            let html = `
                <div class="mcq-container">
                    <div class="mcq-question">${question.question}</div>
                    <div class="mcq-options">
            `;

            allOptions.forEach((option, index) => {
                html += `
                    <div class="option-button" onclick="handleMCQAnswer('${option === question.correct}', this)">
                        <span class="option-number">${index + 1}</span>
                        <span>${option}</span>
                    </div>
                `;
            });

            html += `
                    </div>
                    <button class="view-passage-btn" onclick="showPassageModal()" style="display: block; position: static; margin: 30px auto;">지문 다시 보기</button>
                </div>
            `;

            mainContent.innerHTML = html;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = currentQuestionIndex + 1;
        }

        function handleMCQAnswer(isCorrect, button) {
            // 모든 버튼 비활성화
            document.querySelectorAll('.option-button').forEach(btn => {
                btn.style.pointerEvents = 'none';
            });

            if (isCorrect === 'true') {
                button.classList.add('correct', 'correct-animation');
                correctAnswers++;
                score += 0.2;
                addTime(9);

                // 성공 효과음 느낌의 애니메이션
                button.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    button.style.transform = 'scale(1)';
                }, 300);

                setTimeout(() => {
                    currentQuestionIndex++;
                    showMCQQuestion();
                }, 1500);
            } else {
                button.classList.add('incorrect', 'incorrect-animation');
                mcqWrongAttempts++; // 틀린 횟수 증가
                subtractTime(6); // 2 -> 6 (3배 증가)

                setTimeout(() => {
                    document.querySelectorAll('.option-button').forEach(btn => {
                        btn.style.pointerEvents = 'auto';
                        btn.classList.remove('incorrect', 'incorrect-animation');
                    });
                }, 1000);
            }
        }

        // 유틸리티 함수들
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function positionModalNearHighlight(modal) {
            // 이전 모달 위치가 있으면 그 위치 사용
            if (lastModalPosition && currentQuestionIndex > 0) {
                modal.style.left = lastModalPosition.left + 'px';
                modal.style.top = lastModalPosition.top + 'px';
                modal.style.transform = lastModalPosition.transform || 'none';
                return;
            }

            // 하이라이트된 요소 찾기
            const highlight = document.querySelector('.highlight.active');
            if (!highlight) {
                // 하이라이트가 없으면 기본 위치 사용
                positionModal(modal);
                return;
            }

            const highlightRect = highlight.getBoundingClientRect();
            const modalWidth = modal.offsetWidth || 350; // 기본 너비
            const modalHeight = modal.offsetHeight || 200; // 기본 높이
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;

            let left, top;

            // 가로 위치: 하이라이트 중앙에 정렬
            left = highlightRect.left + (highlightRect.width / 2) - (modalWidth / 2);

            // 화면을 벗어나지 않도록 조정
            if (left < 10) left = 10;
            if (left + modalWidth > viewportWidth - 10) {
                left = viewportWidth - modalWidth - 10;
            }

            // 세로 위치: 하이라이트가 화면 상단/하단에 따라 결정
            const highlightCenterY = highlightRect.top + (highlightRect.height / 2);
            const screenCenterY = viewportHeight / 2;

            if (highlightCenterY < screenCenterY) {
                // 하이라이트가 화면 위쪽: 모달을 아래에 배치
                top = highlightRect.bottom + 10 + scrollY;
            } else {
                // 하이라이트가 화면 아래쪽: 모달을 위에 배치
                top = highlightRect.top - modalHeight - 10 + scrollY;
            }

            // 화면 밖으로 나가지 않도록 최종 조정
            if (top < scrollY + 10) {
                top = highlightRect.bottom + 10 + scrollY;
            }
            if (top + modalHeight > scrollY + viewportHeight - 10) {
                top = highlightRect.top - modalHeight - 10 + scrollY;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
            modal.style.transform = 'none'; // 초기 transform 제거
        }

        function positionModal(modal) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 화면 크기에 따른 반응형 위치 설정
            let left = Math.max(10, (viewportWidth - modalWidth) / 2);
            let top = viewportHeight * 0.15; // 화면 상단 15% 위치

            // 모바일에서는 상단에 더 가까이
            if (viewportWidth < 768) {
                top = viewportHeight * 0.08;
            }

            // 화면을 벗어나지 않도록 조정
            if (left + modalWidth > viewportWidth - 10) {
                left = viewportWidth - modalWidth - 10;
            }
            if (top + modalHeight > viewportHeight - 10) {
                top = viewportHeight - modalHeight - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
            modal.style.transform = 'none'; // 초기 transform 제거
        }

        function makeDraggable(element) {
            // 이미 드래그 이벤트가 추가되어 있는지 확인
            if (element.dataset.draggable === 'true') {
                return;
            }
            element.dataset.draggable = 'true';

            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;
            let xOffset = 0;
            let yOffset = 0;
            let startPosX = 0;
            let startPosY = 0;

            // 이전 모달 위치에서 transform 값 가져오기
            if (lastModalPosition && lastModalPosition.transform) {
                const matrix = lastModalPosition.transform.match(/matrix.*\(([^)]*)\)/);
                if (matrix) {
                    const values = matrix[1].split(', ');
                    xOffset = parseInt(values[4]) || 0;
                    yOffset = parseInt(values[5]) || 0;
                    currentX = xOffset;
                    currentY = yOffset;
                }
            }

            // 마우스 이벤트
            element.addEventListener('mousedown', dragStart);

            // 터치 이벤트
            element.addEventListener('touchstart', dragStart, { passive: false });

            function dragStart(e) {
                // 옵션 버튼이나 닫기 버튼 클릭 시 드래그 방지
                if (e.target.classList.contains('option-button') ||
                    e.target.classList.contains('close-modal') ||
                    e.target.closest('.option-button')) {
                    return;
                }

                // 현재 위치 정확히 가져오기
                const transform = window.getComputedStyle(element).transform;
                if (transform !== 'none' && transform !== 'matrix(1, 0, 0, 1, 0, 0)') {
                    const matrix = transform.match(/matrix.*\(([^)]*)\)/);
                    if (matrix) {
                        const values = matrix[1].split(', ');
                        const newXOffset = parseFloat(values[4]) || 0;
                        const newYOffset = parseFloat(values[5]) || 0;
                        // 값이 유효한지 확인
                        if (!isNaN(newXOffset) && !isNaN(newYOffset)) {
                            xOffset = newXOffset;
                            yOffset = newYOffset;
                        }
                    }
                }
                currentX = xOffset;
                currentY = yOffset;

                if (e.type === 'touchstart') {
                    startPosX = initialX = e.touches[0].clientX - xOffset;
                    startPosY = initialY = e.touches[0].clientY - yOffset;
                } else {
                    startPosX = initialX = e.clientX - xOffset;
                    startPosY = initialY = e.clientY - yOffset;
                }

                if (e.target === element || element.contains(e.target)) {
                    isDragging = true;
                    element.classList.add('dragging');
                    element.style.transition = 'none'; // 드래그 중 transition 제거
                    element.style.willChange = 'transform'; // 성능 최적화

                    // 드래그 중일 때만 이벤트 리스너 추가
                    if (e.type === 'touchstart') {
                        document.addEventListener('touchmove', drag, { passive: false });
                        document.addEventListener('touchend', dragEnd, { passive: false });
                        document.addEventListener('touchcancel', dragEnd, { passive: false });
                    } else {
                        document.addEventListener('mousemove', drag);
                        document.addEventListener('mouseup', dragEnd);
                        document.addEventListener('mouseleave', dragEnd);
                    }

                    e.preventDefault();
                }
            }

            function drag(e) {
                if (!isDragging) return;

                e.preventDefault();

                let clientX, clientY;
                if (e.type === 'touchmove') {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                currentX = clientX - initialX;
                currentY = clientY - initialY;

                xOffset = currentX;
                yOffset = currentY;

                // 화면 밖으로 나가지 않도록 제한 (여백 10px)
                const rect = element.getBoundingClientRect();
                const padding = 10;
                const maxX = window.innerWidth - rect.width - padding;
                const maxY = window.innerHeight - rect.height - padding;
                const minX = padding - rect.left;
                const minY = padding - rect.top;

                currentX = Math.max(minX, Math.min(currentX, maxX));
                currentY = Math.max(minY, Math.min(currentY, maxY));

                // 즉시 위치 업데이트 (더 빠른 반응)
                element.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
            }

            function dragEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                element.classList.remove('dragging');
                element.style.transition = ''; // transition 복원
                element.style.willChange = 'auto'; // willChange 해제

                // 현재 모달 위치 저장
                const rect = element.getBoundingClientRect();
                lastModalPosition = {
                    left: rect.left,
                    top: rect.top,
                    transform: element.style.transform
                };

                // 드래그 거리가 짧으면 클릭으로 처리
                const dragDistance = Math.sqrt(Math.pow(currentX - startPosX, 2) + Math.pow(currentY - startPosY, 2));
                if (dragDistance < 5) {
                    // 클릭으로 처리
                    xOffset = currentX;
                    yOffset = currentY;
                }

                // 이벤트 리스너 제거
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', dragEnd);
                document.removeEventListener('mouseleave', dragEnd);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('touchend', dragEnd);
                document.removeEventListener('touchcancel', dragEnd);

                // 최종 위치 저장
                initialX = currentX;
                initialY = currentY;
            }
        }

        function showPassageModal() {
            const overlay = document.getElementById('passage-modal-overlay');
            const content = document.getElementById('passage-modal-content');

            content.innerHTML = parseMarkdown(learningData.fullPassage()).replace(/\n/g, '<br>');
            overlay.classList.add('active');
        }

        function closePassageModal() {
            document.getElementById('passage-modal-overlay').classList.remove('active');
        }

        function showStageComplete(stage) {
            clearInterval(timerInterval);

            // 단계별 결과 저장
            const elapsedSeconds = (Date.now() - stageStartTime) / 1000;
            stageResults[stage] = {
                correct: stage === 'review' ? reviewCorrectCards : correctAnswers,
                wrong: stage === 'reading' ? wrongAttempts :
                      stage === 'find' ? findWrongAttempts :
                      stage === 'review' ? reviewWrongAttempts : mcqWrongAttempts,
                score: score,
                time: 100 - timeRemaining,
                elapsedTime: elapsedSeconds,
                attempts: stage === 'review' ? (reviewCorrectCards + reviewWrongAttempts) :
                         (correctAnswers + (stage === 'reading' ? wrongAttempts :
                          stage === 'find' ? findWrongAttempts : mcqWrongAttempts))
            };

            // 모든 모달 숨기기
            document.getElementById('question-modal').classList.remove('active');
            document.getElementById('question-modal').style.display = 'none';
            document.getElementById('find-question-modal').style.display = 'none';
            document.getElementById('passage-modal-overlay').classList.remove('active');

            const panel = document.getElementById('results-panel');
            const stats = document.getElementById('results-stats');

            // 각 단계별 총 문제 수 계산
            let stageTotalQuestions = 0;
            switch(stage) {
                case 'reading':
                    stageTotalQuestions = learningData.readingQuestions.length;
                    break;
                case 'find':
                    stageTotalQuestions = learningData.findQuestions.length;
                    break;
                case 'review':
                    stageTotalQuestions = 1; // 카드 정렬은 1문제로 계산
                    break;
                case 'mcq':
                    stageTotalQuestions = learningData.mcqQuestions.length;
                    break;
            }

            // 새로운 정답률 계산: 맞은 문제 / (맞은 문제 + 틀린 횟수)
            let stageWrongAttempts = 0;
            switch(stage) {
                case 'reading':
                    stageWrongAttempts = wrongAttempts;
                    break;
                case 'find':
                    stageWrongAttempts = findWrongAttempts;
                    break;
                case 'review':
                    stageWrongAttempts = reviewWrongAttempts;
                    break;
                case 'mcq':
                    stageWrongAttempts = mcqWrongAttempts;
                    break;
            }

            // 복기 학습은 별도 계산
            let displayCorrectAnswers = correctAnswers;
            let displayWrongAttempts = stageWrongAttempts;
            let accuracy;
            let progressRate;

            if (stage === 'review') {
                displayCorrectAnswers = reviewCorrectCards;
                displayWrongAttempts = reviewWrongAttempts;
                accuracy = (reviewCorrectCards + reviewWrongAttempts) > 0 ?
                          Math.round((reviewCorrectCards / (reviewCorrectCards + reviewWrongAttempts)) * 100) : 0;
                // 복기 학습 진행률: 통과 시 100%, 미통과 시 0%
                // correctAnswers가 1이면 통과한 것 (checkCardOrder에서 설정됨)
                progressRate = correctAnswers === 1 ? 100 : 0;
            } else {
                accuracy = (correctAnswers + stageWrongAttempts) > 0 ?
                          Math.round((correctAnswers / (correctAnswers + stageWrongAttempts)) * 100) : 0;
                progressRate = stageTotalQuestions > 0 ?
                              Math.round((correctAnswers / stageTotalQuestions) * 100) : 0;
            }

            const stageNameKor = {
                reading: '독해 학습',
                find: '확인 학습',
                review: '복기 학습',
                mcq: '단답형 학습'
            };

            stats.innerHTML = `
                <h3 style="margin-bottom: 20px; color: #2c3e50;">${stageNameKor[stage]} 결과</h3>
                <div class="stat-card">
                    <div class="stat-label">점수</div>
                    <div class="stat-value">${score.toFixed(1)}점</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">정답수</div>
                    <div class="stat-value">${displayCorrectAnswers}개</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">오답수</div>
                    <div class="stat-value">${displayWrongAttempts}개</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">정답률</div>
                    <div class="stat-value">${accuracy}%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">진행률</div>
                    <div class="stat-value">${progressRate}%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">소요 시간</div>
                    <div class="stat-value">${formatTime((Date.now() - stageStartTime) / 1000)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">남은 시간</div>
                    <div class="stat-value">${Math.round(timeRemaining)}%</div>
                </div>
            `;

            panel.style.display = 'block';
            document.getElementById('main-content').style.display = 'none';

            // 단계 표시 업데이트
            document.querySelector(`.stage-dot[data-stage="${stage}"]`).classList.add('completed');

            // 부모 프로그램에 결과 전송
            sendResultsToParent(stage, accuracy, score);
        }

        function showTimeUpModal() {
            alert('시간이 종료되었습니다!');
            showStageComplete(currentStage);
        }

        function restartStage() {
            document.getElementById('results-panel').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';

            timeRemaining = 100;
            correctAnswers = 0;
            currentQuestionIndex = 0;

            // 틀린 횟수 초기화
            switch(currentStage) {
                case 'reading':
                    wrongAttempts = 0;
                    break;
                case 'find':
                    findWrongAttempts = 0;
                    break;
                case 'review':
                    reviewWrongAttempts = 0;
                    reviewCorrectCards = 0;
                    break;
                case 'mcq':
                    mcqWrongAttempts = 0;
                    break;
            }

            switch(currentStage) {
                case 'reading':
                    loadReadingStage();
                    break;
                case 'find':
                    loadFindStage();
                    break;
                case 'review':
                    loadReviewStage();
                    break;
                case 'mcq':
                    loadMCQStage();
                    break;
            }

            startTimer();
        }

        function nextStage() {
            document.getElementById('results-panel').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';

            const stages = ['reading', 'find', 'review', 'mcq'];
            const currentIndex = stages.indexOf(currentStage);

            if (currentIndex < stages.length - 1) {
                currentStage = stages[currentIndex + 1];
                document.querySelector(`.stage-dot[data-stage="${currentStage}"]`).classList.add('active');

                timeRemaining = 100;
                correctAnswers = 0;
                currentQuestionIndex = 0;

                // 다음 단계로 이동할 때 틀린 횟수 초기화
                switch(currentStage) {
                    case 'reading':
                        wrongAttempts = 0;
                        break;
                    case 'find':
                        findWrongAttempts = 0;
                        break;
                    case 'review':
                        reviewWrongAttempts = 0;
                        reviewCorrectCards = 0;
                        break;
                    case 'mcq':
                        mcqWrongAttempts = 0;
                        break;
                }

                switch(currentStage) {
                    case 'find':
                        loadFindStage();
                        break;
                    case 'review':
                        loadReviewStage();
                        break;
                    case 'mcq':
                        loadMCQStage();
                        break;
                }

                startTimer();
            } else {
                showFinalResults();
            }
        }

        function showFinalResults() {
            const mainContent = document.getElementById('main-content');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);

            let html = `
                <div class="results-panel" style="display: block; position: static; max-width: 900px;">
                    <div class="results-title">🎉 학습 완료!</div>
                    <p style="margin: 20px 0;">모든 학습 단계를 완료했습니다.</p>

                    <!-- 단계별 결과 -->
                    <h3 style="margin: 30px 0 20px; color: #2c3e50;">📊 단계별 학습 결과</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
            `;

            // 각 단계별 결과 표시
            ['reading', 'find', 'review', 'mcq'].forEach(stage => {
                const result = stageResults[stage];
                const stageAccuracy = result.attempts > 0 ?
                    Math.round((result.correct / result.attempts) * 100) : 0;
                const stageName = {
                    reading: '독해 학습',
                    find: '확인 학습',
                    review: '복기 학습',
                    mcq: '단답형 학습'
                }[stage];

                html += `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; border-left: 4px solid #3498db;">
                        <h4 style="margin: 0 0 10px; color: #2c3e50;">${stageName}</h4>
                        <div style="font-size: 14px; line-height: 1.6;">
                            <div>정답률: <strong>${stageAccuracy}%</strong></div>
                            <div>정답: ${result.correct}개</div>
                            <div>오답: ${result.wrong}회</div>
                            <div>점수: ${result.score.toFixed(1)}점</div>
                            <div>소요 시간: ${formatTime(result.elapsedTime)}</div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>

                    <!-- 전체 학습 결과 -->
                    <h3 style="margin: 30px 0 20px; color: #2c3e50;">📊 전체 학습 결과</h3>
                    <div class="results-stats" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 30px;">
                        <div class="stat-card">
                            <div class="stat-label">전체 점수</div>
                            <div class="stat-value" style="color: #3498db; font-size: 28px;">${totalScore.toFixed(1)}점</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">전체 정답수</div>
                            <div class="stat-value" style="color: #27ae60; font-size: 28px;">${totalCorrect}개</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">전체 오답수</div>
                            <div class="stat-value" style="color: #e74c3c; font-size: 28px;">${totalWrong}개</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">전체 정답률</div>
                            <div class="stat-value" style="color: #27ae60; font-size: 28px;">${overallAccuracy}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">총 소요 시간</div>
                            <div class="stat-value" style="color: #9b59b6; font-size: 24px;">${formatTime((Date.now() - globalStartTime) / 1000)}</div>
                        </div>
                    </div>

                    <div class="results-actions">
                        <button class="btn btn-primary" onclick="location.reload()">처음부터 다시하기</button>
                    </div>
                </div>
            `;

            mainContent.innerHTML = html;

            // 부모 프로그램에 최종 누적 데이터 전송
            sendFinalDataToParent();
        }

        function sendFinalDataToParent() {
            if (window.parent && window.parent !== window) {
                // 전체 결과 계산
                const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
                const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
                const totalAccuracy = (totalCorrect + totalWrong) > 0 ?
                                     Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
                const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);

                window.parent.postMessage({
                    type: 'korean-farm.v2',
                    version: '1.0',
                    activity: 'complete',
                    timestamp: Date.now(),
                    payload: {
                        // 전체 최종 데이터
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        sessionTime: (Date.now() - globalStartTime) / 1000,

                        // 단계별 상세 데이터
                        stageDetails: stageResults
                    }
                }, '*');
            }
        }

        function sendResultsToParent(stage, accuracy, score) {
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm.v2',
                    version: '1.0',
                    activity: stage,
                    payload: {
                        accuracy: accuracy,
                        score: score,
                        timeRemainingPct: timeRemaining / 100
                    }
                }, '*');
            }
        }

        // 페이지 로드 시 학습 시작
        window.addEventListener('DOMContentLoaded', () => {
            startLearning();
        });
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>