<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>전상국 &lt;동행&gt; 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.4;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">전상국 &lt;동행&gt;</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [

                {
                    id: 1,
                    text: "이 작품은 눈 덮인 겨울밤, 살인범 '억구'와 그를 체포하러 가는 '형사'가 우연한 동행자가 되어 험난한 산길을 _____ 여정을 그린 소설입니다.",
                    highlight: "(함께 걷는 / 따로 걷는)",
                    options: ["함께 걷는", "따로 걷는"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "두 인물 사이의 팽팽한 _____ 속에서도 점차 서로의 인간적인 고통을 이해하게 되는 과정을 통해, 법과 제도를 넘어선 인간에 대한 연민과 인도주의 정신이라는 깊은 주제를 다루고 있습니다.",
                    highlight: "(긴장감 / 유대감)",
                    options: ["긴장감", "유대감"],
                    correct: 0
                },
                {
                    id: 3,
                    text: "두 인물 사이의 팽팽한 긴장감 속에서도 점차 서로의 인간적인 고통을 _____ 과정을 통해, 법과 제도를 넘어선 인간에 대한 연민과 인도주의 정신이라는 깊은 주제를 다루고 있습니다.",
                    highlight: "(이해하게 되는 / 외면하게 되는)",
                    options: ["이해하게 되는", "외면하게 되는"],
                    correct: 0
                },
                {
                    id: 4,
                    text: "법과 제도를 넘어선 인간에 대한 연민과 _____ 정신이라는 깊은 주제를 다루고 있습니다.",
                    highlight: "(인도주의 / 합리주의)",
                    options: ["인도주의", "합리주의"],
                    correct: 0
                },
                {
                    id: 5,
                    text: "갈래: 단편 소설, _____ 소설",
                    highlight: "(여로형 / 액자식)",
                    options: ["여로형", "액자식"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "성격: 사실적, _____, 상징적, 인도주의적",
                    highlight: "(심리적 / 교훈적)",
                    options: ["심리적", "교훈적"],
                    correct: 0
                },
                {
                    id: 7,
                    text: "성격: 사실적, 심리적, 상징적, _____",
                    highlight: "(인도주의적 / 고발적)",
                    options: ["인도주의적", "고발적"],
                    correct: 0
                },
                {
                    id: 8,
                    text: "시간적 배경: _____의 추운 겨울밤",
                    highlight: "(정월 보름께 / 한여름 밤)",
                    options: ["정월 보름께", "한여름 밤"],
                    correct: 0
                },
                {
                    id: 9,
                    text: "공간적 배경: 강원도 춘천 근교에서 '와야리'로 가는 _____",
                    highlight: "(눈 덮인 산길 / 기차 안)",
                    options: ["눈 덮인 산길", "기차 안"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "시점: _____ 시점",
                    highlight: "(전지적 작가 / 1인칭 관찰자)",
                    options: ["전지적 작가", "1인칭 관찰자"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "주제: 인간의 원초적 죄의식과 _____, 법의 실현을 넘어선 인간애의 추구",
                    highlight: "(구원에 대한 갈망 / 현실에 대한 체념)",
                    options: ["구원에 대한 갈망", "현실에 대한 체념"],
                    correct: 0
                },
                {
                    id: 12,
                    text: "주제: 인간의 원초적 죄의식과 구원에 대한 갈망, 법의 실현을 넘어선 _____의 추구",
                    highlight: "(인간애 / 이성적 판단)",
                    options: ["인간애", "이성적 판단"],
                    correct: 0
                },
                {
                    id: 13,
                    text: "여로 구조를 통해 인물 간의 심리 변화와 주제를 _____ 드러냄.",
                    highlight: "(효과적으로 / 비효율적으로)",
                    options: ["효과적으로", "비효율적으로"],
                    correct: 0
                },
                {
                    id: 14,
                    text: "심리 묘사: 인물들의 _____을 통해 이들의 내면 심리를 간접적으로 섬세하게 묘사함.",
                    highlight: "(대화와 행동 / 직접적인 서술)",
                    options: ["대화와 행동", "직접적인 서술"],
                    correct: 0
                },
                {
                    id: 15,
                    text: "심리 묘사: 인물들의 대화와 행동을 통해 이들의 내면 심리를 _____으로 섬세하게 묘사함.",
                    highlight: "(간접적 / 직접적)",
                    options: ["간접적", "직접적"],
                    correct: 0
                },
                {
                    id: 16,
                    text: "상징성: '눈'은 시련을 상징하지만, 동시에 모든 것을 덮어주는 _____의 이중적 의미를 지님.",
                    highlight: "(정화와 포용 / 단절과 고립)",
                    options: ["정화와 포용", "단절과 고립"],
                    correct: 0
                },
                {
                    id: 17,
                    text: "갈등: 범인을 체포해야 하는 '형사'의 _____와 범인에 대한 인간적 연민 사이의 내적 갈등이 두드러짐.",
                    highlight: "(공적 임무 / 사적 감정)",
                    options: ["공적 임무", "사적 감정"],
                    correct: 0
                },
                {
                    id: 18,
                    text: "갈등: 범인을 체포해야 하는 '형사'의 공적 임무와 범인에 대한 인간적 연민 사이의 _____이 두드러짐.",
                    highlight: "(내적 갈등 / 외적 갈등)",
                    options: ["내적 갈등", "외적 갈등"],
                    correct: 0
                },
                {
                    id: 19,
                    text: "정월 보름, 눈 덮인 산길을 두 사내가 걷고 있다. 초라한 차림의 키 작은 사내 '억구'와 방한복 차림의 키 큰 사내 '형사'는 _____ 동행이 된다.",
                    highlight: "(우연히 / 계획적으로)",
                    options: ["우연히", "계획적으로"],
                    correct: 0
                },
                {
                    id: 20,
                    text: "억구가 춘천에서 일어난 _____에 대해 먼저 말을 꺼내자, 형사는 자신이 현장을 목격했다고 말하며 둘 사이에 미묘한 긴장감이 흐른다.",
                    highlight: "(살인 사건 / 절도 사건)",
                    options: ["살인 사건", "절도 사건"],
                    correct: 0
                },
                {
                    id: 21,
                    text: "억구가 춘천에서 일어난 살인 사건에 대해 먼저 말을 꺼내자, 형사는 자신이 현장을 _____고 말하며 둘 사이에 미묘한 긴장감이 흐른다.",
                    highlight: "(목격했다고 / 전해들었다고)",
                    options: ["목격했다고", "전해들었다고"],
                    correct: 0
                },
                {
                    id: 22,
                    text: "억구는 일부러 큰길을 벗어나 험한 _____로 형사를 이끈다.",
                    highlight: "(지름길 / 우회로)",
                    options: ["지름길", "우회로"],
                    correct: 0
                },
                {
                    id: 23,
                    text: "억구는 자신의 불행했던 과거를 털어놓는다. 어린 시절 '득수'에게 당했던 _____, 한국 전쟁 중 빨갱이로 몰려 아버지를 잃고 고향에서 쫓겨났던 비극 등을 담담하게 고백한다.",
                    highlight: "(모멸감 / 칭찬)",
                    options: ["모멸감", "칭찬"],
                    correct: 0
                },
                {
                    id: 24,
                    text: "어린 시절 '득수'에게 당했던 모멸감, 한국 전쟁 중 빨갱이로 몰려 아버지를 _____ 고향에서 쫓겨났던 비극 등을 담담하게 고백한다.",
                    highlight: "(잃고 / 구하고)",
                    options: ["잃고", "구하고"],
                    correct: 0
                },
                {
                    id: 25,
                    text: "어린 시절 '득수'에게 당했던 모멸감, 한국 전쟁 중 빨갱이로 몰려 아버지를 잃고 고향에서 쫓겨났던 비극 등을 _____ 고백한다.",
                    highlight: "(담담하게 / 격정적으로)",
                    options: ["담담하게", "격정적으로"],
                    correct: 0
                },
                {
                    id: 26,
                    text: "험난한 '구듬치고개'를 넘으며, 억구는 마침내 어제 자신이 '득수'의 동생인 _____을 죽였다고 자백한다.",
                    highlight: "('득칠' / '득만')",
                    options: ["'득칠'", "'득만'"],
                    correct: 0
                },
                {
                    id: 27,
                    text: "험난한 '구듬치고개'를 넘으며, 억구는 마침내 어제 자신이 '득수'의 동생인 '득칠'을 _____ 죽였다고 자백한다.",
                    highlight: "(우발적으로 / 계획적으로)",
                    options: ["우발적으로", "계획적으로"],
                    correct: 0
                },
                {
                    id: 28,
                    text: "그는 자신의 모든 죄를 고백하며 형사에게 '날 어떻게 하겠수?'라고 묻지만, 형사는 그를 바로 체포하지 않고 _____.",
                    highlight: "(망설인다 / 기뻐한다)",
                    options: ["망설인다", "기뻐한다"],
                    correct: 0
                },
                {
                    id: 29,
                    text: "형사는 과거 어린 시절, 토끼를 해부하겠다는 생물 선생님이 무서워 새끼 토끼를 풀어주지 못했던 자신의 _____을 떠올리며 내적 갈등에 빠진다.",
                    highlight: "(소심함 / 대담함)",
                    options: ["소심함", "대담함"],
                    correct: 0
                },
                {
                    id: 30,
                    text: "억구는 아버지 산소에 들렀다가 _____ 산으로 향한다.",
                    highlight: "(죄값을 치르겠다며 / 도망치겠다며)",
                    options: ["죄값을 치르겠다며", "도망치겠다며"],
                    correct: 0
                },
                {
                    id: 31,
                    text: "그 모습을 지켜보던 형사는 억구를 부른 뒤, 체포하는 대신 자신이 가지고 있던 _____ 한 갑을 건넨다.",
                    highlight: "(담배 / 돈)",
                    options: ["담배", "돈"],
                    correct: 0
                },
                {
                    id: 32,
                    text: "그는 '하루에 꼭 한 개씩만 피우셔야 합니다'라고 말하며, 억구에게 _____간의 시간을 상징적으로 허락한다.",
                    highlight: "(18일 / 30일)",
                    options: ["18일", "30일"],
                    correct: 0
                },
                {
                    id: 33,
                    text: "그는 '하루에 꼭 한 개씩만 피우셔야 합니다'라고 말하며, 억구에게 18일간의 시간을 _____ 허락한다.",
                    highlight: "(상징적으로 / 직접적으로)",
                    options: ["상징적으로", "직접적으로"],
                    correct: 0
                },
                {
                    id: 34,
                    text: "이는 형사가 법 집행관으로서의 임무보다 한 인간의 죄의식과 고통을 이해하는 _____ 선택을 했음을 보여준다.",
                    highlight: "(인도주의적 / 현실주의적)",
                    options: ["인도주의적", "현실주의적"],
                    correct: 0
                },
                {
                    id: 35,
                    text: "억구의 _____가 눈 내리는 산 속에 울려 퍼지며 소설은 마무리된다.",
                    highlight: "(울음 같은 웃음소리 / 분노에 찬 고함소리)",
                    options: ["울음 같은 웃음소리", "분노에 찬 고함소리"],
                    correct: 0
                },
                {
                    id: 36,
                    text: "전쟁의 비극이 한 개인의 삶을 어떻게 망가뜨리고, 그 상처가 또 다른 비극으로 _____를 보여줍니다.",
                    highlight: "(이어지는지 / 치유되는지)",
                    options: ["이어지는지", "치유되는지"],
                    correct: 0
                },
                {
                    id: 37,
                    text: "살인범과 그를 쫓는 형사라는 극적인 관계 속에서, 법과 제도의 차가움을 넘어 서로의 아픔을 _____ 인간적인 연민을 나누는 순간을 포착해냅니다.",
                    highlight: "(이해하고 / 비판하고)",
                    options: ["이해하고", "비판하고"],
                    correct: 0
                },
                {
                    id: 38,
                    text: "이를 통해 아무리 혹독한 시대라도 결국 인간을 구원하는 것은 인간에 대한 _____이라는 메시지를 전하고 있습니다.",
                    highlight: "(따뜻한 이해와 사랑 / 냉철한 법의 심판)",
                    options: ["따뜻한 이해와 사랑", "냉철한 법의 심판"],
                    correct: 0
                },
                {
                    id: 39,
                    text: "우연히 길동무가 된 이들의 대화는 어딘가 _____.",
                    highlight: "(어색하고 위태롭습니다 / 자연스럽고 편안합니다)",
                    options: ["어색하고 위태롭습니다", "자연스럽고 편안합니다"],
                    correct: 0
                },
                {
                    id: 40,
                    text: "작은 남자, '억구'가 불쑥 어제 춘천에서 일어난 살인 사건에 대해 묻자, 큰 남자, '형사'는 _____ 답하며 둘 사이에는 팽팽한 긴장감이 흐르기 시작합니다.",
                    highlight: "(자신이 그 현장에 있었다고 / 신문에서 읽었다고)",
                    options: ["자신이 그 현장에 있었다고", "신문에서 읽었다고"],
                    correct: 0
                },
                {
                    id: 41,
                    text: "억구는 일부러 편한 큰길을 버리고 눈 덮인 밭두렁과 얼음이 얇게 언 개울을 건너는 위험한 지름길로 형사를 이끕니다. 형사는 힘들어하면서도 _____.",
                    highlight: "(말없이 억구의 뒤를 따릅니다 / 억구에게 거세게 항의합니다)",
                    options: ["말없이 억구의 뒤를 따릅니다", "억구에게 거세게 항의합니다"],
                    correct: 0
                },
                {
                    id: 42,
                    text: "그의 이야기는 한 인간이 얼마나 깊은 _____ 속에서 살아왔는지를 보여줍니다.",
                    highlight: "(상처와 열등감 / 자신감과 우월감)",
                    options: ["상처와 열등감", "자신감과 우월감"],
                    correct: 0
                },
                {
                    id: 43,
                    text: "모든 것을 털어놓은 억구는 '자, 날 어떻게 하겠수?'라며 형사에게 자신을 체포하라고 소리칩니다. 하지만 형사는 _____.",
                    highlight: "(망설입니다 / 즉시 체포합니다)",
                    options: ["망설입니다", "즉시 체포합니다"],
                    correct: 0
                },
                {
                    id: 44,
                    text: "그는 문득 어린 시절, 해부를 당할 운명이었던 새끼 토끼를 보고도 두려워서 구해주지 못했던 자신의 _____을 떠올립니다.",
                    highlight: "(비겁함 / 용감함)",
                    options: ["비겁함", "용감함"],
                    correct: 0
                },
                {
                    id: 45,
                    text: "법을 집행해야 하는 임무와, 한 인간의 불행한 삶에 대한 _____ 사이에서 그는 깊은 내적 갈등에 빠집니다.",
                    highlight: "(연민 / 분노)",
                    options: ["연민", "분노"],
                    correct: 0
                },
                {
                    id: 46,
                    text: "고개를 모두 내려온 억구는 아버지의 산소에 들렀다 _____ 홀로 눈 덮인 산길로 향합니다.",
                    highlight: "(자수하겠다며 / 도망가겠다며)",
                    options: ["자수하겠다며", "도망가겠다며"],
                    correct: 0
                },
                {
                    id: 47,
                    text: "그리고는 수갑 대신, 자신이 가지고 있던 _____을 건넵니다.",
                    highlight: "(담배 한 갑 / 비상금 전부)",
                    options: ["담배 한 갑", "비상금 전부"],
                    correct: 0
                },
                {
                    id: 48,
                    text: "이는 범인을 체포하는 대신, 그에게 18일이라는 마지막 시간을 허락한 형사의 _____ 선택이었습니다.",
                    highlight: "(인간적인 / 비합리적인)",
                    options: ["인간적인", "비합리적인"],
                    correct: 0
                }
            
            ],
            fullText: `## 1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠

[작품 해제]

이 작품은 눈 덮인 겨울밤, 살인범 '억구'와 그를 체포하러 가는 '형사'가 우연한 동행자가 되어 험난한 산길을 (함께 걷는 / 따로 걷는) 여정을 그린 소설입니다. 두 인물 사이의 팽팽한 (긴장감 / 유대감) 속에서도 점차 서로의 인간적인 고통을 (이해하게 되는 / 외면하게 되는) 과정을 통해, 법과 제도를 넘어선 인간에 대한 연민과 (인도주의 / 합리주의) 정신이라는 깊은 주제를 다루고 있습니다.

[핵심 정리 표]

| 구분 | 내용 |
| :---- | :---- |
| 갈래 | 단편 소설, (여로형 / 액자식) 소설 |
| 성격 | 사실적, (심리적 / 교훈적), 상징적, (인도주의적 / 고발적) |
| 배경 | 시간적: (정월 보름께 / 한여름 밤)의 추운 겨울밤 공간적: 강원도 춘천 근교에서 '와야리'로 가는 (눈 덮인 산길 / 기차 안) |
| 시점 | (전지적 작가 / 1인칭 관찰자) 시점 |
| 주제 | 인간의 원초적 죄의식과 (구원에 대한 갈망 / 현실에 대한 체념), 법의 실현을 넘어선 (인간애 / 이성적 판단)의 추구 |
| 특징 | 1. 여로 구조: '눈길을 함께 걷는 과정'이라는 여로 구조를 통해 인물 간의 심리 변화와 주제를 (효과적으로 / 비효율적으로) 드러냄. 2. 심리 묘사: 인물들의 (대화와 행동 / 직접적인 서술)을 통해 이들의 내면 심리를 (간접적 / 직접적)으로 섬세하게 묘사함. 3. 상징성: '눈'은 시련을 상징하지만, 동시에 모든 것을 덮어주는 (정화와 포용 / 단절과 고립)의 이중적 의미를 지님. 4. 갈등: 범인을 체포해야 하는 '형사'의 (공적 임무 / 사적 감정)와 범인에 대한 인간적 연민 사이의 (내적 갈등 / 외적 갈등)이 두드러짐. |

[전체 줄거리 및 출제 포인트]

발단: 눈 내리는 겨울밤의 동행

정월 보름, 눈 덮인 산길을 두 사내가 걷고 있다. 초라한 차림의 키 작은 사내 '억구'와 방한복 차림의 키 큰 사내 '형사'는 (우연히 / 계획적으로) 동행이 된다. 억구가 춘천에서 일어난 (살인 사건 / 절도 사건)에 대해 먼저 말을 꺼내자, 형사는 자신이 현장을 (목격했다고 / 전해들었다고) 말하며 둘 사이에 미묘한 긴장감이 흐른다.

전개: 의심과 탐색의 길

억구는 일부러 큰길을 벗어나 험한 (지름길 / 우회로)로 형사를 이끈다. 눈 덮인 밭과 얼음이 깬 개울을 건너는 등 고난이 이어지지만, 형사는 묵묵히 억구의 뒤를 따른다. 억구는 자신의 불행했던 과거를 털어놓는다. 어린 시절 '득수'에게 당했던 (모멸감 / 칭찬), 한국 전쟁 중 빨갱이로 몰려 아버지를 (잃고 / 구하고) 고향에서 쫓겨났던 비극 등을 (담담하게 / 격정적으로) 고백한다. 이는 자신의 범죄에 대한 일종의 자기 변명이자, 형사의 정체를 떠보려는 의도가 담겨 있다.

위기: 범인의 고백과 형사의 갈등

험난한 '구듬치고개'를 넘으며, 억구는 마침내 어제 자신이 '득수'의 동생인 ('득칠' / '득만')을 (우발적으로 / 계획적으로) 죽였다고 자백한다. 그는 자신의 모든 죄를 고백하며 형사에게 "날 어떻게 하겠수?"라고 묻지만, 형사는 그를 바로 체포하지 않고 (망설인다 / 기뻐한다). 형사는 과거 어린 시절, 토끼를 해부하겠다는 생물 선생님이 무서워 새끼 토끼를 풀어주지 못했던 자신의 (소심함 / 대담함)을 떠올리며 내적 갈등에 빠진다.

절정-결말: 인간적 연민과 구원의 가능성

억구는 아버지 산소에 들렀다가 (죄값을 치르겠다며 / 도망치겠다며) 산으로 향한다. 그 모습을 지켜보던 형사는 억구를 부른 뒤, 체포하는 대신 자신이 가지고 있던 (담배 / 돈) 한 갑을 건넨다. 그는 "하루에 꼭 한 개씩만 피우셔야 합니다"라고 말하며, 억구에게 (18일 / 30일)간의 시간을 (상징적으로 / 직접적으로) 허락한다. 이는 형사가 법 집행관으로서의 임무보다 한 인간의 죄의식과 고통을 이해하는 (인도주의적 / 현실주의적) 선택을 했음을 보여준다. 억구의 (울음 같은 웃음소리 / 분노에 찬 고함소리)가 눈 내리는 산 속에 울려 퍼지며 소설은 마무리된다.

## 2️⃣ 작품 미리보기: 배경지식의 첫걸음 📝

# 작가와 시대 이야기

이 소설을 쓴 전상국 작가님은 특히 한국 전쟁이 끝난 후, 사람들의 마음속에 남은 깊은 상처와 아픔을 섬세하게 그려낸 작가로 유명합니다. 「동행」은 1959년에 발표된 작품으로, 전쟁의 비극이 한 개인의 삶을 어떻게 망가뜨리고, 그 상처가 또 다른 비극으로 (이어지는지 / 치유되는지)를 보여줍니다. 하지만 작가님은 단순히 비극을 보여주는 데 그치지 않습니다. 살인범과 그를 쫓는 형사라는 극적인 관계 속에서, 법과 제도의 차가움을 넘어 서로의 아픔을 (이해하고 / 비판하고) 인간적인 연민을 나누는 순간을 포착해냅니다. 이를 통해 아무리 혹독한 시대라도 결국 인간을 구원하는 것은 인간에 대한 (따뜻한 이해와 사랑 / 냉철한 법의 심판)이라는 메시지를 전하고 있습니다.

# 「동행」 줄거리, 아주 자세히 살펴보기

1. 불편한 동행의 시작

눈이 펑펑 쏟아지는 정월 보름날 밤, 춘천에서 '와야리'라는 시골 마을로 가는 험한 산길을 두 남자가 함께 걷고 있습니다. 앞서가는 남자는 키가 작고 양복 한 벌만 걸친 초라한 행색이고, 뒤따르는 남자는 키가 크고 방한복을 잘 챙겨 입은 모습이죠. 우연히 길동무가 된 이들의 대화는 어딘가 (어색하고 위태롭습니다 / 자연스럽고 편안합니다). 작은 남자, '억구'가 불쑥 어제 춘천에서 일어난 살인 사건에 대해 묻자, 큰 남자, '형사'는 (자신이 그 현장에 있었다고 / 신문에서 읽었다고) 답하며 둘 사이에는 팽팽한 긴장감이 흐르기 시작합니다.

2. 고난의 길, 그리고 쏟아지는 이야기들

억구는 일부러 편한 큰길을 버리고 눈 덮인 밭두렁과 얼음이 얇게 언 개울을 건너는 위험한 지름길로 형사를 이끕니다. 형사는 힘들어하면서도 (말없이 억구의 뒤를 따릅니다 / 억구에게 거세게 항의합니다). 험한 길을 걸으며, 억구는 마치 자신의 죄를 변명하듯 불행했던 과거 이야기를 쏟아냅니다. 어린 시절, 부잣집 아들 '득수'에게 눈덩이가 부서지는 모욕을 당하고 그의 손등을 물어뜯었던 기억, 그리고 한국 전쟁 당시 빨갱이로 몰려 마을 사람들에게 아버지를 잃고 고향에서 쫓겨나야 했던 끔찍한 기억까지. 그의 이야기는 한 인간이 얼마나 깊은 (상처와 열등감 / 자신감과 우월감) 속에서 살아왔는지를 보여줍니다.

3. 범인의 자백과 형사의 갈등

마침내 두 사람은 가장 험한 고개인 '구듬치고개'에 다다릅니다. 고개를 넘던 중, 억구는 마침내 자신의 죄를 고백합니다. 바로 어제, 어린 시절 자신을 모욕했던 '득수'의 동생 '득칠'을 우발적으로 죽였다는 것입니다. 모든 것을 털어놓은 억구는 "자, 날 어떻게 하겠수?"라며 형사에게 자신을 체포하라고 소리칩니다. 하지만 형사는 (망설입니다 / 즉시 체포합니다). 그는 문득 어린 시절, 해부를 당할 운명이었던 새끼 토끼를 보고도 두려워서 구해주지 못했던 자신의 (비겁함 / 용감함)을 떠올립니다. 법을 집행해야 하는 임무와, 한 인간의 불행한 삶에 대한 (연민 / 분노) 사이에서 그는 깊은 내적 갈등에 빠집니다.

4. 법을 넘어선 인간적인 선택

고개를 모두 내려온 억구는 아버지의 산소에 들렀다 (자수하겠다며 / 도망가겠다며) 홀로 눈 덮인 산길로 향합니다. 그 초라하고 외로운 뒷모습을 한참 동안 바라보던 형사는, 무언가 결심한 듯 억구를 불러 세웁니다. 그리고는 수갑 대신, 자신이 가지고 있던 (담배 한 갑 / 비상금 전부)을 건넵니다. 그 안에는 담배 18개비가 들어 있었죠. 형사는 "하루에 꼭 한 개씩만 피우셔야 합니다"라는 알 수 없는 말을 남기고 돌아섭니다. 이는 범인을 체포하는 대신, 그에게 18일이라는 마지막 시간을 허락한 형사의 (인간적인 / 비합리적인) 선택이었습니다. 형사가 멀어지는 동안, 눈 덮인 산속에서는 억구의 울음인지 웃음인지 모를 소리가 길게 울려 퍼집니다.`
        };

        // 2단계: 어휘 학습 데이터
        const vocabularyData = [
            {
                word: "동행",
                meaning: "길을 가는 데 짝이 됨. 또는 그 짝.",
                type: "개념",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"동행\"의 의미는?",
                        correct: "길을 가는 데 짝이 됨, 또는 그 짝",
                        distractors: ["여행의 전 과정", "같은 직장에서 일하는 사람", "우연히 만난 사람과의 대화"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"길을 가는 데 짝이 됨. 또는 그 짝.\"을 나타내는 용어는?",
                        correct: "동행",
                        distractors: ["여정", "동료", "동반자"]
                    }
                ]
            },
            {
                word: "여로",
                meaning: "나그네가 다니는 길. 또는 여행 중에 느끼는 쓸쓸한 마음.",
                type: "개념",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"여로\"의 의미는?",
                        correct: "나그네가 다니는 길, 또는 여행 중 느끼는 쓸쓸한 마음",
                        distractors: ["고향으로 돌아가는 길", "여행 계획표", "산을 넘어가는 고개"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"나그네가 다니는 길 또는 여행 중의 쓸쓸함\"을 나타내는 용어는?",
                        correct: "여로",
                        distractors: ["귀로", "일정", "행낭"]
                    }
                ]
            },
            {
                word: "인도주의",
                meaning: "인간애를 존중하고 인류의 복지 향상을 꾀하는 것을 이상으로 하는 사상.",
                type: "개념",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"인도주의\"의 의미는?",
                        correct: "인간애를 존중하고 인류의 복지를 추구하는 사상",
                        distractors: ["전쟁을 반대하는 태도", "가난한 이에게 돈을 주는 행위", "단체의 이익을 우선하는 신념"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"인간애를 존중하고 인류 복지를 이상으로 삼는 사상\"을 나타내는 용어는?",
                        correct: "인도주의",
                        distractors: ["자선", "평화주의", "이타주의"]
                    }
                ]
            },
            {
                word: "죄의식",
                meaning: "저지른 죄에 대하여 스스로 느끼는 부끄러운 마음.",
                type: "개념",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"죄의식\"의 의미는?",
                        correct: "저지른 죄에 대해 스스로 느끼는 부끄러움",
                        distractors: ["과거 선택에 대한 아쉬움", "경쟁에서 져서 느끼는 좌절감", "남을 속인 뒤의 통쾌함"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"저지른 죄에 대해 스스로 느끼는 부끄러운 마음\"을 나타내는 용어는?",
                        correct: "죄의식",
                        distractors: ["회한", "패배감", "후광효과"]
                    }
                ]
            },
            {
                word: "생경하다",
                meaning: "어색하고 서먹하다.",
                type: "상황/정서/태도",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"생경하다\"의 의미는?",
                        correct: "어색하고 서먹하다",
                        distractors: ["예의 바르고 공손하다", "매우 친근하고 편안하다", "유머러스하고 경쾌하다"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"어색하고 서먹한 상태\"를 가장 잘 나타내는 용어는?",
                        correct: "생경하다",
                        distractors: ["활달하다", "유쾌하다", "친밀하다"]
                    }
                ]
            },
            {
                word: "을씨년스럽다",
                meaning: "몹시 쓸쓸하고 스산하여 마음이 움츠러드는 듯하다.",
                type: "상황/정서/태도",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"을씨년스럽다\"의 의미는?",
                        correct: "몹시 쓸쓸하고 스산하다",
                        distractors: ["밝고 따뜻하다", "조용하고 한적하다", "북적이고 활기차다"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"몹시 쓸쓸하고 스산한 느낌\"을 나타내는 용어는?",
                        correct: "을씨년스럽다",
                        distractors: ["잔잔하다", "화사하다", "분주하다"]
                    }
                ]
            },
            {
                word: "적연하다",
                meaning: "아무런 소리 없이 고요하다.",
                type: "상황/정서/태도",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"적연하다\"의 의미는?",
                        correct: "아무런 소리 없이 고요하다",
                        distractors: ["장엄하고 의식적이다", "혼잡하고 시끄럽다", "불안하고 소란스럽다"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"아무 소리 없이 고요한 상태\"를 나타내는 용어는?",
                        correct: "적연하다",
                        distractors: ["장중하다", "분주하다", "소란하다"]
                    }
                ]
            },
            {
                word: "연민",
                meaning: "남의 사정이나 처지를 안타깝고 가엾게 여김.",
                type: "상황/정서/태도",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"연민\"의 의미는?",
                        correct: "남의 처지를 가엾게 여김",
                        distractors: ["남의 의견에 무조건 동의함", "칭찬과 승인을 베풂", "논리로 설득함"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"남의 처지를 가엾게 여기는 마음\"을 나타내는 용어는?",
                        correct: "연민",
                        distractors: ["공감대", "찬사", "논증"]
                    }
                ]
            },
            {
                word: "터벌터벌",
                meaning: "힘없이 느릿느릿 걷는 모양.",
                type: "행동/묘사",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"터벌터벌\"의 의미는?",
                        correct: "힘없이 느릿느릿 걷는 모양",
                        distractors: ["보폭을 넓게 빠르게 걷는 모양", "이리저리 빈둥거리며 걷는 모양", "급히 뛰듯이 걷는 모양"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"힘없이 느릿느릿 걷는 모양\"을 나타내는 말은?",
                        correct: "터벌터벌",
                        distractors: ["성큼성큼", "어슬렁어슬렁", "종종걸음"]
                    }
                ]
            },
            {
                word: "질러 가다",
                meaning: "먼 길을 돌지 않고 가깝게 질러서 가다.",
                type: "행동/묘사",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"질러 가다\"의 의미는?",
                        correct: "먼 길을 돌지 않고 가깝게 가다",
                        distractors: ["앞사람을 추월해 가다", "여러 곳 경유해 천천히 가다", "일정에 따라 정해진 길로만 가다"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"먼 길을 돌지 않고 가깝게 가는 것\"을 나타내는 말은?",
                        correct: "질러 가다",
                        distractors: ["앞질러 가다", "돌아서 가다", "순례하다"]
                    }
                ]
            },
            {
                word: "객혈",
                meaning: "기관지나 폐에서 나온 피를 기침과 함께 토해 내는 일.",
                type: "행동/묘사",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"객혈\"의 의미는?",
                        correct: "기관지·폐에서 나온 피를 기침과 함께 토해 냄",
                        distractors: ["위에서 올라온 피를 토함", "콧속이 말라 피가 남", "상처에서 새어 나오는 피"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"기관지나 폐에서 나온 피를 기침과 함께 토하는 일\"을 나타내는 용어는?",
                        correct: "객혈",
                        distractors: ["토혈", "비출혈", "출혈"]
                    }
                ]
            },
            {
                word: "담배",
                meaning: "불을 붙여 연기를 빨아들이는 기호품의 하나. 소설에서는 인간적 연민과 구원의 가능성을 상징함",
                type: "상징물",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"담배(작품 속 상징)\"의 의미는?",
                        correct: "인간적 연민과 유예된 시간의 상징",
                        distractors: ["권력과 통제의 상징", "부와 성공의 상징", "냉혹한 법의 상징"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"인간적 연민과 유예된 시간을 상징하는 매개\"는?",
                        correct: "담배",
                        distractors: ["수갑", "나침반", "장갑"]
                    }
                ]
            },
            {
                word: "고개",
                meaning: "산을 넘어 다니는 비탈진 길. 소설에서는 인생의 시련과 고난을 상징함",
                type: "상징물",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"고개(작품 속 상징)\"의 의미는?",
                        correct: "시련과 고난을 상징",
                        distractors: ["풍요와 여유를 상징", "안정과 안락을 상징", "유희와 오락을 상징"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"시련과 고난을 암시하는 공간 상징\"은?",
                        correct: "고개",
                        distractors: ["정원", "마을 잔치", "시장터"]
                    }
                ]
            },
            {
                word: "눈",
                meaning: "공기 중의 수증기가 찬 기운을 만나 얼어서 땅으로 떨어지는 얼음의 결정. 소설에서는 시련, 정화, 화해 등의 복합적 의미를 지님",
                type: "상징물",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"눈(작품 속 상징)\"의 의미는?",
                        correct: "시련이자 정화·포용의 이중 상징",
                        distractors: ["권력과 지배의 상징", "무질서와 혼란의 상징", "금전과 이익의 상징"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"시련과 정화의 이중 의미를 지닌 소재\"는?",
                        correct: "눈",
                        distractors: ["비", "달", "햇살"]
                    }
                ]
            },
            {
                word: "희떠운 소리",
                meaning: "실속이 없고 미덥지 아니한 말.",
                type: "관용 표현",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: "\"희떠운 소리\"의 의미는?",
                        correct: "실속 없고 미덥지 않은 말",
                        distractors: ["사실에 근거한 보고", "정중한 사과문", "진지한 설득"]
                    },
                    {
                        type: "meaning-to-word",
                        question: "\"실속 없고 미덥지 않은 말\"을 가리키는 표현은?",
                        correct: "희떠운 소리",
                        distractors: ["공식 발표", "진술서", "항의문"]
                    }
                ]
            }
        ];

        // 3단계 문장 독해 데이터
        const sentenceData = [
    {
        sentence: "참, 선생은 춘천에서 오신다기에 말씀입니다만, 혹시 어제 근화동에서 살인 사건이 생긴 걸 아시우?",
        question: "[인물 파악] 이 말을 한 사람은 누구이며, 그의 심리적 의도는 무엇이라고 추측할 수 있는가?",
        correctAnswer: "억구·상대가 형사인지 떠봄",
        distractors: ["형사·자백을 유도함", "형사·친분 맺어 긴장 완화", "억구·즉시 자수하려 함"]
    },
    {
        sentence: "선생, 우리 일루 질러 갑시다.",
        question: "[의도 파악] '억구'가 굳이 험한 지름길로 가자고 제안한 이유는 무엇일지 두 가지 측면에서 서술하시오.",
        correctAnswer: "의지 시험+지치게 해 따돌림",
        distractors: ["경치 배려·추억 공유", "길 숙지 과시·마을 안내", "안전 우선·시간 단축"]
    },
    {
        sentence: "제엔장, 일룬 안 되겠수다. 여긴 여울이라 놔서….",
        question: "[상황 파악] '억구'가 이 말을 하기 직전과 직후의 상황을 통해, 그가 동행하는 '형사'를 어떻게 대하고 있는지 알 수 있는가?",
        correctAnswer: "정보 숨기며 적대·경계 유지",
        distractors: ["즉시 알려 돕는 협조 태도", "의존적으로 도움 요청", "거짓으로 혼란 주는 장난"]
    },
    {
        sentence: "난 기어코 득술 죽이고야 만 겁니다. 거 왜, 사변 때 말입니다. 파리 새끼 쥑이듯 사람 막 쥑일 때 말이죠.",
        question: "[심리 파악] '억구'가 자신의 과거 살인 경험을 이처럼 담담하게 고백하는 이유는 무엇인가?",
        correctAnswer: "전쟁 핑계로 죄책감 희석",
        distractors: ["용감함 과시로 위협", "연민을 구해 참회", "과장해 무죄 위장"]
    },
    {
        sentence: "우리 부자만 몰랐지. 동네에서들은 모두 국군이 머지않아 돌아온다는 걸 알고들 있었던 거죠. 결국 자기들 손으로 우릴 부잘 처치해 버리자는 생각들이었겠죠.",
        question: "[인과 파악] '억구'는 자신의 아버지가 죽게 된 원인을 무엇이라고 생각하고 있는가?",
        correctAnswer: "이웃의 배신·자기보호 계산",
        distractors: ["오직 북한군 때문", "오직 국군의 오판", "부친 정치 활동 탓"]
    },
    {
        sentence: "김득칠인 어제 근화동서 살해됐습니다.",
        question: "[역할 파악] 이 대사는 두 인물의 관계와 소설의 긴장감에 어떤 변화를 가져오는가?",
        correctAnswer: "형사, 범인 인지→긴장 고조",
        distractors: ["동정 표명→긴장 완화", "모른다 밝혀 안도", "범인 아님 확인 신뢰"]
    },
    {
        sentence: "난 그 광 속에서 이틀 동안이나 이빨 사이에 박힌 장갑 실오래길 빼려구 내가 얼마나 애를 썼는지 아슈?",
        question: "[의미 파악] '억구'에게 '광 속의 기억'과 '장갑 실오라기'는 어떤 의미를 지니는 상징적인 소재인가?",
        correctAnswer: "억압·모멸의 기억과 상처",
        distractors: ["놀이와 순수의 추억", "가난의 물질 결핍", "단순한 사고 상처"]
    },
    {
        sentence: "이왕 이 세상에 나온 이상 한 번 태어난 값이나 해 보자, 한번쯤은 인간답게 살아 보구 싶었던 겁니다.",
        question: "[심리 파악] 이 대사를 통해 알 수 있는 '억구'의 근원적인 소망은 무엇인가?",
        correctAnswer: "존중받는 평범한 삶 소망",
        distractors: ["부 축적해 가난 극복", "복수 완수의 쾌감", "명예·칭찬의 갈망"]
    },
    {
        sentence: "선생, 난 득수 동생놈을, 그 김득칠일 어제 죽였단 말이오, ... 자, 날 어떻게 하겠수?",
        question: "[심리 파악] 모든 것을 자백한 '억구'가 형사에게 이런 질문을 던지는 심리는 무엇일지 추측하여 서술하시오.",
        correctAnswer: "이해·연민·구원 갈망",
        distractors: ["조롱과 도발의 우월감", "무죄 주장·석방 요구", "신분 확인 시험"]
    },
    {
        sentence: "결국, 난 새끼 토낄 구할 생각을 거두고 담만 돌다 돌아오고 말았지.",
        question: "[인물 비교] '형사'가 과거의 이 '토끼 이야기'를 떠올리는 이유는 무엇이며, 이 이야기는 '억구'의 어떤 모습과 연결되는가?",
        correctAnswer: "비겁함 자성→억구에 연민",
        distractors: ["용기 자랑→억구 경멸", "잔혹 회한→동질감 강화", "긴장 완화용 잡담"]
    },
    {
        sentence: "하루에 꼭 한 개씩만 피우셔야 합니다.",
        question: "[상징적 의미 파악] '형사'가 '억구'에게 담배를 주며 한 이 말의 상징적인 의미는 무엇인가?",
        correctAnswer: "18일 자유 유예의 표식",
        distractors: ["건강 위한 금연 조언", "감시 경고의 의미", "직무 엄정 절차"]
    },
    {
        sentence: "그러면서 그는 느닷없이 웃음을 터뜨리는 것이었다. ㅎ ㅎ ㅎ ㅎ ㅎ ㅎ ㅎ….",
        question: "[심리 파악] 소설의 마지막, '억구'가 터뜨린 '울음 같은 웃음'에는 어떤 복합적인 감정이 담겨 있는지 서술하시오.",
        correctAnswer: "허망·감사·구원 희망 뒤섞임",
        distractors: ["속였다는 승리의 흥분", "권력 비웃는 조롱", "광기·운명 저주의 분노"]
    }
        ];

        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            renderPassage();
            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 지문 렌더링
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 마크다운 처리 (하이라이트 처리 전에 먼저 실행)
            // 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (마크다운 테이블을 HTML 테이블로 변환)
            const tableRegex = /^\|.+\|$/gm;
            const tableMatches = [];
            let match;
            while ((match = tableRegex.exec(html)) !== null) {
                tableMatches.push(match.index);
            }

            if (tableMatches.length > 0) {
                // 테이블 라인들을 찾아서 그룹화
                let i = 0;
                while (i < tableMatches.length) {
                    let tableStart = tableMatches[i];
                    let tableEnd = tableMatches[i];
                    let j = i + 1;

                    // 연속된 테이블 라인 찾기
                    while (j < tableMatches.length && tableMatches[j] - tableEnd < 100) {
                        tableEnd = tableMatches[j];
                        j++;
                    }

                    // 테이블 텍스트 추출
                    let beforeTable = html.substring(0, tableStart);
                    let afterTable = html.substring(tableEnd + html.substring(tableEnd).indexOf('\n') + 1);
                    let tableText = html.substring(tableStart, tableEnd + html.substring(tableEnd).indexOf('\n'));

                    const lines = tableText.split('\n').filter(line => line.trim().startsWith('|'));

                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0;">';
                    let rowIndex = 0;

                    lines.forEach((line) => {
                        // 구분선 스킵
                        if (line.match(/^\|\s*:?-+:?\s*\|/)) return;

                        const cells = line.split('|').slice(1, -1); // 첫번째와 마지막 빈 요소 제거
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f8f9fa; font-weight: 600;' : '';

                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<${tag} style="border: 1px solid #ddd; padding: 12px; text-align: left; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHTML += '</tr>';
                        rowIndex++;
                    });

                    tableHTML += '</table>';
                    html = beforeTable + tableHTML + afterTable;

                    i = j;
                }
            }

            // 볼드 처리
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                return `<div class="subsection">• ${content}</div>`;
            });

            // 하이라이트 처리 (마지막에 실행 - HTML 변환된 내용에 적용)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            console.log('nextStage() 호출됨, 현재 단계:', currentStage);

            // 현재 단계에 따라 다음 단계로 전환
            if (currentStage === 1) {
                console.log('1단계 → 2단계로 이동');
                initStage2();
            } else if (currentStage === 2) {
                console.log('2단계 → 3단계로 이동');
                initStage3();
            } else if (currentStage === 3) {
                console.log('3단계 → 4단계로 이동');
                initStage4();
            } else if (currentStage === 4) {
                console.log('4단계 → 5단계로 이동');
                initStage5();
            } else if (currentStage === 5) {
                console.log('5단계 → 최종 결과로 이동');
                showFinalResults();
            } else {
                console.error('알 수 없는 단계:', currentStage);
            }
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            console.log('initStage2() 호출됨');

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            currentStage = 2;
            console.log('currentStage를 2로 설정함');

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // vocab.questions 배열의 각 문제를 처리
                vocab.questions.forEach(q => {
                    const question = {
                        type: q.type,
                        question: q.question,
                        correct: q.correct,
                        word: vocab.word,
                        meaning: vocab.meaning,
                        options: shuffleArray([
                            q.correct,
                            ...q.distractors
                        ])
                    };
                    stage2Data.questions.push(question);
                });
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            console.log('initStage3() 호출됨');

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            currentStage = 3;
            console.log('currentStage를 3으로 설정함');

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장과 질문 표시
            document.getElementById('sentence-text').textContent = question.sentence;
            document.getElementById('sentence-question').textContent = `Q. ${question.question}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);

                const isCorrect = option === question.correct;

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${option}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardText = card.querySelector('.flip-card-front .card-text').textContent;
                        if (cardText === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }

        // ================== 4단계: OX퀴즈 ==================
        const stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],  // 틀린 문제 저장
            startTime: null,
            timeRemaining: 120
        };

        // OX퀴즈 데이터
        const oxQuizData = [
    { question: "억구와 형사는 정월 보름날 밤, 우연히 동행하게 되었다.", answer: true, explanation: "지문 내용과 일치합니다." },
    { question: "형사는 억구의 초라한 행색을 보고 처음부터 그를 살인 사건의 범인으로 확신했다.", answer: false, explanation: "문학 선택지 패턴 '⑧ 했냐 안 했냐 (사실/비사실 혼동)'. 형사는 억구를 체포하러 가는 길이었지만, 처음부터 그가 범인임을 확신하고 대하지는 않았습니다. 억구의 이야기를 들으며 점차 확신하게 됩니다." },
    { question: "억구는 형사를 따돌리기 위해 일부러 험한 지름길로 그를 안내했다.", answer: true, explanation: "지문 내용과 일치합니다. 억구는 형사의 정체를 떠보고, 가능하면 도망치려는 의도로 험한 길을 선택합니다." },
    { question: "형사는 어린 시절, 위험에 처한 새끼 토끼를 용감하게 구해 준 경험이 있다.", answer: false, explanation: "문학 선택지 패턴 '① Good vs Bad (긍정/부정 왜곡)'. 형사는 토끼를 구해주지 못하고('담만 돌다 돌아오고 말았지') 자신의 비겁함을 자책했습니다. 구해주지 못한 부정적(-) 경험을 용감하게 구해준 긍정적(+) 경험으로 왜곡했습니다." },
    { question: "억구는 한국 전쟁 당시 공산주의자로 활동하며 '득수'를 직접 자기 손으로 죽였다.", answer: true, explanation: "지문 내용과 일치합니다." },
    { question: "형사는 폐 질환을 앓고 있으며, 잦은 기침과 객혈 증세를 보인다.", answer: true, explanation: "지문 내용과 일치합니다. 이는 그의 육체적 한계를 암시하며, 억구에 대한 연민을 심화시키는 장치로도 작용합니다." },
    { question: "억구는 형사가 건넨 담배를 받자마자 그 자리에서 모두 피워버렸다.", answer: false, explanation: "문학 선택지 패턴 '⑧ 했냐 안 했냐 (사실/비사실 혼동)'. 형사는 \"하루에 꼭 한 개씩만 피우라\"고 말했고, 억구는 그 말을 되뇌며 웃음을 터뜨렸을 뿐, 담배를 모두 피웠다는 내용은 없습니다." },
    { question: "억구는 춘천 술집에서 만난 '득칠'이 자신의 아버지를 잘 모셔주었다는 말에 고마움을 느꼈다.", answer: true, explanation: "지문에서 \"우선 놈의 얘기가 고맙더군요.\"라고 직접적으로 서술되어 있습니다." },
    { question: "형사는 억구의 불행한 과거 이야기를 듣고 그에 대한 연민을 느끼기 시작했다.", answer: true, explanation: "지문 내용과 일치합니다. 험한 여정을 함께하고 그의 이야기를 들으며 형사의 내면에 갈등과 연민이 생겨납니다." },
    { question: "'구듬치고개'는 억구와 형사가 함께 넘는 마지막 고개로, 두 사람의 심리적 거리가 가까워지는 공간이다.", answer: true, explanation: "지문 내용과 일치합니다. 이 고개를 넘으며 억구는 자백을 하고, 형사는 내적 갈등 끝에 인간적 연민을 선택하게 됩니다." },
    { question: "억구는 어린 시절 '득수'의 손등을 물어뜯은 일로 계모에 의해 광에 갇힌 경험이 있다.", answer: true, explanation: "지문 내용과 일치합니다. 이 기억은 억구에게 깊은 트라우마로 남아 있습니다." },
    { question: "형사는 억구의 자백을 듣자마자 그 자리에서 수갑을 채워 그를 체포했다.", answer: false, explanation: "문학 선택지 패턴 '④ 순서/방향 왜곡'. 형사는 자백을 들은 후에도 망설이고 내적 갈등을 겪다가(①), 최종적으로는 그를 체포하지 않고 시간을 벌어주었습니다(②). 사건의 순서를 왜곡했습니다." },
    { question: "억구는 험한 산길을 걷는 내내 동행하는 형사를 걱정하며 길을 안내했다.", answer: false, explanation: "문학 선택지 패턴 '⑤ 의도/목적 왜곡'. 억구의 의도는 형사를 시험하고 따돌리려는 것이었지, 걱정하고 배려하려는 것이 아니었습니다. 행위의 의도를 정반대로 왜곡했습니다." },
    { question: "억구는 자신의 아버지가 마을 사람들의 배신으로 죽었다고 생각한다.", answer: true, explanation: "지문 내용과 일치합니다. 국군이 돌아온다는 것을 알면서도 자신들에게 알려주지 않고, 자기들 손으로 처리하려 했다고 믿고 있습니다." },
    { question: "소설의 배경인 '눈'은 두 인물이 겪는 시련과 화해를 상징한다.", answer: true, explanation: "지문 내용과 일치합니다. 눈은 시련 외에도 모든 것을 덮어주는 정화와 화해의 의미도 지닙니다." },
    { question: "형사는 억구에게 담배 18개비를 주며 18일간의 시간을 주었다.", answer: true, explanation: "지문 내용과 일치합니다. 담배 두 개비를 피웠으므로 남은 18개비는 18일을 상징합니다." },
    { question: "억구는 득칠을 죽인 것에 대해 전혀 죄책감을 느끼지 못하고 자신의 행동을 정당화했다.", answer: false, explanation: "문학 선택지 패턴 '② A vs B (비교 대상 혼동)'. 억구는 \"왜 내가 그 득칠일 죽였는지...\"라고 말하며 자신의 행동에 대한 혼란스러움과 죄책감(A)을 드러냅니다. 이를 완전한 정당화(B)로 표현한 것은 사실과 다릅니다." },
    { question: "두 사람이 길에서 만난 집주인 남자는 '억구'의 이름을 듣고 그를 반가워했다.", answer: false, explanation: "문학 선택지 패턴 '① Good vs Bad (긍정/부정 왜곡)'. 집주인 남자는 억구의 이름을 듣고 \"그 사람이 정신이 있나? 와야릴 제 발루...\"라며 놀라고 두려워하는 반응(-)을 보였습니다. 이를 반가워했다는 긍정적(+) 반응으로 왜곡했습니다." },
    { question: "억구는 형사가 자신의 정체를 이미 알고 있음을 깨닫고 순순히 자백했다.", answer: false, explanation: "문학 선택지 패턴 '⑥ 인과 관계 왜곡'. 억구는 형사가 자신의 정체를 밝히기 전에(\"김득칠인 어제... 살해됐습니다.\") 먼저 자신의 이야기를 털어놓으며 자백의 과정을 밟고 있었습니다. 형사의 말 때문에 자백했다는 것은 인과 관계가 맞지 않습니다." },
    { question: "형사는 법 집행관의 임무와 인간적인 연민 사이에서 내적 갈등을 겪는다.", answer: true, explanation: "지문 내용과 일치하며, 이 작품의 핵심적인 갈등 양상입니다." }
        ];

        // 4단계 초기화
        function initStage4() {
            console.log('initStage4() 호출됨');

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;
            console.log('currentStage를 4로 설정함');

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '전상국 <동행>';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 4';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.question}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.question,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 진짜 원문 표시
            const originalText = ` 발목까지 빠져드는 눈길을 두 사내가 1)터벌터벌 걷고 있었다. 우중충 흐린 하늘은 곧 눈발이라도 세울 듯, 이제 한창 밝을 정월 보름달이 2)시세를 잃고 있는 밤이었다.
 앞서서 걷고 있는 사내는 작은 키에 3)다부져 보이는 체구였지만 그 걸음걸이가 어딘지 모르게 허전허전한 느낌을 주는 것이었다.
이 사내로부터 두서너 걸음 뒤져 걷고 있는 사내는 4)멀쓱한 키에 언뜻 보아 맺힌 데 없다는 인상을 주면서도 앞선 쪽에 비해 그 걸음걸이는 한결 정확했다.
큰 키에 사내가 5)중절모를 눌러 쓰고 밤색 6)오버에 푹 싸이다시피 방한(防寒)에 빈틈이 없어 보이는가 하면 키 작은 사내는 희끔한 와이셔츠 위에 다만 양복 하나를 걸쳤을 뿐, 그 차림새가 퍽도 7)을씨년스러워 보였다. 그 양복이라는 것도 윗도리의 품이 좁디좁고 길이도 8)깡똥한 반면 아랫바지는 헐렁하게 크기만 해 걷어올린 바짓가랑이에 눈이 녹아 붙어 걸음을 옮길 적마다 서걱거렸다. 그 작은 키에 어깨를 잔뜻 좁혀, 을씨년스럽고 초라한 모습이었다.
"정말 이렇게 9)동행을 얻어 다행입니다."
큰 키의 사내가 10)깡깡하면서도 어딘가 여유를 둔 나지막한 목소리로 말했다.
"예, 밤길을 혼자 걷기란 11)맹했죠. 더욱이 이런 산골 눈길은…."
하고, 앞서 걷던 작은 키의 사내가 어떤 생각으로부터 후다닥 벗어나기라도 한 듯, 12)생경한 목소리로 받았다.
그리고 곧 자기 쪽에서 말을 건네 왔다.
"참, 선생은 춘천에서 오신다기에 말씀입니다만, 혹시 어제 근화동에서 살인 사건이 생긴 걸 아시우?"
그러자 큰 키의 사내는 흠칫 몸을 추슬렀다가 좀 사이를 두어,
"살인이라면…아, 네! 알구말구요. 사실 전 우연한 기회로 형장까지 봤습니다만…."
하고 조심스레 말을 흐렸다.
그러자 키 작은 사내가 주춤 멈춰 서서 다그치듯,
"허, 현장엘? 그래요? 그 술집엔 선생이 가 보셨다구…?"
다시 몇 걸음 떼어 놓다가 말을 이었다.
"근데, 거, 말입니다. 그 살인범을 경찰에선 쉬 잡아 낼 수 있겠습니까?
뭐, 13)단서 같은 거라두…


그러자, 큰 키의 사내는 잠깐 머뭇거리다, 글쎄요, 그건 잘 모르겠군요.
중얼거리듯 잘라 놓곤 이어,
"그런데 노형은 아까 원주에서 오신다고 하신 듯한데 어떻게 벌써 그 사건을 그렇게…역시 소문이란…."
그냥 흘려 넘기는 투였다.
그러나 이때 키 작은 사내가 주춤 멈춰 서며,
"아아니 선생, 이거 왜 이러슈, 내가 언제 원주에서 온다고 했단 말이유?"14)무턱 15)시비조였다.
"아, 그러십니까? 제가 그만…."
그제야 멈춰 섰던 사내가 다시 걸음을 옮겨 놓기 시작했다. 큰 키의 사내도 어깨를 한 번 으쓱 16)추키곤 앞선 쪽의 뒤를 부지런히 따라붙었다.
그렇게 상당한 거리를 서로 한 마디의 대화도 없이 눈길을 터벌터벌 걷던 그들이 문득 고개를 쳐들었을 때, 그들 시야에 꽤 넓은 평지를 사이에 두고 좀 멀찍이 놓인 17)산마루가 희미한 채 그 윤곽을 드러내 보이고 있었다.
작은 키의 사내가 걸음을 멈추고 18)엉거주춤한 자세로 19)질금질금 소변을 보기 시작했다. 이때 큰 키의 사내는 바짓가랑이와 오버 자락에 엉겨붙은 눈을 털어 내다가 불쑥,
"저 재 너머가 바루 와야리겠습니다그려?"
하고 무슨 병명이라도 하듯, 20)초행이라 놔서…했다.
그러나 키 작은 쪽은 대꾸도 없이 바지 단추를 더듬거려 채우다간,
"가만있자…이 길루 21)내처 가면 22)엔간히 돌 게구…."
곧 뒷사내를 향해,
"선생, 우리 일루 23)질러 갑시다."
그런 다음 이쪽 대답은 아랑곳없다는 듯 지금 그들이 걸어온 24)한길을 벗어나 도무지 길이 있을 것 같지 않은, 그냥 눈 덮인 밭으로 터벌터벌 걸어 들어가고 있었다.
"질러 가는 겁니까? 허지만 이 눈에 저 고갤…좀 돌더라두…."
언제나 25)말미를 흐리곤 하는 큰 키의 사내가 아직 한길에서 내려서지도 않은 채 26)머뭇댔다.
"맘대루 허슈, 난 일루 가겠수다."
뒤도 돌아보지 않은 채 작은 키의 사내는 터벌터벌 발목까지 빠져드는 흰 눈발을 걸어 나갔다.
그러자 큰 키의 사내는 퍽 난처하다는 듯 한동안 망설이다가,
"여보시오, 노형, 나 잠깐!"
그러나 키 작은 사내는 뒤도 돌아보지 않았다.
큰 키의 사내는 무슨 결심이라도 한 듯 어깨를 한 번 으쓱 추켜올리곤 한길에서 내려서 앞서 간 쪽의 발자국을 조심스레 되밟아 나갔다.
앞서 가던 쪽이 27)밭두렁에서 발을 헛디뎌 앞으로 넘어졌다. 그러나 곧바로 몸을 세워 옷에 묻은 눈을 털 생각도 않고 그냥 걷고만 있었다. 그렇게 키 작은 쪽이 28)허청거릴 적마다 큰 키의 사내는 오버 주머니에서 가죽장갑 낀 손을 빼어 줄타기하듯 조심스레 발을 옮기곤 했다.


바짓가랑이에 붙은 눈을 열심히 털면서.
그들이 지금 가로지른 평지가 끝난 바로 앞에 하천이 하나 가로놓여 있었다.
"여길 건너야 할 텐데…."
작은 키의 사내가 벌써 아래로 내려서면서 중얼거렸다. 언뜻 보기에 거기 개울이 있다고 보기엔 어려웠다. 다만 잘잘거리는 물소릴 듣고야 바로 앞에 막아 선29)산기슭을 타고 30)개울이 흐리고 있다는 걸 짐작할 수밖에 없었던 것이다.
"얼음이 잘 얼었을까요? 물이 많진 않을 것 같습니다만…."
큰 키의 사내가 조심스레 개울로 내려서며 말했지만 역시 앞선 쪽은 대답이 없었다.
온통 눈으로 덮인 개울은 처음엔 자갈이 밟혔다. 좀더 들어가자 31)덧물이 흘렀다가 언 층이 발 닿는 곳마다 부적부적 소릴 냈다. 큰 키의 사내는 언제나 앞선 쪽의 발자국을 되디디며 그것도 못 미더운지 몇 번씩 발을 굴러 보곤 했다.
이때 앞서 걷던 사내가 뒤로 돌아서며, 여긴 안 되겠수다-중얼거리는 거와 동시에 그의 한쪽 발이 뿌지직 얼음을 깨뜨렸다. 그러자 사내는 다시 몸을 돌려 껴져 드는 얼음 위를 철벅철벅 걸어가며,
"어어, 물 차다!"
꺼져 버린 얼음 조각들이 흐르는 물에 처르르 씻겨 내리고 있었다. 눈 덮여 희던 개울 바닥이 그가 걸어 나간 뒤를 좇아 차츰차츰 검은 빛으로 번져 나갔다.
그렇게 찬물 속을 철벅거리며 개울을 다 건넌 사내는 이쪽에서 아직 어쩌지 못해 서성거리고 있는 큰 키의 사내를 향해 소리치는 것이었다.
"32)제엔장, 일룬 안 되겠수다. 여긴 33)여울이라 놔서…."
키 작은 사내는 산기슭을 타고 개울 상류로 거슬러 오르고 있었다. 이쪽 사내는 34)안절부절못하는 몸짓으로 역시 같은 방향으로 거슬러 오르며 눈을 항시 건너편 사내에게서 뗄 줄 몰랐다.
그렇게 얼마쯤 허둥대고 걷다가 큰 키의 사내는 무턱대고 개울로 들어섰다. 다행히 여울이 아닌 모양이어서 쉽게 건널 수 있었다. 그러나 키 작은 사내는 이쪽에 한 번 주는 법 없이 서벅서벅 제 발길만 옮기고 있었다. 큰 키의 사내는 꽤35)허덕댄 다음에야 앞선 쪽을 따라갈 수 있었다.
역시 앞 사내의 발자국을 되밟으며 따라 걷던 큰 키의 사내는 힉 한 번 혼자 웃었다. 앞 사내의 바지가 36)정강이까지 온통 물에 젖어 있어 차츰 얼어들고 있는 것이었다.
"노형, 그거 그렇게 젖어서 어떻게 합니까? 진작 이 위로 건너실걸…."
"제에기랄, 누가 아니래우. 근데 옷은 이렇게 벌써 삐쩍 얼어드는 이놈의 발이 통 한 시렵다니…."
잠시 사이를 우었다간,
"그래, 꼭 그날 밤도 이랬지! 제기랄…."
신음하듯 중얼댔다.그러자 큰 키의 사내가, 그날 밤이라뇨…? 하고 불쑥 물었다. 그러나 앞선 사내는 대꾸 없이 개울 상류를 향해 자꾸 치오르며 옆 37)산비탈을 올려다보곤 했다.


금세 눈이 내릴 듯 우중충 흐린 밤이었지만 날은 퍽 차가웠다.
드디어 키 작은 사내의 바짓가랑이가 데거덕거리기 시작했다.
그렇게 자꾸 산비탈을 훔쳐 보며 개울 기슭을 따라 작은 키의 사내가 다시 주춤 멈춰 섰다.
"항, 이거 아무래도 잘못 잡았지…."
그러면서 사방을 두러번거렸다.
"눈에 흘린다더니, 정말 눈길을 걷기란 힘이 듭니다그려."
오버 자락의 눈을 털면서 큰 키의 사내가 말했다.
"선생한텐 정말 이만하우, 제에기랄, 이놈의 델 와 본 지도 꽤 오래 돼 놔서…."
"그럼 여기가 고향…?"
그러나 키 작은 사내는 이쪽 말은 38)염두에도 없다는 듯 제 39)궁리에 잠겼다가,
"에라, 40)내친김에 좀더 올라가 볼 수밖에-."
하고 다시 데걱거리며 걷기 시작했다.
그렇게 한참을 걸었다. 그러나 앞선 쪽의 사내는 다시 걸음을 멈추며 속으로 가만히 한숨을 몰아 쉬는 것이었다. 이때 함께 멈춰 발을 탁탁 구르며 주위를 41)두리번대던 큰 키의 사내가 한쪽을 가리켜 보였다.
산을 끼고 흐르던 개울이 점차 산비탈과 그 거리를 벌리면서 그 중간쯤에 집 한 채가 오똑 눈에 띄었다. 누가 먼저 말을 낸 것도 아닌데 그들은 그 쪽으로 발을 옮기고 있었다.
집 앞의 길은 꽤 넓게 눈에 쓸려 있었다. 눈이 쓸리고 거뭇거뭇 드러난 맨땅에 이르러 그들은 옷에 묻은 눈을 털었다. 키 작은 쪽의 바짓가랑이는 달라붙은 눈덩이와 함께 데걱데걱 얼어 있었다.
키 작은 사내가 42)사립문 앞으로 다가갔다.
이때 허리를 굽히고 열심히 눈을 털던 큰 키의 사내가 큿큿 기침을 하기 시작했다. 꽤 43)밭은, 그리고 사뭇 어깨를 움츠린 채였다. 기침이 멎자 그는 눈 위에 무엇인가 뱉었다. 짙은 자국이 눈 위에 드러났다. 발로 즉시 그 자국을 뭉개 버렸다. 그리고 손수건을 꺼내어 거기에 무엇인가 또 뱉었다. 그 손수건을 유심히 들여다본 다음 다시 입언저리를 말끔히 닦았다.
"많이 변했군 이런 데 집이 다 있구, 헌데 이눔의 집은 초저녁부터 44)자빠져 자는 건가?"
키 작은 사내가 사립문 위로 고개를 세워 들고 안을 기웃거리다가 언성을 높여,
45)"여보시우, 46)쥔장! 거 말 좀 물어 봅시다."
그러나 안에선 기척이 없었다.
제엔장, 눈까지 친 걸 보면 빈 집이 아닌 건 분명한데 하고, 키 작은 사내가 사립문을 마구 흔들어 대기 시작했다. 사립문에 달린 깡통이 쩔렁쩔렁 울렸다.
그러기를 한참, 드디어 안에서 두런거리는 소리가 들리는가 싶더니,
"거, 누구유? 첫잠에 그만 빠져서…."
하고 남자의 목소리가 들렸다.
그러나 키 작은 사내는 자꾸 사립문만 흔들어 댔다.
그제야 방문이 삐금 열리며,
"뉘세유?"
이번엔 여자였다.
"거 말 줌 물어 봅시다. 구듬치 고개가 어디쯤 되우?"
그러자 삐끔히 열린 문 사이로 남자의 목소리가 새어 나왔다.
"거 누군지 구듬치 고갤 찾는 걸 보니 와야릴 가는가 본데, 에이 여보슈, 길을 영 잘못 잡았수다. 좀 돌더라두 큰길로 갈 것이지, 거 47)미욱하게 시리 이 눈길에 구듬칠 넘다니!"
쯧쯧, 혀까지 차고 있었다.
작은 키의 사내가 그 말에 48)응수라도 하듯 세차게 사립문을 흔들어 대며,
"아니 여보, 누가 얼루 가든 이거 왜 이래? 거 주인 좀 이리 나오슈!"
49)사뭇 깡깡한 시비조였다.
"에이그 손님, 참으세유. 우리 50)으른은 몸이 불편해서 못 나오세유. 구듬치 고갤 넘으실려구 허세유? 그럼 저 앞에 개울을 따라서 한참 내려가셔야 해유."


"알았수다. 실은 나두 와야리 사람이유. 댁에선 여기 산 지가 얼마 됐는지 모르겠소만 혹시 최억구라구 아시겠수? 바루 내가 최억구란 말이유…."
언 바짓가랑이를 데걱거리며 몸을 돌리던 키 작은 사내가 말했다.
방문을 열고 섰던 아낙네가, 최억구유? 최억구…하고 중얼거렸다.
그러자 갑자기 놀란 남자의 목소리가 방 안으로부터 튕겨 나왔다.
"엥? 최억구라구? 분명 억구랬다! 아아니, 그런데 그 사람이 정신이 있나?
와야릴 제 발루…."
그러나 최억구라고 씹어뱉듯 이름을 밝힌 키 작은 사내는 방 안에서 굴러 나오는 소리엔 아랑곳없다는 듯, 흥, 콧바람을 날리며,
"선생, 가십시다. 제기랄, 좀 서 있으려니 발이 비쩍 얼어드는군…."
심한 기침을 끝내고 아직 말 한 마디 없이 서 있던 큰 키의 사내가 입을 열었다.
"노형, 발이 그렇게 얼어선 안 됩니다. 51)예서 좀 녹여 가지구 가십시다."
그러나 최억구는 이미 저만큼 앞서 걸으며 혼자말하듯 얼어서 안 될 것도 별루 없수다- 했다.
그 기세에 52)머쓱해진 큰 키의 사내 역시 그냥53)덤덤히 키 작은 사내를 따라 나섰다.
두 사내는 조금 전 자기들이 밟고 올라온 눈길을 되밟으며 개울의 흐름을 따라 산비탈을 끼고 내려갔다.
"이거 정말 안됐수! 거 아까 선생 말대루 큰길루 가야 하는 건데, 선생 고생이 말이 아니외다."
아까와는 달리 푹 누그러진 음성으로 얘길 시작한 억구는 이어,
"우습지만, 선생이 와야릴 우째 가시는지 여쭤 보지두 못했네유. 그래, 하필 이 54)설한에 춘천에서 와야릴 뮛 하러 가시는 거유?"
그냥 예사롭게 묻는 투였다.
큰 키의 사내는 좀 당황한 듯 공연히 발을 힘주어 쿵쿵 울려 디디다간,
"예, 뭐 일이…하, 이거 죄송합니다. 55)사삿일이 돼 놔서, 말씀드리기가…."
더듬거렸다.
"사삿일이시라면…."
하고 좀 사이를 두었다가 이어,
"아, 그럼 휴양이라두?"
큰 키의 사내는 56)흠칫 놀란 듯,
"네? 휴양…? 아, 네, 몸이 좀…."
이렇게 57)어물어물 말미를 흐렸다.
"역시 몸이? 아까 기침을 하실 때 58)객혈이 있으시기에…."
"보셨군요. 예, 약두 무척 썼지요. 하지만 그게 좀체루. 역시…제 병은 자기가 잘 알지 않습니까!"
다시 큰 키의 사내는 터져 나오는 기침을 참느라고 큿큿 했다.
"그럼 결국…."
말이 무심결에 뛰어나온 걸 59)엄폐라도 하듯,


"참, 선생은 뭘 하시우? 내 보기엔 어디 관공서에라두 나가시는 것 같은데…."
"예, 뭐, 그저…길이 참 맹했다!"
주춤 몸을 가누며 중절모를 벗어 들었다가 다시 눌러 쓰는 큰 키의 사내였다.
"노형 고향이 와야리시라면 거기 친척이 많으시겠습니다그려…."
억구에게로 질문을 돌리고 있었다.
"친척? 하아, 친척이라…제에기랄…."
억구는 걸음을 잠깐 멈추며 허리춤을 고쳐 올린 다음 씹어뱉듯,
"60)가친이 계시죠. 우리 아버지 말입네다…."
하고는 ㅎㅎㅎ…허탈하게 웃어 댔다.
"아, 그러십니까. 61)춘부장께서 아직…부럽습니다."
"아직 죽지 않았느냐구요? 부럽다구요?"
그렇게 62)다긏던 억구가 다시 허탈한 웃음을 웃었다.
눈 덮인 산골 밤은 냉랭하고 63)적연(寂然)하기만 했다. 다만 개울물 흐르는 소리가 잘잘 두 사내의 눈 밟아 나가는 소리에 어울려지곤 할 뿐이었다.
하늘은 곧 눈을 쏟을 듯 점점 어둑해지기 시작했다. 억구의 언 바짓가랑이가 제법 데걱거리고 있었다.
앞서 걷던 억구가 멈춰 섰다.
거뭇거뭇 64)송림이 우거진 고갯마루를 치어다봤다. 구듬치고개라는 것이었다.
큰 키의 사내가 두어 번 발을 구르며 오보 주머니에서 담배를 꺼내어 65)피봉을 뗐다. 그리고 한 개비를 뽑아 억구에게 내밀었다. 담배를 받아 드는 억구의 맨손이 뻣뻣하게 얼어 있음을 그의 엉거주춤한 손가락을 보아 곧 알 수 있었다. 키 큰 쪽도 한 개를 빼어 물고 성냥을 찾아 가죽장갑 낀 채 불을 댕겼다.
성냥불에 담배를 대고 빠는 억구의 턱이 심하게 떨고 있었다. 첫 성냥개비는 66)허탕이 됐다. 다시 성냥을 그어 대는 큰 키의 사내 시선이 모가 난 억구의 얼굴을 날카롭게 뜯어보고 있었다.
"그래, 와야릴 갈래면 꼭 저놈의 고갤 넘어야 한단 말이우? 내애 참!"
67)생뚱같이 중얼거리는 억구의 말을 큰 키의 사내가 사뭇 송구스럽다는 투로 받았다.
"전 여기가 초행이라 놔서…."
그러나 억구는 흥, 콧바람을 날리며,
"왜 이러슈, 이거! 내가 여길 지릴 몰라 그걸 선생한테 물은 거유?"
하고 튕기듯 68)퉁명을 부렸다. 그리고 담배를 몇 모금 거듭 빨아 연기를 내뿜으며,
"제에기랄, 저놈의 고갤 내가 꼭 넘어야 하는 이유가 도대체 뭐야?"
혼자소릴 했다.
큰 키의 사내는 조용히 억구의 옆모습만 뜯어보고 서 있었다.
문득 옆 사내의 시선을 알아차리기라도 한 듯 억구는 담배를 손끝까지 타들도록 거듭거듭 빨아 대곤 휙 집어던지며 고래를 향해 터덜터덜 오르기 시작했다. 언 바짓가랑이를 데걱거리며.
데걱거리며 고개를 향해 걷기 시작한 억구에게 시선을 떼지 않고 서 있던 큰 키의 사내가 아랫입술을 지그시 물었다. 그리고 고개를 두어 번 끄덕인 다음 억구의 뒤를 따랐다. 터져 나오는 기침을 큿큿 참아가며.
고개로 접어드는 산 기슭, 69)보득솔밭을 지나며 먼저 입을 뗀 것은 억구였다.
"제에기랄, 우리 어렸을 적만 해두 이 보득솔밭엔 토끼두 70)숱했는데…거, 눈이라두 좀 빠졌을 땐 그저 두어 마리 때려잡긴 예사였소만…그런데 거 토끼란 짐승은 눈엔 영 맥을 못 씁데다…."
그러자 큰 키의 사내가 71)회고조로 천천히 말을 받았다.


"이거 토끼 얘기가 나왔으니 생각이 납니다만…."
중학 이 학년 때인가 전교생이 학교 뒷산으로 식수를 나갔다. 이제 싸릿순이 파랗게 터져 오르는 싸리밭에서 토끼똥을 주워 든 아이들이 장난삼아, 토끼 여깄다가-하자 여기저기서 웅성대다 보니 그게 그냥 토끼 사냥에 돼 버렸다. 상급반에서 정말 한 마디 72)풍겨 놓은 것이다.
그러나 73)스크럼이 허술한 74)몰이여서 그놈은 이내 포위망을 빠져 나가고 말았지만 어쩌다 이제 겨우 발발 기어다니는 새끼 한 마리를 붙잡았다. 토끼 새끼를 번쩍 쳐들어 둘러선 아이들에게 구경을 시킨 생물 선생은 싱글거리며 봄볕에 75)노곤히 지쳐 있는 이쪽에서 그것을 건네 주며, 잘 가지고 있어라-했다. 얼결에 새끼 토끼를 받아 든 이쪽은 생물 선생의 말을 들으면서 그만 76)헛구역질을 했다. 이놈을 생물 시간에 해부를 해 보이겠다는 것이었다. 해부를 한 다음에는요? 하고 어떤 녀석이 장난조로 묻자, 하 그건 너희들이 아직 잘 모를 테지만, 거 토끼고기가 뭐뭐에는 최고지-하는 생물 선생의 말을 받아 아이들은 합창하듯,
"토끼다리 술안주!" 했다.
"고오놈들."
과히 무서울 것 없는 호령이었다.
그러나 조막만한 토끼 새끼의 귀를 잡고 앉아 있는 이쪽은 요렇게 작은 걸- 내심으로 툴툴대며 자꾸 헛구역질을 했다. 토끼 새끼의 가슴팍에 손을 대어봤다. 파득파득 뛰고 있는 가슴팍에서 따스한 온기가 전해졌다.
이때 누군가, "저기 에미 토끼 온다아!" 소릴 쳤다. 정말 칡빛 토끼 한 마리가 이리로 곧장 구르다시피 달려 내려오고 있었다. "에미다, 에미! 야. 임마, 그 새낄 에미가 보두룩 번쩍 들어라. 번쩍…." 국어 선생이었다. 어미 토끼를 포위하기란 수월했다. 아이들이 와와 소리쳤다. 어미 토끼는 이리저리 핑핑 돌기만 했다. 그렇게 어쩔 줄 모르고 핑핑 돌기만 하던 어미 토끼가 갑자기 딱 멈춰 서며 이쪽의 번쩍 쳐들고 있는 '새끼 토끼를 노려보는 것이 아닌가. 이 당돌한 기세에 아이들도 주춤했다. 칡빛 어미 토끼의 77)쭈뼛 곤두선 두 귀와 까만 눈빛, 빛나는 눈알을 보자. 이쪽은 부르르 몸을 떨었다. 그러자 이때78)살기 차고 공포에 질린 표정으로 이쪽을 노려보던 그 어미 토끼가 씽하니 이쪽에게로 내달아오기 시작했다. 둘러섰던 아이들이 그제야 와와…소릴 쳤다. 새끼 토끼 역시 무어나 알기라도 한 듯 79)부들컹대며 끽끽거렸다. 이쪽은 어미 토끼의 눈에서 무엇인가 뻔쩍하는 걸 본 듯했다. 마치 불꽃 같은-순간, 새끼 토끼를 쳐들고 있던 이쪽은 그만 얼결에 비켜 서고 말았다. 그 틈이 난 사이로 토끼가 빠져 나가 산으로 치뛰고 있었다. 취뛰는 토끼를 쫓는 다는 건 무모한 것이었다. 모두들 악을 쓰다시피 이쪽에게 욕을 해 대고 있었다. 그러나 정작 이쪽은 멍하니 선 채로 치뛰는 어미 토끼를 바라보고 있을 뿐이었다. 토끼 새끼의 두 귀를 움켜쥔 손바닥에 땀이 배었음을 늦게야 깨달았다. 거, 인간이나 동물이나 모성애란 무섭거든-하고 입을 연 국어 선생님은 금세 입을 해-벌리며 "하, 그놈 꽤 크던걸, 그으거 참…." 이쪽에게 힐끔 80)눈살을 주면서였다.
"하아, 그럼 누군 입맛을 안 다시겠소? 그때 선생님께선 욕깨나 먹게 됐수다 뭐."
흠흠 웃으며 억구가 말했다. 그러자 자못 81)정색을 한 큰 키의 사내는,
"욕이 문젭니까? 그보다두 다음 생물 시간에 벌어질 일을 생각하니…."
하다간 그냥 겸연쩍게 웃어 버리고 말았다.


"그래, 다음날 고 조막만 한 토끼 새낄 해불 합디까? 고 고긴 술안줄 하구…?"
억구가 다시 흠흠 웃었다. 하자 큰 키의 사내는 보득솔을 붙잡고 끙끙 힘을 써 오르며,
"글세 그게…."
잠시 사이를 두었다가,
"그날 밤 꽤 피곤했지만 잠이 통 오질 않더군요. 그 어미 토끼의 도사리고 노려보던 눈, 그리고 배를 째이는 새끼 토끼의 환상이 자꾸…그예 난 생물 선생네 토끼장의 위치를 짐작하며 잠자리에서 빠져나오고야 말았습죠."
하자, 억구는 그 예의 82)조소 섞인 웃음을 흠흠 하며,
"하, 선생이 왜 일어났는가 내 알겠수다. 물론 그 새끼 토낄 구해 주셨겠구만. 그러구 보니 선생두 어렸을 적엔 어지간하게 시리 거 뭐랄까…."
그러나 큰 키의 사내는 그 말을 가로채,
"글세 그게 그렇게 되지가 못하구…."
하고 또 긴 말을 이을 기세를 보이자, 억구는 얼른 말미를 낚아,
"여하튼 선생 얘길 듣고 보니 난 사실 부끄럽습니다. 그럼 선생, 이번엔 내 얘길 한 번 들어 보실라우? 이렇게 눈이라두 푹 빠진 날이면 늘 생각이 납니다만 이놈은 원래 83)종자가 악종이었습니다."
아홉 살인가 그럴 때였다. 자기 집 앞 보리밭에서 눈을 뭉치고 있었다. 처음엔 주먹만하게 뭉쳐서 그것을 눈 위로 굴렸다. 주먹만하던 게 차츰차츰 커지기 시작했다. 아기 머리통만하게, 더 커지면서 물동이만하게, 억구는 자꾸 자꾸 굴렸다. 숨이 찼다. 장갑을 끼지 않은 손이 에듯 시렸지만 참았다. 꾹 참았다. 참아야만 했다. 뒤에 84)종종머리 계집애가 있었던 것이다. 눈덩이가 굴러 바닥이 드러난 곳에 푸릇푸릇 보리싹이 보였다. 그 드러난 자국을 쫓아 종종머리 예쁜 계집애가 따라오며 좋아라 손뼉을 치고 있었다. 마을 밤나무 숲에선 까치가 85)듣그럽게 울었다. 계집애 옆엔 강아지도 길길이 뛰며 따르고 있었다. 신이 난 억구는 자꾸자꾸 눈덩이를 굴렸다.
그러나 이게 웬일인가. 이미 한아름이 넘게 커진 눈덩이는 이제 바닥에서 뿌득뿌득 소리만 날 뿐 더 이상 움직이질 않았다. 눈덩이가 아홉 살짜리 힘에 부치게 컸던 것이다. 그러나 예쁜 종종머리 계집앤 자꾸 더 굴리란 것이다. 항아리만하게 86)낟가리만 하게, 산만큼 크게, 아주 아주 하늘땅만큼 크게 만들라는 것이다. 억구는 그만 울상이 됐다. 안달했다. 이젠 손이 시린 걸 더 참을 수가 없었다.
그러나 이때 종종머리 계집애가 저쪽을 손가락질했다. 득수란 놈이 이쪽으로 눈덩이를 굴려 오고 있지 않은가. 득수의 눈덩이가 점점 커지더니 잠시 후에 억구 것은 댈 것도 못 되었다. 종종머리 계집앤 문제없이 득수 편이 됐다. 강아지까지였다.
억구는 그만 눈물이 징 솟았다. 더 참을 수 없이 손이 시렸다. 드디어 억구 앞까지 눈덩이를 굴려 온 득수가 씩 웃으며 파란 바탕에 누란 무늬 수놓은 장갑을 낀 손으로 억구 눈덩이를 손가락질하며 "애걔, 쪼끄매…."했다.
덩달아 종종머리 예쁜 계집애도, "득수야, 쟤 거(나를 가리키는 그 계집애도 빨간87)벙어리장갑을 끼고 있었지요.) 하구 막 싸워 봐, 누구 게 이기나!" 하는 것이었다.


그러자 득의양양해서 자기 눈덩이를 억구 것에다 굴려 오는 득수,
억구는 자기가 만든 눈덩이가 두 쪽으로 갈라지는 걸 보았다. 그리고 계집애가 좋아라 손뼉치는 소리도 들었다.
"문득 깨닫고 나니 난 득수놈의 장갑을 입에 물고 있더란 말이오. 헌데, 입 안엔 분명 장갑뿐인 게 아니었쥬. 난 그걸 뱉는 것까지 잊어버린 채 그저 멍하니 서 있었지 뭡니까."
이때 눈 위에 벌렁 나자빠졌던 득수가 제 손등을 보더니 그제야 아악! 하고 비명을 질렀다. 그렇게 기겁을 한 득수가 갑자기 시뻘건 눈으로 (놈이 커서 죽을 때도 역시 꼭 그런 눈으로 날 노려봅데다.) 뿌르르 일어서더니 억구가 아직 물고 있는 장갑을 낚아챘다. 그제야 입 안 가득히 괸 것을 눈 위에 뱉었다. 눈이 새빨갛게 물들었다. 억구는 입 안에 괴어 든 피를 88)거푸 뱉어냈다. 손등의 살이 떨어져 나간 득수가 펄펄 뛰면서 울어 대는 걸 힐끔거리며 억구는 자꾸자꾸 침만 뱉었다.
"허나 이빨 사이에 끼인 그놈의 장갑 89)실오래긴 영 나오질 않습니다그려!"
하구, 억구는 걷기를 잠깐 멈추고 몇 번 퉤, 침을 뱉고 나서 다시 이야길 이었다. 볼이 얼어서 발음이 제대로 안 되는지 더듬거려,
"마침 그때 아버님은 안 계셨지만, 난 90)계모한테 붙들려 꼬박 이틀을, 꼭 이틀하구도 91)한나절을 92)광 속에 갇혀 지냈수다. 컴컴한 광 속에 가마니를 깔고 앉아 자꾸 침을 뱉었죠. 그러나 아무리 해도 그 득수놈의 장갑 실오래긴 어떻게 빼낼 수가 없습데다. 속에선 불이 펄펄 일구, 그 망할 광 속은 왜 그리 캄캄하고 추운지! 제기랄, 내 그때 벌써 감옥소란 데가 이렇겠저니 생각했댐 93)알조 아니우?"
억구는 말을 맺으며, 다시 눈 쌓인 고갯길을 오르고 있었다. 그의 양복은 온통 눈투성이였다. 바짓가랑이에선 여전이 데걱데걱 언 소리가 났다.
보득솔밭을 지나 꽤 큼직한 송림 사잇길이었다. 소나무 위에 얹혔던 눈이
쏴르르 떨어져 내렸다. 억구가 다시 이야길 이어 갔다.
"난 기어코 득술 죽이고야 만 겁니다. 거 왜, 94)사변 때 말입니다. 파리 새끼 쥑이듯 사람 막 쥑일 때 말이죠. 놈을 죽일 때 보니 그놈은 왼손에 장갑을 끼고 있더군요. 차마 그걸 벗겨 버릴 순 없었는데 95)울화통은 더 치밀더군요. 여하튼 난 득술 죽이고야 말았다.-이겁니다. 허나 그뿐인 줄 아슈? 육친을, 즉 제 애비까지 잡아먹은 게 바로 나요. 이 최억구라는 인간입네다."
결국 이용당했더란 것이다. 어릴 적부터 동네의 96)천더기로 따돌림당하던 자기를 빨갱이들이 용하게 이용했더란 것이다. 무슨 위원회 부위원장이니 하는 97)감투를 떠억 씌워서. 그래 결국 자기 부친까지 98)참사를 당하게 하고 만 것이었다.
늙은 부친과 함께 한방에서 자고 있었다. 계모는 이미 억구가 철들기 시작할 무렵 달아나 벼렸고, 그래 부친은 늘 억구에게 장가가길 원했던 것이다.
하지만 와야리에선 힘든 일일 수밖에.
억구는 눈을 멀뚱히 뜬 채 생각에 잠겨 있었다. 조금 전 소변 보러 밖에 나갔던 부친이 돌아모여 하던 말이 떠올랐다. 밖에 눈이 퍽 내렸다고, 올해의 눈 온 짐작으로 봐선 내년은 분명히 풍년일 게라고- 하던 부친이 이불을 뒤집어쓰며 푸욱 한숨을 내쉬었던 것이다. 그 깊은 한숨 소리에 억구는 그만 잠을 뺏기고 만 것이다. 자기 때문에 마을도 한 번 변변히 못 나가고 (그렇게 이 억구란 놈이 악종으로 날뛰었던 겁니다.) 방 안에서만 늘 풀이 죽어 있어야만 했던 부친의 한숨 소리에 자꾸 헛기침만 해 대던 억구였다.
그 밤, 부친은 99)죽창에 찔려 죽고, 어쩌다 자긴 이렇게 여기 살아 있다고 억구는 또 고개 오르기를 멈추며 조용히 한숨을 몰아쉬는 것이었다.


"우리 부자만 몰랐지. 동네에서들은 모두 국군이 머지않아 돌아온다는 걸 알고들 있었던 거죠. 결국 자기들 손으로 우릴 부잘 처치해 버리자는 생각들이었겠죠, 억구란 놈이 그렇게 죽어 마땅한 놈이었습네다."
그들이 고개 오르기를 잠시 쉬는 동안도 산속의 소나무 위에 얹혔던 눈은 제 무게가 겨운지 쏴르르 쏟아져 내리곤 했다.
"그날 밤, 난 집을 빠져 나와 뒷산으로 치뛰며 아버님의 비명을 들었수다.
득수 동생놈이 잡았다.! 하고 소릴 치더군요. 잡았다, 하고 말입네다. 그래 두 이놈은 살겠다고 100)정갱이까지 빠져드는 눈길을 맨발로 달아나구 있었죠."
그는 카악 가래침을 돋워 입 안에 꿀럭거리며,
"그러니까 그때 와야릴 떠나군 이번이 처음 가는 겁네다. 십 년이 넘는 오늘에야 아버님을 찾아가는 겁니다. 비록 무덤이지만…."
퉤-가래침을 뱉어 버리고 다시 고개를 허우적허우적 오르기 시작했다. 큰 키의 사내는 이제 눈길을 걷기에 지칠 대로 지친 듯 헉헉 숨을 몰아쉬곤 했다. 그러나 억구의 얘기에 흠뻑 끌리고 있는 투였다.
드디어 우중충 흐렸던 하늘이 눈을 내리기 시작했다. 세상의 모든 것을 덮어 버리며, 그리고 순화시키는 그런 위력을 가진, 그리고 못 견딜 추억 같은걸 뿌리면서 눈이 내렸다. 바람결에 101)눈발이 비끼고 있었다. 송림이 웅웅 적막한 음향을 냈다.
"그럼, 노형은 이제 와야리 사람들을 만날 생각이십니까?"
큰 키의 사내가 좀 가파른 눈길을 엉금엉금 기어오르며 숨가쁘게 말했다. 하자, 옆에서 기어오르던 억구가 주춤 멈추며 뒤를 향해,
"와야리 사람들을 만나겠느냐구요? 분명 선생이 그렇게 말씀하셨것다?만나겠느나구-흥, 만-나-겠-느냐구!"
억구는 거푸 되뇌며, 마치 얼빠진 사람처럼 웅얼거렸다. 그러다가 느닷없이 102)발끈 내질렀다.
"선생, 그래 내가 그 사람들을 만나지 못할 건 뭐야? 난 와야리서 낳구, 거기서 뼈가 굵었구, 가친이 게서 돌아가시구, 게다가 나두 사람인데 내가 왜 그 사람들을 못 만난단 말이우?"
이처럼 격하게 내쏟는 것이었다.
그러나 다시 푹 사그라진 어조로,
"난 어제두 와야리놈을 하나 만났수다. 춘천에서 말이오. 바루 내가 죽인거나 진배없는 그 득수놈의 동생을 만났다 이겁니다. 놈이 날 보자마자, 형님, 이거 반가워유…하지 않겠소. 사실 나도 처음엔 왈칵 반갑습데다. 놈을 술집으로 끌구 갔죠. 우린 과거 얘긴 될 수 있는 한 피했죠. 하난 술이 얼근해지자, 난 떠억 물어 본 겁니다. 그래 자넨 우리 아버질 분명 잡알겠다? 그런데 그 잡은 걸 어데다 묻었나? 하고 말이죠. 허니까 그 녀석 술이 확 깨는지, 그래두 놈은 내 말을 풀어 볼 양으로 고분고분한 말투로, 우리 103)선대조 산소에 모셨노라구, 그리고 104)벌초까지 제가 매년 해왔다는 겁니다. 우선 놈의 얘기가 고맙더군요."
신음하듯 말미를 흐렸다.


"네에! 득수라는 사람 동생을 어제 만나셨다구요? 그 김득칠일…." 그러자 억구는 후딱 놀란 듯,
"예, 어제 분명 그놈을 만났지요. 그런데 선생이 어떻게 그놈 이름을 아슈?알길…."
조급스레 다긏는 것이었다.
"김득칠이가 맞죠? 서른셋, 직업은 면서기죠. 김득칠인 어제 근화동서 살해됐습니다."
큰 키의 사내가 차분한 어조로 말했다.
어제 억구가 휙 몸을 돌리며,
"나도 알구 있소. 득칠이가 소주병에 대가릴 맞아 죽은 걸 나도 알고 있단 말이오.그런데 지금 선생은 꼭 내가 득칠일 죽인 범인이라두 되는 것처럼 생각하시는 본데, 자, 선생, 내가 득칠일 죽였단 말이오?"
한 마리 곰처럼 도사려 앉아 밑의 사내를 노려봤다.
큰 키의 사내는 오른손을 오보 주머니에 찌른 채 두어 걸음 밑으로 물러서며 억구를 쳐다봤다.
이미 그들은 거의 고갯마루턱까지 올라와 있었다. 한동안 그들은 서로 마주 본 채 움직이지 않았다. 큰 키의 사내의 오른손은 아직 오버 주머니에 꾹 찔러 있었고 억구는 머리부터 온통 눈을 뒤집어쓰고 있었다. 눈은 자꾸 비껴 내렸다.
이윽고 큰 키의 사내가 오른쪽 손을 오버 주머니에서 빼며 모자를 벗었다. 모자에 하옇게 내려앉은 눈을 털면서 입을 열었다.
"공연한 오해를 하고 있는 것 같습니다그려. 제가 왜, 어제 근화동에서 그 현장을 우연히 봤다지 않습니까? 형사들은 죽은 사람의 증명서를 뒤지며 김득칠이니 뭐니 하길래…또 노형이 어제 만났다는 분이 그 죽은 사람 같아서 한 번 그래 본 것뿐입니다. …자, 그런데 이거 눈이 너무 오십니다그려…."
그러자 억구는 아무런 대꾸 없이 몸을 일으켜 걸음을 옮기기 시작했다.
이제 그들은 바람을 안고 내리막 눈길을 걷고 있었다. 걷는다기보다는 미끄러져 내려가고 있는 형편이었다. 그러나 앞선 것은 여전히 억구였다.
눈 덮인 송림이 웅웅 울고 있었다.
가끔 소나무 위에 얹혔던 눈무더기가 쏴르르 쏟아져 내렸다. 부쩍 언 억구의 바짓가랑이는 연해 데걱거렸고.
"그래, 노형은 그동안 어떻게 지내셨습니까? 그날 밤 와야릴 떠난 후에 말입니다."
큰 키의 사내가 물었다.
"진작 물으실 줄 알았는데…, 결국 선생이 궁금한 건 사람을 죽인 놈이, 제 애비까지 죽인 빨갱이가 그동안 그 대가를 치렀느냐 이거죠? 즉 이 최억구란 놈이 형무소에서라두 도망쳐 오는 게 아니냔 그 말씀이죠?
하며 억구는 또 그 예이 흠흠 조소 섞이니 웃음을 웃었다.
그렇게 웃던 억구가 풀썩 미끄러져 주저앉았다. 주저앉는가 하자 어느새 굴러 내리기 시작했다. 순간 큰 키의 사내는 긴장하면서 오른손을 오버 주머니에 넣었다. 역시 그도 몇 걸음 미끄러져 내리며,
"여보!"
외쳤다.
그러나 서너 바퀴 굴러 내린 억구는 온통 눈에 묻혀 버린 채 꼼짝도 안 했다. 큰 키의 사내는 오른쪽 손을 주머니에 넣은 채 어쩔까 망설이는 표정으로 서 있기만 했다.
눈발은 더욱 세게 비껴 내리고.
이윽고 눈 속에 엎어져 있던 억구가 105)엉기엉기 길을 찾아 오르며 띄엄띄엄 중얼거렸다.
"하긴 나두 처음엔 몇 번이고 자수할 생각이었죠. 그러나 결국 난 자술 못하고 만 거죠. 난 그 광 속을 잊을 수가 없었던 거요. 그 광 속에서 이틀 동안이나 이빨 사이에 박힌 장갑 실오래길 빼려구 내가 얼마나 애를 썼는지 아슈? 침이 묻은 손은 자꾸 얼어들구, 실이 낀 잇몸의 살이 떨어져 피까지 나왔지만 난 그 장갑 실오래긴 아무래도 뺄 수가 없었던 거요. 예, 늘 생각을 한 거죠. 난 그 106)육실하게 춥구 캄캄한 광 속에선 실오래길 죽어두 빼낼 수가 없었다…이겁네다."
그는 흡사 술 취한 사람처럼 떠벌리며 기어올랐다.
큰 키의 사내는 얼마간 경계하는 몸짓을 하면서 그를 부축해 끌어올리고 있었다.
다 기어 올라온 억구는 눈 같은 건 털려고도 않은 채 우선 양복 윗주머니의 불룩한 곳을 더듬어 보는 것이었다.
그리고 다시 앞을 서서 고개를 내려가기 시작했다. 107)넋두리하듯 지껄여 대며,
"보시우, 선생. 징역이니 사형이니 어쩌구 하는 것에다 제 죄를 전부 뒤집어씌워 놓곤 자긴 떠억 시치밀 뗄 수가 있다고 생각하시우? 어쩜 그게 가능할지도 모르죠. 허나 이놈에겐 그 춥구 캄캄한 광 속의 기억이 있는한 …여하튼 산다는 게 무서웠습니다. 선생, 좀 어쭙잖은 말 같습니다만 늘 생각해 왔습네다. 내 운명이라는 게 가혹하지 않으냐 하는 생각 말입네다. 미련하구 무식한 나지만 난 분명 알구 있었지요. 이건 분명 사람으로 태어나서 사람처럼 살아 보질 못했다는 사실 말입니다. 우선 난 잠을 잃어 버렸던 겁니다. 사람이 잠을 못 잔다는 건 마지막이 아닙니까? 그건 그렇다구 하더라두 이 최억구 놈 세상만사에 재밀 몰랐던 거요. 모든 게 나와는 거리가 멀구 하루하루 사는 게 그저 고역이었습네다. 이렇게 서른여섯 해를 살아온 납네다. 그래 놓으니 이 철저한 악종두, 이건 너무 억울하지 않으냐…하는 생각이 미치는 게 아니겠소…."
눈발은 여전히 108)푸슴푸슴 비껴 내리고 있었다. 눈이 하얗게 뒤집어쓴 채 내리막 눈길을 걷는 억구의 바짓가랑이가 데걱거리고 있었다. 송림이 웅웅 울며 나뭇가지 위에 쌓였던 눈이 다시금 쏴르르 쏟아져 내렸다.


이때, 앞서서 내려가던 억구가 아까처럼 쭈르르 미끄러져 두어 바퀴 굴러내렸다. 하자, 큰 키의 사내는 재빨리 오버 주머니에 손을 넣으려다 짐짓 긴장을 풀며 오버 깃을 추켜올렸다. 굴러 내린 억구가 이번엔 곧 일어나 걸으며 여전히 넋두릴 해 대고 있었다.
"내 어느 날 창녈 하나 찾아가질 않았겠소. 선생 같은 분네한텐 부끄럽수만 난 돈푼이라두 생기면 그런 데라두 가지 않군 못 견뎠습네다. 어쨌든 끌어안고 보면 제아무리 부처님이라도 열중해 버리고 말거든요. 그렇게 무엇에고 열중할 수 있다는 게 이놈에겐 여간 대견한 일이 아니었수다. 암 대견했죠. 그런데 어쩌다 그날 내게 걸려든 계집이라는 게 이건 정말 주물러 잡아 뺀 상판입데다. 109)눈칫밥만 사흘에 얻은 손님이라구 그 계집입이 함박만하게 벌어지더군요. 아무리 못났대두 끼구 누웠으려니 사람의 정이란 묘해서 이런저런 얘길 주고받았죠. 얘기래야 그 잘나빠진 계집의 110)신파 같은 신세 타령이었소만… 헌데, 내애 차암, 어어없어서. 글쎄 그 계집애가 갑자기 쿨쩍쿨쩍 울더란 말이오. 그렇게 쿨쩍거리며 울던 계집이 어번엔 또 111)천연덕스럽게 한다는 소리가 제 운명을 탓해서 우는 건 아니라구요, 기뻐서, 가슴이 벅차서 운다는 겁니다. 그게 무슨 소린고 하니 자기가 지금 이렇게 천댈 받고 살지만, 그게 도무지 억울하지가 않다나요. 억울할 게 뭐라는고 하니, 자긴 죽었다가 다시 이 세상에 태아난다나요. 그건 틀림이 없다구요. 그땐 지금112)괄셀 받고 산 그 만큼 잘 살아 보겠다는 겁니다. 그건 틀림이 없다나요. 자기 머릿속에 꽉 차 있는 건, 다시 태어나면 그땐 어떻게 살아 보겠다는 계획뿐이랍니다. '국회 의원 외딸루 태어날지도 몰라요. 아버진 귀가 큰데다가 얼굴이 잘생기구 또 기맥히게 인자하시지 뭐예요. 이렇게 눈에 선한걸요. 학교에 갈 땐 아버지 차로 가겠어요. 사내 동생 하나가 또 있음 좋겠어요. 걘 말 아니게 개구쟁이라니까요. 그래두 날 얼마나 따른다구요. 그 앤 영화 배울 만들었으면 좋겠는데….' 이렇게 꿈 같은 소릴 하길래 내 말이 113)오뉴월 쇠불알 떨어지길 기다리지 왜…했더니 그 계집 정색을 하는덴 내 그만 손들었수다. 그렇지 못하다면 지금 자기가 왜 이 고생을 하며 살겠느냔 겁니다. 안 그래요, 손님? 하지 뭐요. 제에기랄, 계집이 미쳐두…."
억구는 이제 흡사 한 마리 흰 곰이 돼 있었다. 언 바짓가랑이가 걸음을 옮길 적마다 요란스레 데걱거렸다.


큰 키의 사내는 억구의 떠벌리는 말을 들으며 좀체로 입을 열지 않고 있었다. 그의 모자와 오버에도 온통 하얗게 눈이 내려앉아 있었다. 그는 가끔 터져 나오려는 기침을 큿큿 참는 것이었다.
"그 창년 다음 세상에서 잘 살아 보길 원하고 있었지만 난 그게 아니었수다. 보다는 이왕 이 세상에 나온 이상 한 번 태어난 값이나 해 보자, 한번쯤은 인간답게 살아 보구 싶었던 겁니다. 아마 나처럼 살려구, 그놈의 구렁텅이에서 벗어나려구 끈덕지게 버둥거린 놈두 드물겁니다. 하지만, 선생, 그 보답이 뭔지 아시우?"
마치 시비라도 걸 듯한 기세였다가 곧 수그러진 어조로 말했다.
"자, 이제 됐수다. 여기가 바로 큰길입니다."
걸음을 멈춘 억구는 엉거주춤 소변을 봤다. 그의 말대로 그들은 이미 그 험한 구듬치고개 눈길을 다 넘어 큰길에 다다라 있었던 것이다.
큰길에 이르고서부터 그들은 서로 나란히 서서 걸었다. 두 사내의 발이 터벌터벌 발목까지 빠지는 눈길 위에 점을 찍어 나가고 있었다.
먼저보다 바람기가 스러지면서 눈발은 이제 조용한 흩날림으로 변하고 있었다.
옆 산 소나무 위에 얹혔던 눈무더기가 쏴르르 쏟아져 내렸다. 마치 자기 무게를 그렇게 나약한 소나무가지 위에선 더 이상 지탱할 수 없다는 듯이…그때 먼 곳에서 뚝 우지끈 소나무가지 부러져 내리는 소리가 들려왔다.
그러자 이때 억구가 느닷없이 키 큰 사내의 앞을 막아 서며,
"선생, 난 득수 동생놈을, 그 김득칠일 어제 죽였단 말이오, 이렇게 온통 눈이 내리는데 그까짓 걸 숨겨 뭘 하겠소. 선생은 아주 추악한, 사람을 몇씩이나 죽인 무서운 놈과 함께 서 있는 거유. 자, 날 어떻게 하겠수?"
그러면서 한 걸음 큰 키의 사내 앞으로 다가섰다.
큰 키의 사내는 후딱 몇 걸음 물러서며 오버 주머니에 오른손을 잽싸게 넣었다.
그의 시선은 억구가 양복 윗주머니의 불룩한 것을 움켜쥐고 있는 것에 머물러 있었다.
"아까두 말했지만, 그 술집에서 난 놈에게 114)이주걱됐죠. 그래 자넨 분명 우리 아버질 잡았것다? 그래 벌초를 매년 해 왔다구? 아 고마워, 고마워…하고 말입네다. 헌데 그 득칠일 난 그날 밤 죽이고야 만것입니다. 글쎄, 나두 그걸 모르겠수다. 왜 내가 그 득칠일 죽였는지…."
여직 들어 보지 못한 맥빠진, 그렇게 풀이 죽은 목소리로 말했다.
그러나 큰 키의 사내는 묵묵히 억구의 얼굴을 뜯어보고만 있었다.
이윽고 억구가 큰 키의 사내 앞에서 몸을 돌림 저쪽 산등성이를 가리켜 보였다.
"바루 저 산에 가친 산소가 있답니다. 우리 조부님 산소 옆이라는군요. 난 지금거길 가는 겁니다. 가서 우선 무덤의 눈을 쳐드려야죠. 그리구 술을 한잔 올릴랍니다. 술을 올리면서 가친의 음성을 들을 겁니다. 올해두 눈이 퍽 내렸구나. 눈 온 짐작으루 봐선 내년두 분명 풍년이갰다만…하실 겁니다. 그리고 푹 한숨을 몰아쉬시겠죠. 그 한숨 소리 들으면서 가친 옆에 누워야죠. 이젠 가친을 혼자 버려 두고 달아나진 않을 겁니다."
그는 산으로 향한 115)생눈길을 몇 걸음 걷다가 다시 이쪽을 향해,
"참, 바루 저기 보이는 저 모퉁일 돌아감 거기가 바로 와야립니다. 가셔서 우선 구장네 집을 찾아 몸을 녹이시우. 뜨끈뜨끈한 아랫목에 푹 몸을 녹이셔, 자, 그럼 난…."
산을 향해 생눈길을 걷어가는 가의 언 바짓가랑이가 서걱서걱 요란한 소리를 냈다.


어깨를 잔뜩 구부리고 흡사 한 마리 흰 곰처럼 산을 향해 걷는 억구의 을씨년스럽고 초라한 뒷모습에 눈을 주고 선 큰 키의 사내는 한참이나 그렇게 묵묵히 섰다가 문득 큰길 아래로 내려서서 억구 쪽으로 따라가며,
"노-형, 잠깐!"
말소리 속에 강인한 무엇인가가 깔려 있는 듯싶었다.
언 바짓가랑이를 데걱거리며 걸어가던 억구가 주춤 멈춰서 이쪽으로 몸을 돌렸다. 큰 키의 사내가 성큼성큼 다가갔다. 오버 안주머니에 손을 넣어 무엇인가 움켜쥔 그런 자세였다.
억구가 짐짓 몸을 추스르며 자기에게로 다가서는 큰 키의 사내 거동을 바라보고만 있었다.
억구 앞에 멈춰 선 큰 키의 사내가 할 말을 잊은 듯 멍청하니 고개를 위로 향했다. 고개를 약간 젖히고 입을 헤-벌린 채, 그의 이러한 생각하는 표정위에 눈이 내려 앉고 있었다.
-그날 밤 난 생물 선생네 담을 빙빙 돌고만 있었지. 내 키보다두 낮은 담이었어. 난 거푸 담을 돌고만 있었지. 만약 내가 담을 넘어 들어간다면…그러나 난 담을 넘어서는 안된다고 생각했다. 담이란 남이 들어오지 말라고 만들어 놓은 거니까. 들어오지 말라는 걸 들어가면 그건 나쁜 짓이니까, 그건 도둑놈이지. 난 나쁜 놈이 되는 건 싫었으니까. 무서웠던 거야. 나는 담만 돌며 생각했지. 오늘 갑자기 생물 선생넨 무서운 개를 얻어다 놓았을지도 모른다고. 또 어쩌면 선생이 설사 나서 변소에 웅크려 앉았을지도 모른다는 지레 경계를…그리고 남의 담을 넘는다는 건 분명 나쁜 짓이라고…무서웠던 거야. 결국, 난 새끼 토낄 구할 생각을 거두고 담만 돌다 돌아오고 말았지.
"아니 선생, 남을 불러 놓군 왜 그렇게 하늘만 쳐다보슈?"
억구가 말했다.
-나쁜 놈이 되기가 싫었던 거야. 담을 넘는다는 건….
큰 키의 사내가 한 걸음 물러섰다. 생각하는 표정을 거두지 못한 채.
산속 소나무 위에서 다시 눈무더기가 쏴르르 쏟아져 내렸다. 마치 그 연약한 나뭇가지 위에선, 그리고 거푸 내려 쌓이고 있는 눈의 무게를 더 이상 지탱할 수 없다는 듯.
억구가 다시 다그쳤다.
"선생, 발이 시립니다. 내가 여기 얼어붙어야 좋겠소? 원 별 양반도…자, 그럼…."
억구가 다시 몸을 돌려 산을 행했다. 그가 몸을 돌리는 순간 그의 깡똥한 양복 윗주머니에 삐죽하니 2홉들이 소주병 노란 덮개가 드러나 보였다.
순간 망설이던 큰 키의 사내 얼굴에 어떤 결의의 빛이 스쳤다.
"아, 노형, 잠깐!"
억구가 바짓가랑이를 데걱거리며 다시 몸을 돌렸다. 순간 큰 키의 사내는 오른쪽 오버 주머니에서 서서히 손을 뺐다. 그리고 무엇인가 불쑥 억구 앞으로 내밀었다.
-나는 담만 돌았지. 무서웠던 거야.
"이걸 나한테 주시는 겁니까?"
억구가 물었다.
"예, 드리는 겁니다. 아까 두 개비를 피웠으니까 꼭 열여덟 개비가 남아 있을 겁니다. 눈이 이렇게 많이 왔으니 올핸 담배도 풍년이겠죠. 그러나 제가 지금 드린 담배는 하루에 꼭 한 개씩만 피우셔야 합니다."
큰 키의 사내 얼굴에 엷은 미소가 번지고 있었다.
그리고 그는 담배 한 갑을 받아 든 채 멍청히 서 있는 억구에게서 몸을 돌려 마치 눈에 흘린 사람처럼 116)비척비척 큰길을 향해 걸어가고 있었다.


잔기침을 몇 번 큿큿 하면서.
걸어가는 그의 등 뒤로 마치 울음 같은 억구의 외침이 따랐다.
"하루에 꼭 한 개씩 피우라구요? 꼭, 한 개씩, 피, 우, 라, 구요?"
그러면서 그는 느닷없이 웃음을 터뜨리는 것이었다.
ㅎ ㅎ ㅎ ㅎ ㅎ ㅎ ㅎ….
눈 덥인 산속, 아직 눈이 조용히 비껴 내리고 있는 밤이었다.`;

            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="nextStage()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
        const writingQuestions = [
    {
        id: 1,
        question: "이 소설은 '여로 구조'를 통해 이야기가 전개된다. '눈길을 함께 걷는 과정'이 두 인물의 관계 변화에 어떤 영향을 미쳤는지 서술하시오.",
        questionType: "형식/구조 파악",
        correctAnswer: "처음 '형사'와 '범인'이라는 적대적 관계로 시작된 두 인물은 '눈길'이라는 험난한 여정을 함께 겪으며 점차 서로의 인간적인 면모를 발견하게 된다. 특히 억구가 자신의 불행한 과거를 고백하고, 형사가 그의 이야기에 귀를 기울이는 과정 속에서 단순한 추격자와 도망자의 관계를 넘어선다. 고난의 길을 함께 걷는 '동행'의 과정은 두 사람 사이에 심리적 유대를 형성하게 하고, 결국 형사가 억구의 처지를 이해하고 인간적인 연민을 느끼게 되는 계기로 작용하여, 법을 넘어선 인도주의적 결말을 이끌어내는 중요한 역할을 한다.",
        scoringCriteria: "① 초기 적대적 관계 언급, ② 험난한 여정을 통한 심리적 유대 형성, ③ 관계 변화(연민, 이해)를 서술.",
        correctParts: [
            "처음 '형사'와 '범인'이라는 적대적 관계로 시작된 두 인물은 '눈길'이라는 험난한 여정을 함께 겪으며 점차 서로의 인간적인 면모를 발견하게 된다.",
            "특히 억구가 자신의 불행한 과거를 고백하고, 형사가 그의 이야기에 귀를 기울이는 과정 속에서 단순한 추격자와 도망자의 관계를 넘어선다.",
            "고난의 길을 함께 걷는 '동행'의 과정은 두 사람 사이에 심리적 유대를 형성하게 하고, 결국 형사가 억구의 처지를 이해하고 인간적인 연민을 느끼게 되는 계기로 작용하여, 법을 넘어선 인도주의적 결말을 이끌어내는 중요한 역할을 한다."
        ],
        distractors: ["두 인물은 눈길을 함께 겪으며 최소한의 공감대를 마련하지만, 관계의 축은 끝까지 공권력과 피의자의 긴장으로 수렴한다. 동행은 충돌을 늦출 뿐, 방향을 바꾸지는 못한 채 법적 절차의 재개로 이어진다.", "험로의 경험이 대화의 물꼬를 트지만, 서로의 내면을 더 깊게 여는 대신 각자의 입장 정리가 선명해진다. 억구는 생존의 논리를 단단히 하고, 형사는 원칙을 재확인하며 결말의 균열을 봉합한다.", "눈길은 협력의 장면을 간헐적으로 만들지만, 그 호흡이 신뢰로 고정되지는 않는다. 때맞춰 드러난 과거 서사가 감정의 파문을 일으키되, 최종 선택은 제도적 한계 안으로 복귀한다."]
    },
    {
        id: 2,
        question: "'억구'가 겪은 두 가지 핵심적인 과거의 상처(어린 시절 득수와의 일, 전쟁 중 아버지의 죽음)가 그에게 어떤 영향을 미쳤으며, 이것이 '득칠'을 살해하게 된 것과 어떻게 연결되는지 서술하시오.",
        questionType: "내용형 / 인과 파악",
        correctAnswer: "어린 시절 '득수'에게 당한 모멸감과 그로 인해 광에 갇혔던 경험은 억구에게 깊은 열등감과 폭력성을 내재시켰다. 또한, 한국 전쟁 중 이념 대립으로 인해 아버지마저 억울하게 잃게 되면서 그는 세상과 타인에 대한 깊은 불신과 분노를 갖게 되었다. 이러한 과거의 상처들이 응어리져 있던 상태에서, 득수의 동생인 '득칠'을 만나 술을 마시던 중 과거의 아픈 기억이 자극되면서 억눌려 있던 분노가 우발적으로 폭발하여 살인이라는 비극적인 결과로 이어진 것이다.",
        scoringCriteria: "① 어린 시절의 상처(열등감, 폭력성), ② 전쟁의 상처(불신, 분노), ③ 두 상처가 득칠의 살해로 이어지는 인과 관계를 서술.",
        correctParts: [
            "어린 시절 '득수'에게 당한 모멸감과 그로 인해 광에 갇혔던 경험은 억구에게 깊은 열등감과 폭력성을 내재시켰다.",
            "또한, 한국 전쟁 중 이념 대립으로 인해 아버지마저 억울하게 잃게 되면서 그는 세상과 타인에 대한 깊은 불신과 분노를 갖게 되었다.",
            "이러한 과거의 상처들이 응어리져 있던 상태에서, 득수의 동생인 '득칠'을 만나 술을 마시던 중 과거의 아픈 기억이 자극되면서 억눌려 있던 분노가 우발적으로 폭발하여 살인이라는 비극적인 결과로 이어진 것이다."
        ],
        distractors: ["어린 시절의 모멸은 성격의 거친 면을 드러내게 했고, 전쟁의 경험은 감정을 둔탁하게 만들었다. 그러나 현재의 사건은 우연한 충돌이 확대된 결과에 가깝고, 장기적 원한의 폭발과는 결이 다르다.", "득수와 얽힌 기억은 자의식의 균열을 남겼고, 아버지 사건은 세계관을 차갑게 굳혔다. 다만 술자리의 파국은 즉흥적 자극 속에서 진행되어, 과거의 축적이 직접적 방아쇠가 되었다고 보긴 어렵다.", "모멸과 상실은 억구를 방어적으로 만들었고, 타인 회피로 굳어지게 했다. 득칠과의 마찰은 그 방어의 실패에서 비롯되며, 계획성보다 미성숙한 충동 조절의 균열이 더 큰 변인이 된다."]
    },
    {
        id: 3,
        question: "형사는 자신의 과거 경험인 '토끼 이야기'를 떠올린다. 이 이야기가 형사의 내적 갈등을 어떻게 심화시키고, 최종적인 선택에 어떤 영향을 주었는지 서술하시오.",
        questionType: "내용/해석형",
        correctAnswer: "형사는 과거에 '나쁜 짓'이라는 두려움 때문에 위험에 처한 새끼 토끼를 구해주지 못했던 자신의 소심함과 비겁함을 자책하고 있다. 그는 억구의 불행한 삶의 이야기를 들으며 그에게 연민을 느끼지만, 동시에 범인을 체포해야 하는 법 집행관으로서의 임무 사이에서 갈등한다. 이때 '토끼 이야기'는 억구의 처지와 겹쳐지며, 만약 여기서도 법이라는 '담'을 넘지 못하고 억구를 외면한다면 과거의 자신처럼 또다시 비겁한 방관자가 되는 것이라는 죄책감을 심화시킨다. 결국 그는 과거의 잘못을 반복하지 않기 위해, 법적 임무를 유예하고 억구에게 인간적인 연민을 베푸는 선택을 하게 된다.",
        scoringCriteria: "① '토끼 이야기'의 내용(자신의 비겁함에 대한 자책) 요약, ② 형사의 내적 갈등(임무 vs 연민) 심화 과정 서술, ③ 과거의 잘못을 반복하지 않기 위해 인도주의적 선택을 하게 됨을 서술.",
        correctParts: [
            "형사는 과거에 '나쁜 짓'이라는 두려움 때문에 위험에 처한 새끼 토끼를 구해주지 못했던 자신의 소심함과 비겁함을 자책하고 있다.",
            "그는 억구의 불행한 삶의 이야기를 들으며 그에게 연민을 느끼지만, 동시에 범인을 체포해야 하는 법 집행관으로서의 임무 사이에서 갈등한다.",
            "이때 '토끼 이야기'는 억구의 처지와 겹쳐지며, 만약 여기서도 법이라는 '담'을 넘지 못하고 억구를 외면한다면 과거의 자신처럼 또다시 비겁한 방관자가 되는 것이라는 죄책감을 심화시킨다. 결국 그는 과거의 잘못을 반복하지 않기 위해, 법적 임무를 유예하고 억구에게 인간적인 연민을 베푸는 선택을 하게 된다."
        ],
        distractors: ["형사는 토끼 일화를 떠올리며 감정의 폭을 조절한다. 지나친 연민이나 과도한 엄정으로 기울지 않도록 스스로를 단련하고, 최종 선택은 규범과 정서의 균형점에서 현실적으로 결론난다.", "과거의 망설임은 직무 수행의 신중함으로 전화된다. 형사는 사건의 전모를 끝까지 확인하려는 태도를 견지하고, 감정적 개입은 통제한 채 결과의 책임을 감내하는 방식으로 마무리한다.", "토끼 이야기는 판단의 속도를 늦추는 장치가 된다. 그는 절차와 사실 검증을 우선해 돌이킬 수 없는 결정을 유보하고, 이후의 처리에서 제도적 보호와 개인적 배려를 분리해 적용한다."]
    },
    {
        id: 4,
        question: "<보기>를 참고하여, 이 소설에서 '눈'이 어떤 복합적인 의미로 사용되었는지 구체적인 장면과 연결하여 서술하시오.\n\n< 보 기 >\n문학 작품에서 '눈'은 다양한 상징적 의미를 지닌다. 차갑고 혹독한 '시련'을 의미하기도 하고, 모든 것을 하얗게 덮어버리는 '정화'나 '화해'를 상징하기도 하며, 때로는 순수함을 의미하기도 한다.",
        questionType: "<보기> 적용형",
        correctAnswer: "이 소설에서 '눈'은 복합적인 의미를 지닌다. 첫째, 두 인물이 발목까지 빠져들며 힘겹게 걸어야 하는 '눈길'은 그들이 겪는 '시련과 고난'의 현실을 상징한다. 둘째, 소설의 마지막에 모든 것을 하얗게 덮으며 내리는 눈은 억구의 죄와 상처를 감싸주고 정화하며, 형사가 그를 인간적으로 용서하는 '화해와 구원'의 분위기를 조성한다. 이처럼 '눈'은 혹독한 현실인 동시에, 그 현실을 끌어안고 치유하는 이중적인 의미로 사용된다.",
        scoringCriteria: "① 시련과 고난의 의미, ② 정화와 화해(구원)의 의미를 각각 작품 속 상황과 연결하여 서술.",
        correctParts: [
            "이 소설에서 '눈'은 복합적인 의미를 지닌다. 첫째, 두 인물이 발목까지 빠져들며 힘겹게 걸어야 하는 '눈길'은 그들이 겪는 '시련과 고난'의 현실을 상징한다.",
            "둘째, 소설의 마지막에 모든 것을 하얗게 덮으며 내리는 눈은 억구의 죄와 상처를 감싸주고 정화하며, 형사가 그를 인간적으로 용서하는 '화해와 구원'의 분위기를 조성한다.",
            "이처럼 '눈'은 혹독한 현실인 동시에, 그 현실을 끌어안고 치유하는 이중적인 의미로 사용된다."
        ],
        distractors: ["눈길은 인물들의 걸음을 무겁게 만들고, 말끝마다 쉬이 멈칫하게 한다. 말미의 눈발은 소음을 낮추어 사태를 응시하게 하고, 충동의 열기를 차분히 식히는 배경으로 기능한다.", "눈은 사건의 온도를 낮추며 시야를 일정하게 흐린다. 인물의 선택은 더디게 숙성되고, 마지막 장면의 백색감은 결론의 날을 무디게 하여 각자의 숙연함을 남긴다.", "두 인물은 눈의 냉기에 보폭을 맞추며 호흡을 고른다. 축적된 피로가 말수를 줄이고, 침묵의 질감이 관계의 구획을 정리해 이후의 정돈된 선택을 가능하게 한다."]
    },
    {
        id: 5,
        question: "'억구'는 형사에게 자신의 과거를 장황하게 털어놓는다. 억구가 이러한 행동을 하는 심리적 의도를 두 가지 이상 서술하시오.",
        questionType: "내용/해석형",
        correctAnswer: "첫째, 자신의 범죄가 단순히 악한 본성 때문이 아니라, 어린 시절부터 겪어온 불행한 과거와 사회적 모순 때문에 어쩔 수 없이 벌어진 일임을 항변하고 자신의 죄를 정당화하려는 의도가 있다. 둘째, 동행하는 남자가 자신을 쫓는 형사일지도 모른다고 의심하며, 자신의 이야기를 통해 상대방의 반응을 살피고 정체를 떠보려는 의도가 있다. 셋째, 자신의 억울함과 고통을 누군가에게 털어놓고 이해와 위로를 받고 싶은 절박한 심리가 담겨 있다.",
        scoringCriteria: "① 자기 정당화/변명, ② 상대방의 정체 탐색, ③ 이해와 위로에 대한 갈망 중 두 가지 이상을 타당하게 서술.",
        correctParts: [
            "첫째, 자신의 범죄가 단순히 악한 본성 때문이 아니라, 어린 시절부터 겪어온 불행한 과거와 사회적 모순 때문에 어쩔 수 없이 벌어진 일임을 항변하고 자신의 죄를 정당화하려는 의도가 있다.",
            "둘째, 동행하는 남자가 자신을 쫓는 형사일지도 모른다고 의심하며, 자신의 이야기를 통해 상대방의 반응을 살피고 정체를 떠보려는 의도가 있다.",
            "셋째, 자신의 억울함과 고통을 누군가에게 털어놓고 이해와 위로를 받고 싶은 절박한 심리가 담겨 있다."
        ],
        distractors: ["그는 과거의 연쇄를 앞세워 현재의 자신을 설명하려 한다. 이야기를 길게 풀어 상대의 반응을 가늠하고, 이해를 이끌 실마리를 찾아가며 대화의 주도권을 서서히 확보하려는 계산이 깔려 있다.", "장황한 진술은 감정의 압력을 낮추려는 호흡이다. 상처의 맥락을 펼쳐 두면 판단의 속도가 늦춰지고, 그 사이에서 자신에게 유리한 해석의 틀을 잔잔히 주입하려는 의도가 따른다.", "그는 경로의 피로와 날씨의 무게를 말로 치환한다. 내면의 매듭을 풀며 상대의 시선을 묶어 두고, 사건의 초점을 주변부로 분산시켜 지금 이 순간을 지연시키려는 심리가 작동한다."]
    },
    {
        id: 6,
        question: "소설의 마지막, 형사는 억구를 체포하는 대신 담배 한 갑을 건넨다. 이 행동에 담긴 형사의 내면 심리와, \"하루에 꼭 한 개씩만 피우셔야 합니다.\"라는 말의 상징적 의미를 서술하시오.\n\n< 조 건 >\n남은 담배의 개수와 연결하여 설명할 것.",
        questionType: "조건형",
        correctAnswer: "형사가 담배를 건네는 행동에는, 억구의 불행한 삶에 대한 깊은 인간적 연민과 그의 죄를 법으로 심판하기에 앞서 한 인간으로서 용서하고 위로하려는 마음이 담겨 있다. 두 사람이 이미 담배 두 개비를 피웠으므로 남은 담배는 18개비이다. 따라서 \"하루에 꼭 한 개씩만 피우라\"는 말은, 억구에게 18일간의 자유 시간을 주겠다는 상징적인 표현이다. 이는 억구가 아버지의 산소를 찾아가 마지막 효를 다하고, 자신의 삶을 정리하며 인간으로서의 존엄을 지킬 수 있도록 배려하는 형사의 인도주의적인 결단을 의미한다.",
        scoringCriteria: "① 형사의 연민과 용서의 마음 서술, ② 남은 담배 개수(18개비)와 연결하여 18일의 시간을 의미함을 서술, ③ 그 시간의 의미(삶을 정리할 기회 부여)를 서술.",
        correctParts: [
            "형사가 담배를 건네는 행동에는, 억구의 불행한 삶에 대한 깊은 인간적 연민과 그의 죄를 법으로 심판하기에 앞서 한 인간으로서 용서하고 위로하려는 마음이 담겨 있다.",
            "두 사람이 이미 담배 두 개비를 피웠으므로 남은 담배는 18개비이다. 따라서 '하루에 꼭 한 개씩만 피우라'는 말은, 억구에게 18일간의 자유 시간을 주겠다는 상징적인 표현이다.",
            "이는 억구가 아버지의 산소를 찾아가 마지막 효를 다하고, 자신의 삶을 정리하며 인간으로서의 존엄을 지킬 수 있도록 배려하는 형사의 인도주의적인 결단을 의미한다."
        ],
        distractors: ["담배를 건네는 행위는 긴장을 낮추는 의례다. 그는 냉혹한 결박 대신 호흡을 돌릴 공간을 열고, 말의 리듬을 맞춰가며 이후 절차를 차분히 안내하려는 마음을 담아낸다.", "그 말은 시간을 재는 별도의 시계를 꺼내는 일이다. 둘이 공유한 개비 수만큼 기억의 눈금을 새기고, 그만큼의 평정 속에서 다음 결정을 숙성시키려는 제스처다.", "형사는 차가운 밤의 체온을 나눠 들려준다. 품에서 꺼낸 가벼운 불씨로 대화를 이으며, 매듭을 급히 묶지 말자는 무언의 합의를 조심스레 제안한다."]
    },
    {
        id: 7,
        question: "소설 속 두 인물의 옷차림은 대조적으로 묘사된다. '억구'와 '형사'의 옷차림이 각각 두 인물의 어떤 처지와 상황을 암시하는지 서술하시오.",
        questionType: "내용/해석형",
        correctAnswer: "'억구'는 추운 겨울밤에 맞지 않게 얇은 양복 한 벌만 걸친 초라하고 을씨년스러운 옷차림이다. 이는 범죄를 저지르고 쫓기는 그의 불안정한 처지와 평생 가난과 사회적 냉대 속에서 살아온 그의 소외된 삶을 암시한다. 반면, '형사'는 중절모와 밤색 오버 등 방한에 빈틈이 없는 옷차림이다. 이는 사회 제도권 내에 있는 그의 안정적인 신분과, 범인을 쫓는 공적 임무를 수행하는 그의 상황을 암시한다.",
        scoringCriteria: "① 억구 옷차림의 의미(불안정한 처지, 소외된 삶), ② 형사 옷차림의 의미(안정적 신분, 공적 임무)를 각각 서술.",
        correctParts: [
            "'억구'는 추운 겨울밤에 맞지 않게 얇은 양복 한 벌만 걸친 초라하고 을씨년스러운 옷차림이다. 이는 범죄를 저지르고 쫓기는 그의 불안정한 처지와 평생 가난과 사회적 냉대 속에서 살아온 그의 소외된 삶을 암시한다.",
            "반면, '형사'는 중절모와 밤색 오버 등 방한에 빈틈이 없는 옷차림이다. 이는 사회 제도권 내에 있는 그의 안정적인 신분과, 범인을 쫓는 공적 임무를 수행하는 그의 상황을 암시한다."
        ],
        distractors: ["억구의 얇은 옷차림은 이동의 급박함을 드러낸다. 형사의 단단한 외투는 대비되는 규율의 촉감을 전하고, 두 사람의 보폭 차이가 역할의 간극을 꾸준히 상기시킨다.", "서늘한 공기에 드러난 억구의 옷은 삶의 여백을 보여 준다. 단정한 형사의 차림은 절차의 질서를 배어 나오게 하고, 두 인물의 거리감은 외양에서 먼저 형상화된다.", "옷의 결은 말보다 먼저 사정을 말한다. 억구의 가벼움은 보호의 부재를, 형사의 대비는 책임의 무게를 환기하며, 장면의 공기를 조용히 정렬한다."]
    },
    {
        id: 8,
        question: "억구가 자백하며 \"자, 날 어떻게 하겠수?\"라고 물었을 때, 형사는 법적 임무와 인간적 연민 사이에서 갈등한다. 형사가 겪는 '내적 갈등'의 구체적인 내용이 무엇인지 서술하시오.",
        questionType: "내용형",
        correctAnswer: "형사는 범인을 체포하여 법의 심판을 받게 해야 하는 '법 집행관으로서의 공적 임무'와, 억구의 불행한 삶의 내력을 듣고 그가 겪어온 고통과 죄의식을 이해하게 되면서 느끼는 '한 인간으로서의 연민' 사이에서 갈등한다. 즉, 사회 질서를 유지해야 하는 냉정한 법의 잣대와 한 개인의 비극적인 삶을 동정하는 따뜻한 인간애 사이에서 어떤 선택을 해야 할지 고뇌하는 것이다.",
        scoringCriteria: "① 법 집행관으로서의 공적 임무, ② 한 인간으로서의 연민을 명확히 구분하여 갈등의 내용을 서술.",
        correctParts: [
            "형사는 범인을 체포하여 법의 심판을 받게 해야 하는 '법 집행관으로서의 공적 임무'와, 억구의 불행한 삶의 내력을 듣고 그가 겪어온 고통과 죄의식을 이해하게 되면서 느끼는 '한 인간으로서의 연민' 사이에서 갈등한다.",
            "즉, 사회 질서를 유지해야 하는 냉정한 법의 잣대와 한 개인의 비극적인 삶을 동정하는 따뜻한 인간애 사이에서 어떤 선택을 해야 할지 고뇌하는 것이다."
        ],
        distractors: ["그는 법의 언어와 인간의 언어 사이에서 속도를 조절한다. 판결의 문장과 위로의 문장이 충돌하지 않도록 고심하며, 어느 쪽도 가볍지 않게 무게중심을 되묻는다.", "형사는 사건의 해명과 사람의 구제를 한 화면에 담을 수 있을지 자문한다. 절차의 선명함과 마음의 온도가 어긋나지 않도록, 선택의 언저리를 오래 맴돈다.", "그는 직업의 표정과 개인의 표정이 서로를 잠식하지 않게 한다. 공적 책임을 흐리지 않으면서도, 눈앞의 사연을 공허하게 만들지 않으려 균형을 모색한다."]
    },
    {
        id: 9,
        question: "'억구'는 \"한번쯤은 인간답게 살아 보구 싶었던 겁니다.\"라고 말한다. 그의 불행한 삶을 통해 볼 때, 그가 생각하는 '인간다운 삶'이란 무엇이었을지 추론하여 서술하시오.",
        questionType: "내용/해석형",
        correctAnswer: "억구가 생각하는 '인간다운 삶'이란, 어린 시절의 모멸감과 전쟁의 상처 같은 외부의 폭력과 억압에서 벗어나, 한 개인으로서 존중받으며 평범한 관계 속에서 살아가는 삶을 의미한다. 또한, 자신의 죄의식과 과거의 트라우마에서 벗어나 마음의 평화를 얻고, 타인과 진정한 유대를 맺으며 자신의 존재 가치를 느끼는 삶을 갈망했다고 볼 수 있다.",
        scoringCriteria: "① 외부의 억압으로부터의 자유, ② 한 개인으로서의 존중과 평범한 삶, ③ 내면의 죄의식으로부터의 해방 등을 타당하게 추론하여 서술.",
        correctParts: [
            "억구가 생각하는 '인간다운 삶'이란, 어린 시절의 모멸감과 전쟁의 상처 같은 외부의 폭력과 억압에서 벗어나, 한 개인으로서 존중받으며 평범한 관계 속에서 살아가는 삶을 의미한다.",
            "또한, 자신의 죄의식과 과거의 트라우마에서 벗어나 마음의 평화를 얻고, 타인과 진정한 유대를 맺으며 자신의 존재 가치를 느끼는 삶을 갈망했다고 볼 수 있다."
        ],
        distractors: ["그가 바라는 삶은 외풍을 견딜 최소한의 벽을 갖추는 일이다. 작은 일상의 일정함 속에서 자신을 잃지 않고, 관계의 속도를 자신에게 맞출 수 있는 여유다.", "그는 흔들림이 적은 자리를 꿈꾼다. 치유의 호흡이 이어지는 관계 안에서 과거의 그림자를 길들이고, 이름 불리는 순간의 품위를 회복하고자 한다.", "인간다운 삶은 스스로의 기준을 세우는 과정이다. 타인의 규정에 휘둘리지 않고, 서서히 자신을 보듬는 일로 날을 채우는 상태다."]
    },
    {
        id: 10,
        question: "이 소설의 결말에서 억구는 '울음 같은 웃음'을 터뜨린다. 이 복합적인 감정이 무엇을 의미하는지, 그가 처한 상황과 형사의 마지막 행동을 바탕으로 서술하시오.",
        questionType: "내용/해석형",
        correctAnswer: "억구의 '울음 같은 웃음'은 복합적인 감정이 응축된 표현이다. 살인범인 자신의 처지에 대한 비참함과 평생 불행하게 살아온 삶에 대한 자조적인 '울음'인 동시에, 처음으로 타인(형사)에게서 자신의 고통을 이해받고 용서받았다는 사실에 대한 '웃음'이다. 즉, 법의 심판 대신 인간적인 연민을 보여준 형사의 행동을 통해, 자신의 죄를 씻고 구원받을 수 있다는 희망을 발견한 데서 오는 감격과 안도, 그리고 자신의 기구한 운명에 대한 허탈감이 뒤섞인 것이라 할 수 있다.",
        scoringCriteria: "① 자신의 처지에 대한 비참함/자조(울음의 측면), ② 타인에게 이해받고 용서받은 것에 대한 감격(웃음의 측면), ③ 구원의 희망과 기구한 운명에 대한 허탈감의 복합적 감정을 서술.",
        correctParts: [
            "억구의 '울음 같은 웃음'은 복합적인 감정이 응축된 표현이다. 살인범인 자신의 처지에 대한 비참함과 평생 불행하게 살아온 삶에 대한 자조적인 '울음'인 동시에, 처음으로 타인(형사)에게서 자신의 고통을 이해받고 용서받았다는 사실에 대한 '웃음'이다.",
            "즉, 법의 심판 대신 인간적인 연민을 보여준 형사의 행동을 통해, 자신의 죄를 씻고 구원받을 수 있다는 희망을 발견한 데서 오는 감격과 안도, 그리고 자신의 기구한 운명에 대한 허탈감이 뒤섞인 것이라 할 수 있다."
        ],
        distractors: ["그 웃음에는 얼어붙은 체온이 서서히 풀리는 감각이 겹친다. 무게를 덜어 준 손길을 느끼면서도, 돌아갈 길의 길이를 계산하는 냉기가 끝내 남아 있다.", "그는 마지막에 숨을 길게 고른다. 이해의 문턱에 도착했다는 안도와, 아직 마무리되지 않은 장부를 떠올리는 쓸쓸함이 한데 겹쳐 미묘한 표정이 된다.", "울음과 웃음은 서로의 가장자리를 닮는다. 벗겨지는 매듭의 통증과 가벼움이 동시에 밀려오고, 그 사이의 공백이 한순간 허허로 번진다."]
    }
        ];

        // 5단계 초기화
        function initStage5() {
            console.log('initStage5() 호출됨');

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;
            console.log('currentStage를 5로 설정함');

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '전상국 <동행>';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="nextStage()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
            // 학습 완료 버튼 추가
            if (typeof addCompleteLearningButton === 'function') {
                setTimeout(() => addCompleteLearningButton(), 500);
            }
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stageResults,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `봄봄_워크북_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>