<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>흥부전 내신 대비 워크북</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 999;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .subtitle {
            font-size: 14px;
            color: #7f8c8d;
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stage-indicator {
            display: flex;
            gap: 10px;
        }

        .stage-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            background: #3498db;
            transform: scale(1.3);
        }

        .stage-dot.completed {
            background: #27ae60;
        }

        .question-counter {
            font-size: 18px;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Timer Bar */
        .timer-container {
            width: 300px;
            height: 24px;
            background: #ecf0f1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .timer-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        /* Main Content */
        .main-content {
            margin-top: 100px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
        }

        .passage-container {
            font-size: 18px;
            line-height: 2;
            color: #2c3e50;
            word-break: keep-all;
            white-space: pre-wrap;
        }

        .passage-container h2 {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .passage-container h3 {
            font-size: 20px;
            font-weight: 600;
            color: #34495e;
            margin: 25px 0 15px 0;
        }

        .passage-container strong {
            font-weight: 700;
            color: #2c3e50;
        }

        .passage-container ul,
        .passage-container ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .passage-container li {
            margin: 8px 0;
            line-height: 1.8;
        }

        .passage-container .section-number {
            display: inline-block;
            font-weight: 700;
            color: #3498db;
            margin-right: 8px;
        }

        .passage-container .subsection {
            margin-left: 20px;
            margin-top: 15px;
            padding-left: 15px;
            border-left: 3px solid #ecf0f1;
        }

        /* Highlights */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            position: relative;
        }

        .highlight:hover {
            background-color: rgba(255, 235, 59, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }

        .highlight.active {
            background-color: rgba(255, 235, 59, 0.6);
            box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.4);
            animation: pulse 1s infinite;
        }

        .highlight.correct {
            background-color: rgba(76, 175, 80, 0.3);
        }

        .highlight.correct:hover {
            background-color: rgba(76, 175, 80, 0.4);
        }

        .highlight.incorrect {
            background-color: rgba(244, 67, 54, 0.3);
        }

        .highlight.incorrect:hover {
            background-color: rgba(244, 67, 54, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Question Modal */
        .question-modal {
            position: fixed;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: min(90vw, 450px);
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            cursor: move;
            display: none;
            will-change: transform;
        }

        .question-modal.active {
            display: block;
        }

        .question-modal.dragging {
            opacity: 0.95;
            user-select: none;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-question {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 20px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-button:hover:not(:disabled) {
            background: #e3f2fd;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .option-button.correct {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .option-button.incorrect {
            background: #ffebee;
            border-color: #f44336;
        }

        .option-button:disabled {
            cursor: default;
            opacity: 0.8;
        }

        .option-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-weight: 600;
            font-size: 12px;
        }

        /* Feedback Animation */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .correct-animation {
            animation: correctPulse 0.6s ease;
        }

        .incorrect-animation {
            animation: incorrectShake 0.5s ease;
        }

        /* Result Screen */
        .result-screen {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 100px;
        }

        .result-screen.active {
            display: block;
        }

        /* 결과 화면 표시 시 시간바 숨김 */
        body:has(.result-screen.active) .timer-container {
            display: none !important;
        }

        /* 모달 공통 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #95a5a6;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-modal-btn:hover {
            background: #ecf0f1;
            color: #e74c3c;
        }

        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }

        .result-title {
            font-size: 32px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .result-button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-button.primary {
            background: #3498db;
            color: white;
        }

        .result-button.primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .result-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .result-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Vocabulary Learning Styles (Stage 2) */
        .vocabulary-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .vocabulary-question-card {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .question-number {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .vocab-option-button {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .vocab-option-button:hover:not(:disabled) {
            background: #e9ecef;
            border-color: #3498db;
            transform: translateX(5px);
        }

        .vocab-option-button:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .vocab-option-button .option-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            font-weight: 600;
            flex-shrink: 0;
        }

        .vocab-option-button .option-text {
            flex: 1;
            color: #2c3e50;
        }

        .vocab-option-button.correct {
            background: #d4edda;
            border-color: #27ae60;
        }

        .vocab-option-button.correct .option-number {
            background: #27ae60;
        }

        .vocab-option-button.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            animation: shake 0.5s;
        }

        .vocab-option-button.incorrect .option-number {
            background: #f44336;
        }

        /* Sentence Reading Styles (Stage 3) */
        .sentence-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .sentence-display {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .sentence-text {
            font-size: 20px;
            line-height: 1.8;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 500;
            white-space: normal;
            word-break: keep-all;
        }

        .sentence-question {
            font-size: 22px;
            color: #3498db;
            font-weight: 600;
            margin-bottom: 30px;
            white-space: normal;
            word-break: keep-all;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 700px;
            margin: 0 auto;
        }

        .flip-card {
            background-color: transparent;
            width: 100%;
            height: 120px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flip-card-front {
            background: white;
            color: #2c3e50;
            border: 2px solid #e9ecef;
        }

        .flip-card:hover .flip-card-front {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .flip-card-back {
            transform: rotateY(180deg);
        }

        .flip-card-back.correct {
            background: #10b981;
            color: white;
        }

        .flip-card-back.incorrect {
            background: #ef4444;
            color: white;
        }

        .card-text {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.6;
            white-space: normal;
            word-break: keep-all;
        }

        .card-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .flip-card:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Stage 2 이후 공통 폰트 크기 축소 */
            body {
                font-size: 14px;  /* 기본 폰트 크기 축소 */
            }

            #main-content {
                font-size: 14px;
            }

            /* Stage 2 - 확인 학습 모바일 최적화 */
            .stage2-question {
                font-size: 14px;
                padding: 15px;
            }

            .stage2-text {
                font-size: 13px;
                line-height: 1.5;
            }

            /* Stage 3 - 복기 학습 모바일 최적화 */
            .sentence-card {
                padding: 10px;
                font-size: 13px;
                margin: 5px;
            }

            .drop-zone {
                min-height: 60px;
                padding: 10px;
                margin: 5px;
            }

            /* Stage 1 모달 */
            .question-modal {
                width: 85vw;
                max-height: 70vh;
                padding: 16px;
            }

            .modal-question {
                font-size: 13px;  /* 더 작게 조정 */
            }

            .option-button {
                padding: 8px 10px;  /* 패딩도 줄임 */
                font-size: 12px;  /* 더 작게 조정 */
            }

            .header {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .title {
                font-size: 20px;
            }

            .subtitle {
                font-size: 12px;
            }

            .progress-info {
                width: 100%;
                justify-content: space-between;
                gap: 10px;
            }

            .question-counter {
                font-size: 14px;
            }

            .timer-container {
                width: 200px;
                height: 18px;
            }

            .stage-dot {
                width: 10px;
                height: 10px;
            }
        }

        /* Mobile Phone Size */
        @media (max-width: 480px) {
            .header {
                padding: 10px;
                gap: 8px;
            }

            .header-left {
                gap: 3px;
            }

            .title {
                font-size: 16px;
                font-weight: 600;
            }

            .subtitle {
                font-size: 11px;
            }

            .progress-info {
                gap: 8px;
            }

            .question-counter {
                font-size: 12px;
                font-weight: 400;
            }

            .timer-container {
                width: 150px;
                height: 14px;
            }

            .stage-indicator {
                gap: 6px;
            }

            .stage-dot {
                width: 8px;
                height: 8px;
            }

            .stage-dot.active {
                transform: scale(1.2);
            }

            .main-content {
                margin-top: 80px;
                padding: 20px;
            }

            .passage-container {
                font-size: 16px;
                line-height: 1.8;
            }

            .question-modal {
                width: 90vw;
                padding: 12px;
            }

            .modal-header {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .modal-question {
                font-size: 13px;
                margin-bottom: 15px;
            }

            .option-button {
                padding: 8px 10px;
                font-size: 12px;
                gap: 8px;
            }

            .option-number {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 10px;
            }

            /* Stage 2 Vocabulary Mobile */
            .vocabulary-question-card {
                padding: 20px;
            }

            .question-text {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .vocab-option-button {
                padding: 12px 15px;
                font-size: 14px;
                gap: 12px;
            }

            .vocab-option-button .option-number {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            /* Stage 3 Sentence Mobile */
            .sentence-display {
                padding: 20px;
            }

            .sentence-text {
                font-size: 16px;
                line-height: 1.6;
            }

            .sentence-question {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .flip-card {
                height: 100px;
            }

            .card-text {
                font-size: 14px;
            }

            .card-icon {
                font-size: 36px;
            }
        }
    </style>

    <!-- html-to-image CDN -->
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="title">흥부전</div>
                <div class="subtitle">1단계: 딥리서치 - 핵심 정리</div>
            </div>
            <div class="progress-info">
                <div class="stage-indicator">
                    <div class="stage-dot active"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div class="question-counter">
                    문제: <span id="current-question">0</span> / <span id="total-questions">0</span>
                </div>
                <div class="timer-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="main-content">
            <div class="passage-container" id="passage-container"></div>
        </div>

        <!-- Result Screen -->
        <div class="result-screen" id="result-screen">
            <h2 class="result-title">1단계 학습 완료!</h2>
            <div class="result-stats">
                <div class="stat-box">
                    <div class="stat-value" id="progress-stat">0%</div>
                    <div class="stat-label">진행률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy-stat">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="correct-stat">0</div>
                    <div class="stat-label">맞힌 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="wrong-stat">0</div>
                    <div class="stat-label">틀린 문제</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-stat">0:00</div>
                    <div class="stat-label">소요 시간</div>
                </div>
            </div>
            <div class="result-buttons">
                <button class="result-button secondary" onclick="restartStage()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage()">다음 단계로</button>
            </div>
        </div>

        <!-- Question Modal -->
        <div class="question-modal" id="question-modal">
            <div class="modal-header">문제 <span id="modal-question-num">1</span></div>
            <div class="modal-question" id="modal-question-text"></div>
            <div class="modal-options" id="modal-options"></div>
        </div>
    </div>

    <script>
        // 현재 단계
        let currentStage = 1;

        // 전체 학습 결과 저장소
        const allStageResults = {
            stage1: null,
            stage2: null,
            stage3: null,
            stage4: null,
            stage5: null
        };

        // 학습 데이터
        const learningData = {
            questions: [
                // 1️⃣ 딥리서치 - 작품 해제 (3문제)
                {
                    id: 1,
                    text: "선량한 동생 흥부와 악한 형 놀부의 이야기를 통해 _____이라는 보편적 주제를 명확하게 드러냅니다.",
                    highlight: "(권선징악 / 인과응보)",
                    options: ["권선징악", "인과응보"],
                    correct: 0
                },
                {
                    id: 2,
                    text: "조선 후기 사회의 급격한 변화를 _____ 그려내며 당대 사회를 풍자하고 있습니다.",
                    highlight: "(낭만적으로 / 사실적으로)",
                    options: ["낭만적으로", "사실적으로"],
                    correct: 1
                },
                {
                    id: 3,
                    text: "빈농의 처참한 삶을 그려내며 당대 사회를 _____ 있습니다.",
                    highlight: "(풍자하고 / 긍정하고)",
                    options: ["풍자하고", "긍정하고"],
                    correct: 0
                },
                // 1️⃣ 딥리서치 - 핵심 정리표 (8문제)
                {
                    id: 4,
                    text: "**갈래** - 고전 소설, _____, 영웅 소설",
                    highlight: "(판소리계 소설 / 서사 무가)",
                    options: ["판소리계 소설", "서사 무가"],
                    correct: 0
                },
                {
                    id: 5,
                    text: "**성격** - 해학적, 풍자적, _____",
                    highlight: "(교훈적 / 전기적)",
                    options: ["교훈적", "전기적"],
                    correct: 0
                },
                {
                    id: 6,
                    text: "**배경** - 시간적: 조선 후기 공간적: _____",
                    highlight: "(서울 / 농촌 마을)",
                    options: ["서울", "농촌 마을"],
                    correct: 1
                },
                {
                    id: 7,
                    text: "**시점** - _____ 시점 ➕ 서술자의 개입(편집자적 논평)이 자주 드러남",
                    highlight: "(1인칭 주인공 / 전지적 작가)",
                    options: ["1인칭 주인공", "전지적 작가"],
                    correct: 1
                },
                {
                    id: 8,
                    text: "**주제** - 형제간의 우애와 _____ 사상",
                    highlight: "(권선징악 / 인과율)",
                    options: ["권선징악", "인과율"],
                    correct: 0
                },
                {
                    id: 9,
                    text: "**특징** - 판소리 사설이 정착된 것으로, 운문체와 _____가 혼합되어 있음.",
                    highlight: "(산문체 / 율문체)",
                    options: ["산문체", "율문체"],
                    correct: 0
                },
                {
                    id: 10,
                    text: "**특징** - 현실적(가난한 삶) 내용과 _____ 내용이 조화롭게 나타남.",
                    highlight: "(비현실적 / 교훈적)",
                    options: ["비현실적", "교훈적"],
                    correct: 0
                },
                {
                    id: 11,
                    text: "**특징** - 인물의 행동과 심리를 _____으로 제시하여 생동감을 부여함.",
                    highlight: "(직접적 / 간접적)",
                    options: ["직접적", "간접적"],
                    correct: 0
                },
                // 1️⃣ 딥리서치 - 전체 줄거리 (15문제)
                {
                    id: 12,
                    text: "[발단] 흥부는 마음이 _____ 가난하지만 욕심 없이 살아간다.",
                    highlight: "(인색하여 / 인후하여)",
                    options: ["인색하여", "인후하여"],
                    correct: 1
                },
                {
                    id: 13,
                    text: "[발단] 흥부는 형님인 놀부의 모진 성품을 알기에 망설이지만, 아내의 간절한 부탁에 _____ 놀부의 집으로 향한다.",
                    highlight: "(용기를 내어 / 마지못해)",
                    options: ["용기를 내어", "마지못해"],
                    correct: 1
                },
                {
                    id: 14,
                    text: "[전개] 치장이라곤 변변치 않은 흥부의 모습은 _____ 가난을 단적으로 보여준다.",
                    highlight: "(풍요로운 / 비참한)",
                    options: ["풍요로운", "비참한"],
                    correct: 1
                },
                {
                    id: 15,
                    text: "[전개] 흥부가 놀부의 집에 도착하자, 놀부는 그의 모습을 보고 형제끼리도 _____ 흥부를 구박한다.",
                    highlight: "(정겹게 / 내외하여)",
                    options: ["정겹게", "내외하여"],
                    correct: 1
                },
                {
                    id: 16,
                    text: "[전개] 놀부는 자신의 재산을 _____ 과시하며 흥부를 매몰차게 거절한다.",
                    highlight: "(열거하고 / 대조하고)",
                    options: ["열거하고", "대조하고"],
                    correct: 0
                },
                {
                    id: 17,
                    text: "[전개] 놀부는 급기야 하인 마당쇠를 시켜 _____를 내오게 한 뒤, 흥부를 무자비하게 구타한다.",
                    highlight: "(보리섬 / 돝자루)",
                    options: ["보리섬", "돝자루"],
                    correct: 1
                },
                {
                    id: 18,
                    text: "[위기] 놀부 아내는 \"남녀가 유별하다\"며 _____으로 흥부의 뺨을 때린다.",
                    highlight: "(밥그릇 / 밥 주걱)",
                    options: ["밥그릇", "밥 주걱"],
                    correct: 1
                },
                {
                    id: 19,
                    text: "[위기] 흥부는 \"아주머님은 뺨을 쳐도 엿여 먹여 가시니\"라고 말하며 밥알이 묻은 뺨을 _____ 웃음을 자아낸다.",
                    highlight: "(닦아내고 / 훔쳐 넣어)",
                    options: ["닦아내고", "훔쳐 넣어"],
                    correct: 1
                },
                {
                    id: 20,
                    text: "[위기] 이는 흥부의 _____과 해학적인 성품을 보여준다.",
                    highlight: "(비인간성 / 낙천성)",
                    options: ["비인간성", "낙천성"],
                    correct: 1
                },
                {
                    id: 21,
                    text: "[절정] _____는 어느 날 구렁이에게 다리를 물린 제비를 구해주고, 그 제비가 물어다 준 박씨를 심어 큰 부자가 된다.",
                    highlight: "(놀부 / 흥부)",
                    options: ["놀부", "흥부"],
                    correct: 1
                },
                {
                    id: 22,
                    text: "[절정] 이 소문을 들은 놀부는 동지섣달부터 제비를 기다리며 흥부의 행동을 _____ 부자가 되려고 한다.",
                    highlight: "(본받아 / 모방하여)",
                    options: ["본받아", "모방하여"],
                    correct: 1
                },
                {
                    id: 23,
                    text: "[절정] 놀부는 멀쩡한 제비 새끼를 잡아다 _____ 다리를 부러뜨리는 악행을 저지른다.",
                    highlight: "(인위적으로 / 우연히)",
                    options: ["인위적으로", "우연히"],
                    correct: 0
                },
                {
                    id: 24,
                    text: "[결말] 놀부에게 다리가 부러진 제비는 강남으로 돌아가 _____에게 놀부의 만행을 고한다.",
                    highlight: "(강남 황제 / 강남 부자)",
                    options: ["강남 황제", "강남 부자"],
                    correct: 0
                },
                {
                    id: 25,
                    text: "[결말] 황제는 놀부의 악행에 _____, 제비에게 놀부에게 '보수표(報讐瓢)'를 가져다주라고 한다.",
                    highlight: "(탄복하고 / 분개하고)",
                    options: ["탄복하고", "분개하고"],
                    correct: 1
                },
                {
                    id: 26,
                    text: "[결말] 이는 선행에 대한 보상과 악행에 대한 _____이라는 권선징악의 주제를 향한 결정적인 복선이다.",
                    highlight: "(보상 / 응징)",
                    options: ["보상", "응징"],
                    correct: 1
                },
                // 2️⃣ 작품 미리보기 (9문제)
                {
                    id: 27,
                    text: "[작가와 시대] 착한 사람은 복을 받고 나쁜 사람은 벌을 받는다는 _____을 이야기하고 있어요.",
                    highlight: "(교훈 / 사실)",
                    options: ["교훈", "사실"],
                    correct: 0
                },
                {
                    id: 28,
                    text: "[줄거리 1] 흥부는 _____ 놀부의 집으로 향합니다.",
                    highlight: "(기꺼이 / 어쩔 수 없이)",
                    options: ["기꺼이", "어쩔 수 없이"],
                    correct: 1
                },
                {
                    id: 29,
                    text: "[줄거리 2] 놀부는 \"네가 누군데 우리 집에 왔냐\"며 흥부를 _____.",
                    highlight: "(모른 척합니다 / 반갑게 맞이합니다)",
                    options: ["모른 척합니다", "반갑게 맞이합니다"],
                    correct: 0
                },
                {
                    id: 30,
                    text: "[줄거리 2] 하인 마당쇠를 불러 흥부를 _____ 내쫓아요.",
                    highlight: "(돕게 하고 / 몽둥이로 때려)",
                    options: ["돕게 하고", "몽둥이로 때려"],
                    correct: 1
                },
                {
                    id: 31,
                    text: "[줄거리 3] 놀부 아내는 \"남녀유별한데 어딜 들어오느냐\"며 _____ 흥부를 내쫓습니다.",
                    highlight: "(매몰차게 / 정중하게)",
                    options: ["매몰차게", "정중하게"],
                    correct: 0
                },
                {
                    id: 32,
                    text: "[줄거리 3] 흥부의 순수함과 _____ 태도 때문에 오히려 웃음이 터져 나오게 만든답니다.",
                    highlight: "(부정적인 / 긍정적인)",
                    options: ["부정적인", "긍정적인"],
                    correct: 1
                },
                {
                    id: 33,
                    text: "[줄거리 4] 흥부는 구렁이에게 다리가 부러진 제비 새끼를 발견하고 정성껏 _____.",
                    highlight: "(치료해 줍니다 / 외면합니다)",
                    options: ["치료해 줍니다", "외면합니다"],
                    correct: 0
                },
                {
                    id: 34,
                    text: "[줄거리 5] 놀부는 _____를 잡아다가 일부러 다리를 부러뜨리는 끔찍한 짓을 저질러요.",
                    highlight: "(멀쩡한 제비 새끼 / 병든 제비 새끼)",
                    options: ["멀쩡한 제비 새끼", "병든 제비 새끼"],
                    correct: 0
                },
                {
                    id: 35,
                    text: "[줄거리 5] 흥부의 선행을 _____ 거죠.",
                    highlight: "(흉내 낸 / 비웃은)",
                    options: ["흉내 낸", "비웃은"],
                    correct: 0
                }
            ],
            stage1Text: `## 1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠

■ 작품 해제

이 작품은 조선 후기에 형성된 작자 미상의 판소리계 소설로, 한국 문학사에서 가장 대중적인 고전 중 하나입니다. 선량한 동생 흥부와 악한 형 놀부의 이야기를 통해 (권선징악 / 인과응보)이라는 보편적 주제를 명확하게 드러냅니다. 표면적으로는 형제간의 우애와 도덕적 교훈을 강조하지만, 그 이면에는 조선 후기 사회의 급격한 변화, 즉 신흥 부유층의 비인간적인 행태와 빈농의 처참한 삶을 (낭만적으로 / 사실적으로) 그려내며 당대 사회를 (풍자하고 / 긍정하고) 있습니다.

■ 핵심 정리 표

| 구분 | 내용 |
| :---- | :---- |
| **갈래** | 고전 소설, (판소리계 소설 / 서사 무가), 영웅 소설 |
| **성격** | 해학적, 풍자적, (교훈적 / 전기적) |
| **배경** | 시간적: 조선 후기 공간적: (서울 / 농촌 마을) |
| **시점** | (1인칭 주인공 / 전지적 작가) 시점 ➕ 서술자의 개입(편집자적 논평)이 자주 드러남 |
| **주제** | 형제간의 우애와 (권선징악 / 인과율) 사상 |
| **특징** | 1. 판소리 사설이 정착된 것으로, 운문체와 (산문체 / 율문체)가 혼합되어 있음. 2. 선과 악이 분명한 **전형적인 인물**을 통해 주제를 효과적으로 드러냄. 3. 현실적(가난한 삶) 내용과 (비현실적 / 교훈적) 내용이 조화롭게 나타남. 4. 등장인물의 대화에 해학(諧謔)과 풍자(諷刺)가 잘 드러남. 5. 인물의 행동과 심리를 (직접적 / 간접적)으로 제시하여 생동감을 부여함. |

■ 전체 줄거리 및 출제 포인트

**[발단] 착한 흥부와 악한 놀부**

흥부는 마음이 (인색하여 / 인후하여) 가난하지만 욕심 없이 살아간다. 흥부 아내는 굶주리는 자식들을 위해 남편에게 형님 집으로 가서 쌀을 얻어오라고 설득한다. 흥부는 형님인 놀부의 모진 성품을 알기에 망설이지만, 아내의 간절한 부탁에 (용기를 내어 / 마지못해) 놀부의 집으로 향한다.

**[전개] 놀부의 비인간성과 흥부의 수난**

치장이라곤 변변치 않은 흥부의 모습은 (풍요로운 / 비참한) 가난을 단적으로 보여준다. 흥부가 놀부의 집에 도착하자, 놀부는 그의 모습을 보고 형제끼리도 (정겹게 / 내외하여) 흥부를 구박한다. 흥부가 굶주린 자식들을 위해 쌀 한 되만 달라고 애원하지만, 놀부는 자신의 재산을 (열거하고 / 대조하고) 과시하며 흥부를 매몰차게 거절한다. 놀부는 급기야 하인 마당쇠를 시켜 (보리섬 / 돝자루)를 내오게 한 뒤, 흥부를 무자비하게 구타한다.

**[위기] 주걱으로 맞은 뺨과 해학적 태도**

놀부의 매를 맞고 쫓겨난 흥부는 혹시나 하는 마음에 부엌으로 간다. 밥 냄새를 맡고 오장이 뒤집혀 놀부 아내에게 밥 한 술을 애걸한다. 하지만 놀부 아내는 "남녀가 유별하다"며 (밥그릇 / 밥 주걱)으로 흥부의 뺨을 때린다. 이 비극적인 상황에서 흥부는 "아주머님은 뺨을 쳐도 엿여 먹여 가시니"라고 말하며 밥알이 묻은 뺨을 (닦아내고 / 훔쳐 넣어) 웃음을 자아낸다. 이는 흥부의 (비인간성 / 낙천성)과 해학적인 성품을 보여주는 동시에, 당시 서민들의 고통을 웃음으로 승화시키려는 건강한 삶의 태도를 드러낸다.

**[절정] 흥부의 선행과 놀부의 모방**

(놀부 / 흥부)는 어느 날 구렁이에게 다리를 물린 제비를 구해주고, 그 제비가 물어다 준 박씨를 심어 큰 부자가 된다. 이 소문을 들은 놀부는 동지섣달부터 제비를 기다리며 흥부의 행동을 (본받아 / 모방하여) 부자가 되려고 한다. 그는 자연스럽게 다친 제비를 기다리는 흥부와 달리, 멀쩡한 제비 새끼를 잡아다 (인위적으로 / 우연히) 다리를 부러뜨리는 악행을 저지른다.

**[결말] 놀부의 악행에 대한 응징**

놀부에게 다리가 부러진 제비는 강남으로 돌아가 (강남 황제 / 강남 부자)에게 놀부의 만행을 고한다. 황제는 놀부의 악행에 (탄복하고 / 분개하고), 제비에게 놀부에게 '보수표(報讐瓢)'를 가져다주라고 한다. 이는 선행에 대한 보상과 악행에 대한 (보상 / 응징)이라는 권선징악의 주제를 향한 결정적인 복선으로, 결국 놀부가 박을 타서 징벌을 받게 될 것임을 암시한다.

## 2️⃣ 작품 미리보기: 배경지식의 첫걸음 📝

■ 작가와 시대 이야기

흥부전은 작가가 누구인지 알려지지 않은 '작자 미상'의 작품이에요. 조선 후기에 평범한 사람들의 삶을 노래하던 '판소리'로 불리다가 나중에 글로 쓰이면서 소설이 되었죠. 당시 조선은 신분제도가 흔들리고 농민들이 힘겹게 살아가던 시기였어요. 땅을 잃고 가난해진 농민들은 흥부처럼 가난과 싸워야 했고, 일부는 놀부처럼 돈을 모아 새로운 부자가 되기도 했답니다. 이 소설은 바로 그 시대의 모습을 거울처럼 보여주면서, 착한 사람은 복을 받고 나쁜 사람은 벌을 받는다는 (교훈 / 사실)을 이야기하고 있어요.

■ 흥부전 줄거리, 아주 자세히 살펴보기

**1. 굶주림에 지쳐 형을 찾아간 흥부**
흥부 가족은 너무 가난해서 하루 세 끼 밥 먹는 게 소원이었어요. 흥부 아내가 "부질없는 청렴 말고 형님에게 가서 쌀이라도 얻어오세요"라고 애원하자, 흥부는 (기꺼이 / 어쩔 수 없이) 길을 나섭니다. 그는 찢어진 옷에 낡은 짚신을 신고 허름한 차림으로 형 놀부의 집으로 향해요. 이 모습을 보면 흥부가 얼마나 가난한지 한눈에 알 수 있죠.

**2. 얄미운 놀부의 매몰찬 거절**
흥부가 힘들게 놀부 집에 도착하자, 놀부는 "네가 누군데 우리 집에 왔냐"며 흥부를 (모른 척합니다 / 반갑게 맞이합니다). 흥부가 굶주린 자식들 이야기를 하며 제발 쌀 한 되만 달라고 애원하지만, 놀부는 자신의 집 앞에 산처럼 쌓인 쌀가마니와 곡식 더미를 하나하나 열거하며 "너 주자고 이걸 허물 순 없다"고 매정하게 거절합니다. 그러고는 하인 마당쇠를 불러 흥부를 (돕게 하고 / 몽둥이로 때려) 내쫓아요.

**3. 주걱으로 맞은 뺨, 그런데…**
매를 맞고 쫓겨난 흥부는 혹시나 하는 마음에 부엌으로 갑니다. 그때 놀부 아내가 밥을 푸고 있었는데, 흥부는 그 밥 냄새를 맡고 "형수님, 밥 한 술만 주십시오"라고 애원하죠. 하지만 놀부 아내는 "남녀유별한데 어딜 들어오느냐"며 (매몰차게 / 정중하게) 흥부를 내쫓습니다. 이때 흥부는 뺨에 묻은 밥알을 훔쳐 먹으며 "아주머니는 뺨을 쳐도 먹을 것을 주시니 감사하다"며 한 뺨 더 때려달라고 말해요. 이 장면은 슬프고 비극적이지만, 흥부의 순수함과 (부정적인 / 긍정적인) 태도 때문에 오히려 웃음이 터져 나오게 만든답니다.

**4. 복을 부르는 선행, 박씨를 얻다**
이렇게 형에게도 도움을 받지 못한 흥부는 다시 힘겨운 삶을 살아갑니다. 그러던 어느 날, 흥부는 구렁이에게 다리가 부러진 제비 새끼를 발견하고 정성껏 (치료해 줍니다 / 외면합니다). 다음 해에 그 제비는 흥부에게 보답하기 위해 '박씨' 하나를 물어다 줍니다. 흥부가 그 박을 심자, 박 속에서 온갖 귀한 보물들이 쏟아져 나와 흥부는 큰 부자가 돼요.

**5. 똑같이 따라 하는 놀부, 그런데…**
흥부가 부자가 되었다는 소문을 들은 놀부는 욕심에 눈이 멀어 흥부처럼 부자가 되려 합니다. 그는 (멀쩡한 제비 새끼 / 병든 제비 새끼)를 잡아다가 일부러 다리를 부러뜨리는 끔찍한 짓을 저질러요. 흥부의 선행을 (흉내 낸 / 비웃은) 거죠. 제비는 강남으로 돌아가 이 사실을 황제에게 알리고, 황제는 놀부에게 벌을 주기 위해 '보수표', 즉 '원수를 갚는 박'이라는 글씨가 새겨진 박씨를 보냅니다. 놀부는 이 박씨를 심고, 박을 타자 박 속에서 온갖 무서운 요괴들과 재앙이 쏟아져 나와 놀부는 재산을 모두 잃고 벌을 받게 됩니다.`,
            fullText: `흥부 마음 인후하여 청산유수와 곤륜옥결이라. 성덕을 본받고 악인을 저어하며 물욕에 탐이 없고 주색에 무심하니 마음이 이러하매 부귀를 바랄쏘냐? 흥부 아내 하는 말이,
"애고 여봅소, 부질없는 청렴 맙소, 안자의 가난함은 주린 염치로 서른에 일찍 죽고, 백이숙제는 주린 염치로 청루 소년이 웃었으니, 부질없는 청렴 말고 저 자식들 굶겨 죽이겠으니, 아주버님네 집에 가서 쌀이 되나 벼가 되나 얻어 옵소."
흥부가 하는 말이,
"형님이 음식 끝을 보면 사촌을 몰라보고 똥 싸도록 때리는데, 그 매를 뉘 아들놈이 맞는단 말이오?"
"애고 동냥은 못 준들 쪽박조차 깨칠쏜가. 맞으나 아니 맞으나 쏘아나 본다고 건너가 봅소."

흥부 이 말을 듣고 형의 집에 건너갈 제, 치장을 볼작시면, 편자 없는 헌 망건에 박쪼가리 관자 달고 물렛줄로 당끈 달아 대가리 터지게 동이고, 깃만 남은 중치막, 동강 이은 헌 술띠를 흉복통에 눌러 띠고, 떨어진 헌 고의에 칡 노끈 대님 매고, 헌 짚신 감발하고, 세살 부채 손에 쥐고, 서 홉들이 오망자루 꽁무니에 비슥 차고, 바람맞은 병인같이, 잘 쓰는 대비같이, 어슥비슥 건너 달아 형의 집에 들어가서 전후좌우 바라보니, 앞노적, 뒷노적, 멍에 노적 담불담불 쌓였으니, 흥부 마음 즐거우나 놀부 심사 무거하여 형제끼리 내외하여 구박이 태심하니 흥부가 하릴없어 뜰아래서 문안하니 놀부가 묻는 말이,

"네가 뉜고?"
"내가 흥부요."
"흥부가 뉘 아들인가?"
"애고 형님, 이것이 웬 말이오? 비옵니다. 형님 전에 비옵니다. 세끼 굶어 누운 자식 살려 낼 길 전혀 없으니 쌀이 되나 벼가 되나 양단간에 주시면 품을 판들 못 갚으며 일을 한들 못 갚을까. 부디 옛일을 생각하여 사람을 살려 주오."
애걸하니, 놀부 놈의 거동 보소. 성난 눈을 부릅뜨고 볼을 치며 호령하되,
"너도 염치없다. 내 말을 들어 보아라. '하늘은 녹 없는 사람을 내지 않으며, 땅은 이름 없는 풀을 내지 않는다.' 네 복을 누굴 주고 나를 이리 보채느냐? 쌀이 있다 한들 너 주자고 노적 헐며, 벼가 많이 있다 한들 너 주자고 섬을 헐며, 돈이 많이 있다 한들 궤에 가득 든 것을 문을 열랴."

흥부 하는 말이,
"아무리 그러실지라도 죽는 동생 살려 주오."
놀부 화를 버럭 내어 벼락같은 소리로 하인 마당쇠를 부 르니 마당쇠가,
"예"
하고 나오거늘, 놀부 분분하되,
"이놈아, 뒤 광문 열고 들어가면 저편에 보리 쌓은 더미 있지?" 이때 흥부 그 말 듣고 내심에, '옳다! 우리 형님이 보리 말이나 주시려나 보다.' 하고 은근히 기꺼하더니, 놀부놈이 마당쇠를 시켜 보리섬 뒤에 두었던 돝자루 묶음을 내놓고 손에 맞는 대로 골라 잡더니 그만 달려들어 흥부 뒤꼭지를 잔뜩 훔쳐 쥐고 몽둥 이로 함부로 치는데, 마치 손 챈 스님의 비질하듯, 상좌 중 이 법고 치듯 아아 탕탕 두드리니, 흥부 울며 하는 말이, "에고 형님, 이것이 웬일이오? 방약무인(傍若無人) 도척* 이도 이에서 성인이요 무거불측(無據不測) 관숙*이도 이에서는 군자로다. 우리 형제 어찌하여 이렇게 하오? 아니 주면 그만이지 때리기는 무슨 일인고, 에고 어머니, 나 죽소!"
놀부의 모진 마음 그래도 그치지 아니하고 지끈지끈 함부로 치다가 제 기운에 못 이겨 몽둥이를 내던지고 숨을 헐떡이며,
"이놈, 내 눈앞에서 뵈지 마라."
하고 사명으로 분분히 들어가며 문을 벼락같이 닫으니, 이때 흥부는 어찌 맞았던지 일신이 노릇하여 돌아갈 마음 그지없건만, 그중에도 형수나 보고 가려고 엉금엉금 기어 부엌 근처로 가니 놀부 아내가 마침 밥을 푸는 지라. 흥부가 매 맞는 것은 고사하고 여러 날 굶은 창자에 밥 냄새 맡으니 오장이 뒤집히어,
"에고, 형수씨, 밥 한 술만 주오. 이 동생 살려 주오."
하며 부엌으로 뛰어들어가니, 이년 또한 몹쓸 년이라 와라 돌아서며 하는 말이,
"남녀가 유별한데 어디를 들어오노?"
하며 밥 푸던 주걱으로 흥부의 바른 뺨을 지끈 때리니 흥부가 그 뺨 한 번을 맞은 즉 두 눈에 불이 화끈하며 정신이 어질하다가 뺨을 쓸며시 만져보니 밥이 뺨따귀에 붙었 는지라 일변 입으로 훔쳐 넣으며 하는 말이,
"아주머님은 뺨을 쳐도 엿여 먹여 가시니 감사한 말을 어찌 다 하오리까. 수고스럽지만은 이 뺨마저 쳐 주시오, 밥 많이 붙은 주걱으로. 그 밥 갖다가 아이들 구경이나 시키겠소."
이 몹쓸 년이 밥 쓸 년이 밥 주걱은 놓고 밥 그릇쟁이로 흥부를 흠씬 때려 놓으니, 흥부 아프단 말도 못하고 하릴없이 통곡하며 돌아오니 천지가 망망하더라.
(중략)
흥부 아내 생각에 시형 내외 마음을 짐작할지라.
"그만두시오, 알겠소. 형님 속도 내가 알고 시아주버니 속도 내가 아오. 뭣 낫, 쌀 서 말이 무엇이오. 내게다 그런 말을 하시오?"
하며 자기 남편을 보니 유혈이 낭자하여 얼굴이 모두 붓고 온몸을 만져보니 성한 곳이 바이 없으니, 흥부 아내 기가 막히어 땅에 펄쩍 주저앉으며,
"에고, 이것이 웬일인가, 가기 싫다 하는 가장 내말 어려워 가시더니 저 모양이 웬일이오, 팔자 그른 이 몹쓸년 가장 하나 못 섬기고 이런 광경 당하게 하니 잠시인들 살아 무얼 하리. 모질고 악한 양반, 구산같이 쌓인 곡식 누구 주자 아끼어 서리 몹시 친단 말고."
흥부의 착한 마음 형의 말은 아니하고,
"여보 마누라, 슬퍼 마소. 가난 구제는 나라에서도 못 한다 하니 형님인들 어찌하시나. 우리 양주 품이나 팔아 살아가세."
흥부 아내 응하고 서로 나서 품을 판다. 용정(舂精)*하여 방아 찧기, 술집에 가 술 거르기, 초상난 집 제복 짓기, 사고 있는 집 그릇 닦기, 굿하는 집 떡 만들기, 시골발치 오줌 치기, 해병하면 나물 캐기, 춘모 갈아 보리 놓기, 온 가지로 품을 팔고, 흥 부는 이월동풍 가래질하기, 삼사월에 부침질하기, 일등 전답 무논 갈기, 이 집 저 집 이엉 엮기, 날 궂은 날 멍석 맺기, 시장 갓에 나무 베기, 무곡 주인 역인 서기, 각 읍 주인 섬길 가기, 술값 먹고 말짐 싣기, 오 푼 받고 마찰 박기, 두 푼 받고 돝 재치기, 한 푼 받고 비 매기, 식전이면 마당 쓸기, 이웃집 물 긷기, 진주 감영 돋짐 지기, 대구 감영 태전 지기, 온 가지로 다하여도 굶기를 밥 먹는 듯하여 살길이 없는지라.

[중략 부분의 줄거리] 어렵게 살던 흥부는 어느 날 구렁이의 습격을 받아 다리가 부러진 제비 새끼를 구해 주고 박씨를 얻어 큰 부자가 된다.

놀부 놈의 거동 보소. 동지섣달부터 제비를 기다린다. 그물 막대 둘러메고 제비를 몰러 갈 제, 한 곳을 바라보니 한 짐승이 떠서 들어오니 놀부 놈이 보고,
"제비 인제 온다."

하고 보니, 태백산 갈가마귀 차돌도 못 얻어먹고 주려 청천에 높이 떠 갈곡갈곡 울고 가니, 놀부 눈을 멀겋게 뜨고 보다가 하릴없어 동네 집으로 다니면서 제비를 제 집으로 몰아들이되 제비가 아니 온다.
그달 저 달 다 지내고 삼월 삼일 다다르니 강남서 나온 제비 옛집을 찾으려 하고 오락가락 넘놀 적에 놀부 사면에 제비 집을 지어 놓고 제비를 들이모니, 그중 팔자 사나운 제비 하나가 놀부 집에 흙을 물어 집을 짓고 알을 낳아 안으려 할 제, 놀부 놈이 주야로 제비 집 앞에 대령하여 가끔가끔 만져 보니 알이 다 옳고 다만 하나 깨었는지라. 날기 공부 힘쓸 제 구렁배암 아니 오니 놀부 민망 답답하여 제 손으로 제비 새끼를 잡아 내려 두 발목을 자끈 부러뜨리고 제가 깜짝 놀라 이른 말이, "가련하다. 이 제비야." 하고 조기 껍질을 얻어 찬찬 동여 뱃놈의 닻줄 감듯 삼층 얼레 연줄 감듯 하여 제집에 얹어 두었더니, 십여 일 뒤에 그 제비가 구월 구일을 당하여 두 날개를 펼쳐 강남으로 들어가니 강남 황제 각처 제비를 점고할 제, 이 제비가 다리 절고 들어와 복지하니, 황제 제신으로 하여금,

"그 연고를 사실하여 아뢰라."
하시니, 제비 아뢰되,
"작년에 웬 박씨를 내어 보내어 흥부가 부자 되었다 하여 그 형 놀부 놈이 나를 여차여차하여
절뚝발이가 되게 하였사오니, 이 원수를 어찌하여 갚고자 하나이다."
황제가 이 말을 들으시고 대경하사 가라사대,
"이놈 이제 전답 재물이 여유롭되 동기를 모르고 오륜에 벗어난 놈을 그저 두지 못할 것이요, 또한 네 원수를 갚아 주리라."
하고 박씨 하나를 '보수표(報讐瓢)'라 금자로 새겨 주더라.

작자 미상, 「흥부전」-

* *도척: 춘추시대 노나라의 큰 도적
* *관숙: 주나라 무왕의 아우. 무왕이 죽은 뒤 주공을 모함하고 상나라 주의 아들 무경과 함께 반란을 일으켰다.
* *용정: 곡식을 찧음.
* *보수표: 원수를 갚는 박.

---

## **1️⃣ 딥리서치: 출제 포인트 및 핵심 정리 🧠**

**[작품 해제]**

이 작품은 조선 후기에 형성된 작자 미상의 판소리계 소설로, 한국 문학사에서 가장 대중적인 고전 중 하나입니다. 선량한 동생 흥부와 악한 형 놀부의 이야기를 통해 (권선징악 / 인과응보)이라는 보편적 주제를 명확하게 드러냅니다. 표면적으로는 형제간의 우애와 도덕적 교훈을 강조하지만, 그 이면에는 조선 후기 사회의 급격한 변화, 즉 신흥 부유층의 비인간적인 행태와 빈농의 처참한 삶을 (낭만적으로 / 사실적으로) 그려내며 당대 사회를 (풍자하고 / 긍정하고) 있습니다.

**[핵심 정리 표]**

| 구분 | 내용 |
| :---- | :---- |
| **갈래** | 고전 소설, (판소리계 소설 / 서사 무가), 영웅 소설 |
| **성격** | 해학적, 풍자적, (교훈적 / 전기적) |
| **배경** | 시간적: 조선 후기 공간적: (서울 / 농촌 마을) |
| **시점** | (1인칭 주인공 / 전지적 작가) 시점 ➕ 서술자의 개입(편집자적 논평)이 자주 드러남 |
| **주제** | 형제간의 우애와 (권선징악 / 인과율) 사상 |
| **특징** | 1. 판소리 사설이 정착된 것으로, 운문체와 (산문체 / 율문체)가 혼합되어 있음. 2. 선과 악이 분명한 **전형적인 인물**을 통해 주제를 효과적으로 드러냄. 3. 현실적(가난한 삶) 내용과 (비현실적 / 교훈적) 내용이 조화롭게 나타남. 4. 등장인물의 대화에 해학(諧謔)과 풍자(諷刺)가 잘 드러남. 5. 인물의 행동과 심리를 (직접적 / 간접적)으로 제시하여 생동감을 부여함. |

**[전체 줄거리 및 출제 포인트]**

[발단] 착한 흥부와 악한 놀부

흥부는 마음이 (인색하여 / 인후하여) 가난하지만 욕심 없이 살아간다. 흥부 아내는 굶주리는 자식들을 위해 남편에게 형님 집으로 가서 쌀을 얻어오라고 설득한다. 흥부는 형님인 놀부의 모진 성품을 알기에 망설이지만, 아내의 간절한 부탁에 (용기를 내어 / 마지못해) 놀부의 집으로 향한다.

[전개] 놀부의 비인간성과 흥부의 수난

치장이라곤 변변치 않은 흥부의 모습은 (풍요로운 / 비참한) 가난을 단적으로 보여준다. 흥부가 놀부의 집에 도착하자, 놀부는 그의 모습을 보고 형제끼리도 (정겹게 / 내외하여) 흥부를 구박한다. 흥부가 굶주린 자식들을 위해 쌀 한 되만 달라고 애원하지만, 놀부는 자신의 재산을 (열거하고 / 나열하고) 과시하며 흥부를 매몰차게 거절한다. 놀부는 급기야 하인 마당쇠를 시켜 (보리섬 / 돝자루)를 내오게 한 뒤, 흥부를 무자비하게 구타한다.

[위기] 주걱으로 맞은 뺨과 해학적 태도

놀부의 매를 맞고 쫓겨난 흥부는 혹시나 하는 마음에 부엌으로 간다. 밥 냄새를 맡고 오장이 뒤집혀 놀부 아내에게 밥 한 술을 애걸한다. 하지만 놀부 아내는 "남녀가 유별하다"며 (밥그릇 / 밥 주걱)으로 흥부의 뺨을 때린다. 이 비극적인 상황에서 흥부는 "아주머님은 뺨을 쳐도 엿여 먹여 가시니"라고 말하며 밥알이 묻은 뺨을 (닦아내고 / 훔쳐 넣어) 웃음을 자아낸다. 이는 흥부의 (비인간성 / 낙천성)과 해학적인 성품을 보여주는 동시에, 당시 서민들의 고통을 웃음으로 승화시키려는 건강한 삶의 태도를 드러낸다.

[절정] 흥부의 선행과 놀부의 모방

(놀부 / 흥부)는 어느 날 구렁이에게 다리를 물린 제비를 구해주고, 그 제비가 물어다 준 박씨를 심어 큰 부자가 된다. 이 소문을 들은 놀부는 동지섣달부터 제비를 기다리며 흥부의 행동을 (본받아 / 모방하여) 부자가 되려고 한다. 그는 자연스럽게 다친 제비를 기다리는 흥부와 달리, 멀쩡한 제비 새끼를 잡아다 (인위적으로 / 우연히) 다리를 부러뜨리는 악행을 저지른다.

[결말] 놀부의 악행에 대한 응징

놀부에게 다리가 부러진 제비는 강남으로 돌아가 (강남 황제 / 강남 부자)에게 놀부의 만행을 고한다. 황제는 놀부의 악행에 (탄복하고 / 분개하고), 제비에게 놀부에게 '보수표(報讐瓢)'를 가져다주라고 한다. 이는 선행에 대한 보상과 악행에 대한 (보상 / 응징)이라는 권선징악의 주제를 향한 결정적인 복선으로, 결국 놀부가 박을 타서 징벌을 받게 될 것임을 암시한다.

---

## **2️⃣ 작품 미리보기: 배경지식의 첫걸음 📝**

# 작가와 시대 이야기

흥부전은 작가가 누구인지 알려지지 않은 '작자 미상'의 작품이에요. 조선 후기에 평범한 사람들의 삶을 노래하던 '판소리'로 불리다가 나중에 글로 쓰이면서 소설이 되었죠. 당시 조선은 신분제도가 흔들리고 농민들이 힘겹게 살아가던 시기였어요. 땅을 잃고 가난해진 농민들은 흥부처럼 가난과 싸워야 했고, 일부는 놀부처럼 돈을 모아 새로운 부자가 되기도 했답니다. 이 소설은 바로 그 시대의 모습을 거울처럼 보여주면서, 착한 사람은 복을 받고 나쁜 사람은 벌을 받는다는 (교훈 / 사실)을 이야기하고 있어요.

# 흥부전 줄거리, 아주 자세히 살펴보기

1. 굶주림에 지쳐 형을 찾아간 흥부
   흥부 가족은 너무 가난해서 하루 세 끼 밥 먹는 게 소원이었어요. 흥부 아내가 "부질없는 청렴 말고 형님에게 가서 쌀이라도 얻어오세요"라고 애원하자, 흥부는 (용기를 내어 / 마지못해) 길을 나섭니다. 그는 찢어진 옷에 낡은 짚신을 신고 허름한 차림으로 형 놀부의 집으로 향해요. 이 모습을 보면 흥부가 얼마나 가난한지 한눈에 알 수 있죠.
2. 얄미운 놀부의 매몰찬 거절
   흥부가 힘들게 놀부 집에 도착하자, 놀부는 "네가 누군데 우리 집에 왔냐"며 흥부를 (모른 척합니다 / 반갑게 맞이합니다). 흥부가 굶주린 자식들 이야기를 하며 제발 쌀 한 되만 달라고 애원하지만, 놀부는 자신의 집 앞에 산처럼 쌓인 쌀가마니와 곡식 더미를 하나하나 열거하며 "너 주자고 이걸 허물 순 없다"고 매정하게 거절합니다. 그러고는 하인 마당쇠를 불러 흥부를 (돕게 하고 / 몽둥이로 때려) 내쫓아요.
3. 주걱으로 맞은 뺨, 그런데…
   매를 맞고 쫓겨난 흥부는 혹시나 하는 마음에 부엌으로 갑니다. 그때 놀부 아내가 밥을 푸고 있었는데, 흥부는 그 밥 냄새를 맡고 "형수님, 밥 한 술만 주십시오"라고 애원하죠. 하지만 놀부 아내는 "남녀유별한데 어딜 들어오느냐"며 (밥 주걱 / 밥그릇)으로 흥부의 뺨을 때립니다. 이때 흥부는 뺨에 묻은 밥알을 훔쳐 먹으며 "아주머니는 뺨을 쳐도 먹을 것을 주시니 감사하다"며 한 뺨 더 때려달라고 말해요. 이 장면은 슬프고 비극적이지만, 흥부의 순수함과 (부정적인 / 긍정적인) 태도 때문에 오히려 웃음이 터져 나오게 만든답니다.
4. 복을 부르는 선행, 박씨를 얻다
   이렇게 형에게도 도움을 받지 못한 흥부는 다시 힘겨운 삶을 살아갑니다. 그러던 어느 날, 흥부는 구렁이에게 다리가 부러진 제비 새끼를 발견하고 정성껏 (치료해 줍니다 / 외면합니다). 다음 해에 그 제비는 흥부에게 보답하기 위해 '박씨' 하나를 물어다 줍니다. 흥부가 그 박을 심자, 박 속에서 온갖 귀한 보물들이 쏟아져 나와 흥부는 큰 부자가 돼요.
5. 똑같이 따라 하는 놀부, 그런데…
   흥부가 부자가 되었다는 소문을 들은 놀부는 욕심에 눈이 멀어 흥부처럼 부자가 되려 합니다. 그는 (멀쩡한 제비 새끼 / 병든 제비 새끼)를 잡아다가 일부러 다리를 부러뜨리는 끔찍한 짓을 저질러요. 흥부의 선행을 (흉내 낸 / 비웃은) 거죠. 제비는 강남으로 돌아가 이 사실을 황제에게 알리고, 황제는 놀부에게 벌을 주기 위해 '보수표', 즉 '원수를 갚는 박'이라는 글씨가 새겨진 박씨를 보냅니다. 놀부는 이 박씨를 심고, 박을 타자 박 속에서 온갖 무서운 요괴들과 재앙이 쏟아져 나와 놀부는 재산을 모두 잃고 벌을 받게 됩니다.`
        };

        const vocabularyData = [
            {
                word: "인후(仁厚)",
                meaning: "마음이 너그럽고 인정이 두터운 상태",
                type: "핵심 인물 속성",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"인후(仁厚)"의 의미는?',
                        correct: "마음이 너그럽고 인정이 두터운 상태",
                        distractors: ["이익만을 좇고 인정이 없는 상태", "슬픔을 웃음으로 승화하는 태도", "형제끼리 서먹하게 대하는 태도"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"마음이 너그럽고 인정이 두터운 상태"를 나타내는 용어는?',
                        correct: "인후(仁厚)",
                        distractors: ["해학(諧謔)", "모진 마음", "내외"]
                    }
                ]
            },
            {
                word: "해학(諧謔)",
                meaning: "슬픔을 웃음으로 승화시키는 낙천적인 성격",
                type: "핵심 인물 속성",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"해학(諧謔)"의 의미는?',
                        correct: "슬픔을 웃음으로 승화시키는 낙천적인 성격",
                        distractors: ["마음이 너그럽고 인정이 두터운 성격", "이익만을 좇고 인정이 없는 성격", "슬픔에 빠져 의욕을 잃는 성격"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"슬픔을 웃음으로 승화시키는 낙천적인 성격"을 나타내는 용어는?',
                        correct: "해학(諧謔)",
                        distractors: ["인후(仁厚)", "풍자(諷刺)", "권선징악(勸善懲惡)"]
                    }
                ]
            },
            {
                word: "모진 마음",
                meaning: "이익만을 좇고 인정이 없는 잔혹하고 탐욕스러운 성격",
                type: "핵심 인물 속성",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"모진 마음"의 의미는?',
                        correct: "이익만을 좇고 인정이 없는 잔혹하고 탐욕스러운 성격",
                        distractors: ["마음이 너그럽고 인정이 두터운 성격", "고집이 세고 융통성이 없는 성격", "슬픔을 웃음으로 승화하는 성격"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"이익만을 좇고 인정이 없는 잔혹하고 탐욕스러운 성격"을 나타내는 말은?',
                        correct: "모진 마음",
                        distractors: ["인후한 마음", "청렴한 마음", "해학적 태도"]
                    }
                ]
            },
            {
                word: "치장",
                meaning: "흥부의 가난한 처지를 상징적으로 보여주는 옷차림",
                type: "사건 및 상황",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '작품에서 "치장"이 의미하는 것은?',
                        correct: "흥부의 가난한 처지를 반어적으로 보여주는 옷차림",
                        distractors: ["형님 집에 가기 위해 성장하게 차려입은 옷", "제사를 지내기 위한 의복", "놀부의 부유함을 드러내는 의복"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"흥부의 가난한 처지를 반어적으로 보여주는 옷차림"을 가리키는 말은?',
                        correct: "치장",
                        distractors: ["중치막", "관자", "망건"]
                    }
                ]
            },
            {
                word: "새끼 낳은 돼지",
                meaning: "놀부가 동생에게 먹다 남은 술 지게미도 주지 않는 이유가 된 짐승",
                type: "사건 및 상황",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"새끼 낳은 돼지"가 작품에서 의미하는 것은?',
                        correct: "놀부가 동생에게 먹다 남은 술 지게미도 주지 않는 이유가 된 짐승",
                        distractors: ["흥부가 키우던 가축", "제비를 공격한 동물", "놀부가 희생 제물로 바친 동물"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"놀부가 동생에게 먹다 남은 술 지게미도 주지 않는 이유가 된 짐승"은?',
                        correct: "새끼 낳은 돼지",
                        distractors: ["구렁이", "제비", "갈가마귀"]
                    }
                ]
            },
            {
                word: "몽둥이",
                meaning: "놀부가 흥부를 때리기 위해 사용한 도구",
                type: "사건 및 상황",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '작품에서 "몽둥이"의 용도는?',
                        correct: "놀부가 흥부를 때리기 위해 사용한 도구",
                        distractors: ["흥부가 품을 팔 때 사용한 연장", "놀부가 제비를 잡기 위해 사용한 도구", "흥부가 박을 깨기 위해 사용한 도구"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"놀부가 흥부를 때리기 위해 사용한 도구"는?',
                        correct: "몽둥이",
                        distractors: ["돝자루", "밥 주걱", "보리섬"]
                    }
                ]
            },
            {
                word: "내외",
                meaning: "윗사람이 아랫사람을 대할 때 말이나 행동을 어려워함",
                type: "고전 어휘",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"내외"의 의미는?',
                        correct: "윗사람이 아랫사람을 대할 때 말이나 행동을 어려워함",
                        distractors: ["부부 사이의 애정 어린 호칭", "남녀가 유별함을 강조하는 말", "형제끼리 다정하게 대하는 태도"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"윗사람이 아랫사람을 대할 때 말이나 행동을 어려워함"을 나타내는 말은?',
                        correct: "내외",
                        distractors: ["구박", "호령", "문안"]
                    }
                ]
            },
            {
                word: "일신이 노릇하여",
                meaning: "몸을 움직이지 못하게 된 상태",
                type: "고전 어휘",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"일신이 노릇하여"의 의미는?',
                        correct: "몸을 움직이지 못하게 된 상태",
                        distractors: ["몸이 날렵하고 민첩한 상태", "정신이 맑고 깨끗한 상태", "온몸에 힘이 넘치는 상태"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"몸을 움직이지 못하게 된 상태"를 나타내는 표현은?',
                        correct: "일신이 노릇하여",
                        distractors: ["하릴없이", "엉금엉금", "천지가 망망하더라"]
                    }
                ]
            },
            {
                word: "흠씬 때려놓으니",
                meaning: "마구 때리다",
                type: "고전 어휘",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"흠씬 때려놓으니"의 의미는?',
                        correct: "마구 때리다",
                        distractors: ["살짝 때리다", "정성껏 치료하다", "부드럽게 쓰다듬다"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"마구 때리다"를 나타내는 표현은?',
                        correct: "흠씬 때려놓으니",
                        distractors: ["훔쳐 넣으며", "엉금엉금", "벼락같이"]
                    }
                ]
            },
            {
                word: "하릴없이",
                meaning: "아무리 애써도 소용없다는 뜻으로, 달리 도리가 없는 상태",
                type: "고전 어휘",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"하릴없이"의 의미는?',
                        correct: "아무리 애써도 소용없다는 뜻으로, 달리 도리가 없는 상태",
                        distractors: ["기쁜 마음으로 즐겁게", "화가 나서 분노하는 상태", "계획적으로 차근차근"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"아무리 애써도 소용없다는 뜻으로, 달리 도리가 없는 상태"를 나타내는 말은?',
                        correct: "하릴없이",
                        distractors: ["민망하여", "분분히", "대경하사"]
                    }
                ]
            },
            {
                word: "천지",
                meaning: "사람이 사는 세상",
                type: "고전 어휘",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"천지"의 의미는?',
                        correct: "사람이 사는 세상",
                        distractors: ["하늘과 땅의 거리", "신들이 사는 공간", "죽은 자들의 세계"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"사람이 사는 세상"을 나타내는 말은?',
                        correct: "천지",
                        distractors: ["강남", "노적", "광"]
                    }
                ]
            },
            {
                word: "보수표(報讐瓢)",
                meaning: "원수를 갚는 박",
                type: "고전 어휘",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"보수표(報讐瓢)"의 의미는?',
                        correct: "원수를 갚는 박",
                        distractors: ["복을 주는 박", "재물이 나오는 박", "약을 담는 박"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"원수를 갚는 박"을 나타내는 말은?',
                        correct: "보수표(報讐瓢)",
                        distractors: ["복표(福瓢)", "재표(財瓢)", "약표(藥瓢)"]
                    }
                ]
            },
            {
                word: "방약무인(傍若無人)",
                meaning: "곁에 아무도 없는 것처럼 제멋대로 행동함",
                type: "한자 성어",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"방약무인(傍若無人)"의 의미는?',
                        correct: "곁에 아무도 없는 것처럼 제멋대로 행동함",
                        distractors: ["근거가 없고 헤아릴 수 없음", "좋은 일을 권하고 나쁜 일을 징계함", "형제간의 우애가 깊음"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"곁에 아무도 없는 것처럼 제멋대로 행동함"을 나타내는 한자 성어는?',
                        correct: "방약무인(傍若無人)",
                        distractors: ["무거불측(無據不測)", "권선징악(勸善懲惡)", "형제유의(兄弟有義)"]
                    }
                ]
            },
            {
                word: "무거불측(無據不測)",
                meaning: "근거가 없고 헤아릴 수 없다는 뜻으로, 놀부의 인물됨을 풍자함",
                type: "한자 성어",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"무거불측(無據不測)"의 의미는?',
                        correct: "근거가 없고 헤아릴 수 없다는 뜻으로, 놀부의 인물됨을 풍자함",
                        distractors: ["곁에 아무도 없는 것처럼 제멋대로 행동함", "마음이 너그럽고 인정이 두터움", "착한 일을 권하고 악한 일을 징계함"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"근거가 없고 헤아릴 수 없다는 뜻으로, 놀부의 인물됨을 풍자함"을 나타내는 한자 성어는?',
                        correct: "무거불측(無據不測)",
                        distractors: ["방약무인(傍若無人)", "권선징악(勸善懲惡)", "인후성덕(仁厚聖德)"]
                    }
                ]
            },
            {
                word: "권선징악(勸善懲惡)",
                meaning: "좋은 일을 권하고 나쁜 일을 징계함. 이 작품의 주제 의식",
                type: "한자 성어",
                questions: [
                    {
                        type: "word-to-meaning",
                        question: '"권선징악(勸善懲惡)"의 의미는?',
                        correct: "좋은 일을 권하고 나쁜 일을 징계함",
                        distractors: ["곁에 아무도 없는 것처럼 제멋대로 행동함", "근거가 없고 헤아릴 수 없음", "형제간의 우애가 깊고 인정이 두터움"]
                    },
                    {
                        type: "meaning-to-word",
                        question: '"좋은 일을 권하고 나쁜 일을 징계함"을 나타내는 한자 성어는?',
                        correct: "권선징악(勸善懲惡)",
                        distractors: ["방약무인(傍若無人)", "무거불측(無據不測)", "형제우의(兄弟友誼)"]
                    }
                ]
            }
        ];


                const sentenceData = [
    // 문장 독해력 강화 훈련 (7문제)
    {
        sentence: "흥부가 매 맞는 것은 고사하고 여러 날 굶은 창자에 밥 냄새 맡으니 오장이 뒤집히어",
        question: "[가리키는 말 바꿔 읽기] '오장이 뒤집히어'는 흥부가 어떤 상태를 느끼고 있음을 보여줍니까?",
        correctAnswer: "극심한 허기",
        distractors: ["극심한 고통", "극심한 분노", "극심한 슬픔"]
    },
    {
        sentence: "\"에고, 형수씨, 밥 한 술만 주오. 이 동생 살려 주오.\"",
        question: "[서술어 중심 호응 찾기] 흥부가 \"이 동생 살려 주오\"라고 말하는 이유는?",
        correctAnswer: "굶주림으로 인해 죽을 것 같았기 때문",
        distractors: ["놀부에게 맞아서 죽을 것 같았기 때문", "형제애를 강조하기 위해", "놀부 아내의 동정심을 얻기 위해"]
    },
    {
        sentence: "이년 또한 몹쓸 년이라 와라 돌아서며 하는 말이, \"남녀가 유별한데 어디를 들어오노?\"",
        question: "[인물 지칭어 파악] '이년'이 가리키는 인물은 누구입니까?",
        correctAnswer: "놀부 아내",
        distractors: ["흥부 아내", "흥부", "마당쇠"]
    },
    {
        sentence: "\"남녀가 유별한데 어디를 들어오노?\"",
        question: "[숨은 말 찾아 읽기] 이 말에 숨겨진 놀부 아내의 진짜 의도는?",
        correctAnswer: "흥부를 밥 주지 않고 쫓아내려는 핑계",
        distractors: ["유교적 도리를 지키려는 순수한 의도", "흥부의 안전을 걱정하는 배려", "부엌의 정결함을 유지하려는 노력"]
    },
    {
        sentence: "흥부가 그 뺨 한 번을 맞은 즉 두 눈에 불이 화끈하며 정신이 어질하다가",
        question: "[개념 관련 표현 파악] '두 눈에 불이 화끈하며 정신이 어질하다'는 것은 흥부가 어떤 상태임을 보여줍니까?",
        correctAnswer: "충격으로 정신을 차리지 못하고 있음",
        distractors: ["분노를 느끼고 있음", "기쁨에 겨워 있음", "두려움에 떨고 있음"]
    },
    {
        sentence: "\"아주머님은 뺨을 쳐도 엿여 먹여 가시니 감사한 말을 어찌 다 하오리까.\"",
        question: "[옛 말투 해석하기] \"엿여 먹여 가시니\"에서 '엿여'의 의미는?",
        correctAnswer: "엿(먹을 것)을 주듯",
        distractors: ["엿을 먹이듯(비유적으로 골탕 먹이다)", "엿처럼 달콤하게", "엿을 만들어"]
    },
    {
        sentence: "\"수고스럽지만은 이 뺨마저 쳐 주시오, 밥 많이 붙은 주걱으로.\"",
        question: "[의도 파악] 이 말에 담긴 흥부의 태도는?",
        correctAnswer: "해학적",
        distractors: ["풍자적", "비판적", "공격적"]
    },
    // 실전 대비 문제 (4문제)
    {
        sentence: "흥부 마음 인후하여 청산유수와 곤륜옥결이라.",
        question: "[표현 방식] 윗글에 대한 설명으로 가장 적절한 것은?",
        correctAnswer: "인물의 내면을 직접적으로 제시하여 인물의 성격을 드러내고 있다.",
        distractors: ["서술자가 인물에 대한 객관적인 평가를 배제하고 있다.", "등장인물의 행동이 현실적인 인과관계에 따라 긴밀하게 연결되고 있다.", "과거와 현재를 교차하는 입체적 구성 방식을 취하고 있다."]
    },
    {
        sentence: "뺨을 쓸며시 만져보니 밥이 뺨따귀에 붙었는지라 일변 입으로 훔쳐 넣으며",
        question: "[인물 이해] 흥부에 대한 설명으로 적절하지 않은 것은?",
        correctAnswer: "뺨에 묻은 밥풀을 떼어 먹는 행동은 그의 비극적 현실을 여과 없이 드러낸다.",
        distractors: ["극심한 가난 속에서도 착한 본성을 잃지 않는 인물이다.", "형의 집에 갈 때 초라한 옷차림은 그의 비참한 처지를 상징적으로 드러낸다.", "'마음이 인후하여'라는 서술을 통해 인물의 성격이 직접적으로 제시되고 있다."]
    },
    {
        sentence: "애걸하니, 놀부 놈의 거동 보소.",
        question: "[서술 특징] 이 장면의 서술상 특징은?",
        correctAnswer: "서술자가 작품 속에 직접 개입하여 독자에게 말을 거는 편집자적 논평이 드러나고 있다.",
        distractors: ["서술자가 인물의 내면 심리를 직접 서술하고 있다.", "서술자가 인물의 성격을 직접 평가하고 있다.", "서술자가 사건의 결과를 미리 예고하고 있다."]
    },
    {
        sentence: "바람맞은 병인같이, 잘 쓰는 대비같이 / 쌀이 많이 있다 한들 너 주자고 섭을 헐며... 콩 섬이나 주자 한들... / 놀부 화를 버럭 내어 벼락같은 소리로 하인 마당쇠를 부르니",
        question: "[표현 기법] 윗글에 사용된 표현 방식으로 적절한 것을 모두 고른 것은? ㄱ. 직유 ㄴ. 반복적 나열 ㄷ. 과장법",
        correctAnswer: "ㄱ, ㄴ, ㄷ 모두",
        distractors: ["ㄱ만", "ㄴ만", "ㄱ, ㄴ만"]
    }
        ];


        // 1단계 전용 변수
        let stage1Data = {
            currentQuestionIndex: 0,
            answeredQuestions: new Set(),
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 180,
            maxTime: 180
        };

        // 2단계 전용 변수
        let stage2Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 240,
            maxTime: 240
        };

        // 3단계 전용 변수
        let stage3Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            startTime: 0,
            timeRemaining: 100,
            maxTime: 100
        };

        // 공통 변수
        let timerInterval = null;
        let modalDragging = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let activeModal = null;
        let activeTimeout = null;
        let isProcessingClick = false;

        // 현재 단계에 따른 시간 관련 변수 (호환성 유지)
        let timeRemaining = 180;
        let maxTime = 180;

        // 전역 학습 시작 시간
        let globalStartTime = null;

        // 전체 학습 결과 저장
        const stageResults = {
            stage1: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage2: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage3: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage4: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] },
            stage5: { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] }
        };

        // 초기화
        function init() {
            // 전역 시작 시간 기록
            globalStartTime = Date.now();

            // Stage 1 초기화
            stage1Data.startTime = Date.now();
            timeRemaining = stage1Data.timeRemaining;
            maxTime = stage1Data.maxTime;

            // 1단계에서는 문제 텍스트만 표시 (전체 원문은 4단계, 5단계에서만 지문 보기 모달로 표시)
            renderStage1Questions();

            // passage-container 표시
            document.getElementById('passage-container').style.display = 'block';

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
            setupModalDrag();
        }

        // 1단계 지문 렌더링 (딥리서치와 작품 미리보기)
        function renderStage1Questions() {
            const container = document.getElementById('passage-container');
            let html = learningData.stage1Text;

            // 마크다운 처리 (하이라이트 처리 전에 먼저 실행)
            // 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^■\s+(.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (마크다운 테이블을 HTML 테이블로 변환)
            const tableRegex = /^\|.+\|$/gm;
            const tableMatches = [];
            let match;
            while ((match = tableRegex.exec(html)) !== null) {
                tableMatches.push(match.index);
            }

            if (tableMatches.length > 0) {
                // 테이블 라인들을 찾아서 그룹화
                let i = 0;
                while (i < tableMatches.length) {
                    let tableStart = tableMatches[i];
                    let tableEnd = tableMatches[i];
                    let j = i + 1;

                    // 연속된 테이블 라인 찾기
                    while (j < tableMatches.length && tableMatches[j] - tableEnd < 100) {
                        tableEnd = tableMatches[j];
                        j++;
                    }

                    // 테이블 텍스트 추출
                    let beforeTable = html.substring(0, tableStart);
                    let afterTable = html.substring(tableEnd + html.substring(tableEnd).indexOf('\n') + 1);
                    let tableText = html.substring(tableStart, tableEnd + html.substring(tableEnd).indexOf('\n'));

                    const lines = tableText.split('\n').filter(line => line.trim().startsWith('|'));

                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0;">';
                    let rowIndex = 0;

                    lines.forEach((line) => {
                        // 구분선 스킵
                        if (line.match(/^\|\s*:?-+:?\s*\|/)) return;

                        const cells = line.split('|').slice(1, -1); // 첫번째와 마지막 빈 요소 제거
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f8f9fa; font-weight: 600;' : '';

                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<${tag} style="border: 1px solid #ddd; padding: 12px; text-align: left; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHTML += '</tr>';
                        rowIndex++;
                    });

                    tableHTML += '</table>';
                    html = beforeTable + tableHTML + afterTable;

                    i = j;
                }
            }

            // 볼드 처리
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 하이라이트 처리 (마지막에 실행 - HTML 변환된 내용에 적용)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 지문 렌더링 (전체 원문 - 4단계, 5단계에서 사용)
        function renderPassage() {
            const container = document.getElementById('passage-container');
            let html = learningData.fullText;

            // 마크다운 처리 (하이라이트 처리 전에 먼저 실행)
            // 제목 처리
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^■ (.+)$/gm, '<h3>$1</h3>');

            // 테이블 처리 (마크다운 테이블을 HTML 테이블로 변환)
            const tableRegex = /^\|.+\|$/gm;
            const tableMatches = [];
            let match;
            while ((match = tableRegex.exec(html)) !== null) {
                tableMatches.push(match.index);
            }

            if (tableMatches.length > 0) {
                // 테이블 라인들을 찾아서 그룹화
                let i = 0;
                while (i < tableMatches.length) {
                    let tableStart = tableMatches[i];
                    let tableEnd = tableMatches[i];
                    let j = i + 1;

                    // 연속된 테이블 라인 찾기
                    while (j < tableMatches.length && tableMatches[j] - tableEnd < 100) {
                        tableEnd = tableMatches[j];
                        j++;
                    }

                    // 테이블 텍스트 추출
                    let beforeTable = html.substring(0, tableStart);
                    let afterTable = html.substring(tableEnd + html.substring(tableEnd).indexOf('\n') + 1);
                    let tableText = html.substring(tableStart, tableEnd + html.substring(tableEnd).indexOf('\n'));

                    const lines = tableText.split('\n').filter(line => line.trim().startsWith('|'));

                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0;">';
                    let rowIndex = 0;

                    lines.forEach((line) => {
                        // 구분선 스킵
                        if (line.match(/^\|\s*:?-+:?\s*\|/)) return;

                        const cells = line.split('|').slice(1, -1); // 첫번째와 마지막 빈 요소 제거
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f8f9fa; font-weight: 600;' : '';

                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<${tag} style="border: 1px solid #ddd; padding: 12px; text-align: left; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHTML += '</tr>';
                        rowIndex++;
                    });

                    tableHTML += '</table>';
                    html = beforeTable + tableHTML + afterTable;

                    i = j;
                }
            }

            // 볼드 처리
            html = html.replace(/\*\*([^<>]+?)\*\*/g, '<strong>$1</strong>');

            // 섹션 번호 처리 (1. 2. 3. 형태)
            html = html.replace(/^(\d+)\.\s+(.+구간.*)$/gm, function(match, num, text) {
                return `<div style="margin-top: 20px;"><span class="section-number">${num}.</span><strong>${text}</strong></div>`;
            });

            // 불릿 처리
            html = html.replace(/^[•·]\s+(.+)$/gm, function(match, content) {
                return `<div class="subsection">• ${content}</div>`;
            });

            // 하이라이트 처리 (마지막에 실행 - HTML 변환된 내용에 적용)
            learningData.questions.forEach((q, index) => {
                // 정규식 특수문자 이스케이프
                const escapedHighlight = q.highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(escapedHighlight);
                const highlightHTML = `<span class="highlight" data-question="${index}">${q.highlight}</span>`;
                // 첫 번째 매칭만 교체
                html = html.replace(regex, highlightHTML);
            });

            container.innerHTML = html;

            // 하이라이트 클릭 이벤트 등록 (PC와 모바일 모두 지원)
            document.querySelectorAll('.highlight').forEach(highlight => {
                let touchStartX = 0;
                let touchStartY = 0;

                const handleInteraction = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // 이미 처리 중이면 무시
                    if (isProcessingClick) return;
                    isProcessingClick = true;

                    const questionIndex = parseInt(this.getAttribute('data-question'));

                    // 클릭/터치 좌표 가져오기
                    let clientX, clientY;
                    if (e.type === 'touchend') {
                        // 터치 시작 위치 사용 (더 정확함)
                        clientX = touchStartX;
                        clientY = touchStartY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }

                    showQuestion(questionIndex, clientX, clientY);

                    // 처리 플래그 리셋
                    setTimeout(() => {
                        isProcessingClick = false;
                    }, 300);
                };

                // 터치 시작 위치 저장
                highlight.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });

                // 이벤트 등록 (터치 디바이스는 touchend만, PC는 click만)
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isTouchDevice) {
                    highlight.addEventListener('touchend', handleInteraction, { passive: false });
                } else {
                    highlight.addEventListener('click', handleInteraction);
                }
            });
        }

        // 문제 표시
        function showQuestion(index, clickX, clickY) {
            // 이미 푼 문제는 처리하지 않음
            if (stage1Data.answeredQuestions.has(index)) return;

            // 이전 모달과 타이머 정리
            if (activeModal && activeModal.classList.contains('active')) {
                activeModal.classList.remove('active');
            }
            if (activeTimeout) {
                clearTimeout(activeTimeout);
                activeTimeout = null;
            }

            const question = learningData.questions[index];
            const modal = document.getElementById('question-modal');
            const highlight = document.querySelector(`[data-question="${index}"]`);

            // 하이라이트 활성화
            document.querySelectorAll('.highlight').forEach(h => h.classList.remove('active'));
            highlight.classList.add('active');

            // 모달 내용 설정
            document.getElementById('modal-question-num').textContent = index + 1;
            document.getElementById('modal-question-text').textContent = question.text;

            // 선택지 랜덤 배열
            const shuffledOptions = shuffleOptions(question.options, question.correct);

            const optionsHTML = shuffledOptions.map((option, i) => {
                const isCorrect = option.isCorrect ? 'true' : 'false';
                return `
                    <button class="option-button" onclick="checkAnswer(${index}, ${i}, ${isCorrect})">
                        <span class="option-number">${i + 1}</span>
                        <span>${option.text}</span>
                    </button>
                `;
            }).join('');

            document.getElementById('modal-options').innerHTML = optionsHTML;

            // 모달 위치 설정 (클릭 좌표 중심)
            positionModalAtClick(modal, clickX, clickY);

            modal.classList.add('active');
            activeModal = modal;
        }

        // 선택지 섞기
        function shuffleOptions(options, correctIndex) {
            const shuffled = options.map((text, index) => ({
                text: text,
                isCorrect: index === correctIndex
            }));

            // Fisher-Yates shuffle
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // 답 체크 (전역 함수로 등록)
        window.checkAnswer = function(questionIndex, selectedOption, isCorrect) {
            const modal = document.getElementById('question-modal');
            const buttons = modal.querySelectorAll('.option-button');
            const highlight = document.querySelector(`[data-question="${questionIndex}"]`);

            // 버튼 비활성화
            buttons.forEach(btn => btn.disabled = true);

            // isCorrect를 boolean으로 변환
            const correct = (isCorrect === true || isCorrect === 'true');

            if (correct) {
                buttons[selectedOption].classList.add('correct');
                modal.classList.add('correct-animation');
                highlight.classList.add('correct');
                stage1Data.correctAnswers++;
                addTime(10);
            } else {
                buttons[selectedOption].classList.add('incorrect');
                modal.classList.add('incorrect-animation');
                highlight.classList.add('incorrect');
                stage1Data.wrongAnswers++;
                subtractTime(40);

                // 정답 표시
                buttons.forEach((btn, i) => {
                    const optionText = btn.querySelector('span:last-child').textContent;
                    const correctText = learningData.questions[questionIndex].options[learningData.questions[questionIndex].correct];
                    if (optionText === correctText) {
                        btn.classList.add('correct');
                    }
                });
            }

            stage1Data.answeredQuestions.add(questionIndex);
            updateQuestionCounter();

            // 0.8초 후 모달 닫기
            activeTimeout = setTimeout(() => {
                modal.classList.remove('active', 'correct-animation', 'incorrect-animation');
                highlight.classList.remove('active');
                activeModal = null;
                activeTimeout = null;

                // 모든 문제 완료 체크
                if (stage1Data.answeredQuestions.size === learningData.questions.length) {
                    completeStage();
                }
            }, 800);
        }

        // 모달 위치 설정
        function positionModal(highlight) {
            const modal = document.getElementById('question-modal');
            const rect = highlight.getBoundingClientRect();

            let left = rect.left + window.scrollX;
            let top = rect.bottom + window.scrollY + 10;

            // 화면 벗어남 방지
            const modalRect = modal.getBoundingClientRect();
            if (left + 450 > window.innerWidth) {
                left = window.innerWidth - 460;
            }
            if (top + modalRect.height > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - modalRect.height - 10;
            }

            modal.style.left = left + 'px';
            modal.style.top = top + 'px';
        }

        // 클릭 좌표에 모달 중심 배치
        function positionModalAtClick(modal, clickX, clickY) {
            // 모달을 fixed 포지션으로 설정 (뷰포트 기준)
            modal.style.position = 'fixed';

            // 측정을 위한 임시 표시 (이전 값 저장)
            const prevDisplay = modal.style.display;
            const prevVisibility = modal.style.visibility;

            modal.style.visibility = 'hidden';
            modal.style.display = 'block';

            const modalWidth = modal.offsetWidth;
            const modalHeight = modal.offsetHeight;

            // 클릭 좌표를 중심으로 계산 (뷰포트 기준)
            let left = clickX - (modalWidth / 2);
            let top = clickY - (modalHeight / 2);

            // 화면 밖으로 나가지 않도록 조정
            const margin = 10;

            // 좌우 경계 체크
            if (left < margin) {
                left = margin;
            } else if (left + modalWidth > window.innerWidth - margin) {
                left = window.innerWidth - modalWidth - margin;
            }

            // 상하 경계 체크
            if (top < margin) {
                top = margin;
            } else if (top + modalHeight > window.innerHeight - margin) {
                top = window.innerHeight - modalHeight - margin;
            }

            // 위치 설정
            modal.style.left = left + 'px';
            modal.style.top = top + 'px';

            // 중요: 임시 표시 원복 - .active 클래스가 display를 관리하도록
            modal.style.visibility = prevVisibility || '';
            modal.style.display = prevDisplay || '';
        }

        // 모달 드래그 설정
        function setupModalDrag() {
            const modal = document.getElementById('question-modal');

            // PC 마우스 이벤트
            modal.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 모바일 터치 이벤트
            modal.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            // 옵션 버튼 클릭시 드래그 방지
            if (e.target.closest('.option-button')) return;

            const modal = document.getElementById('question-modal');
            modalDragging = true;
            modal.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = modal.getBoundingClientRect();
            modalOffsetX = clientX - rect.left;
            modalOffsetY = clientY - rect.top;

            if (e.touches) {
                e.preventDefault(); // 터치 시 스크롤 방지
            }
        }

        function drag(e) {
            if (!modalDragging) return;

            const modal = document.getElementById('question-modal');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const newLeft = clientX - modalOffsetX;
            const newTop = clientY - modalOffsetY;

            // 화면 밖으로 나가지 않도록 제한
            const maxLeft = window.innerWidth - modal.offsetWidth;
            const maxTop = window.innerHeight - modal.offsetHeight;

            modal.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
            modal.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';

            if (e.touches) {
                e.preventDefault(); // 터치 드래그 시 스크롤 방지
            }
        }

        function endDrag() {
            modalDragging = false;
            const modal = document.getElementById('question-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
        }

        // 타이머
        function startTimer() {
            timerInterval = setInterval(() => {
                timeRemaining -= 0.1;

                // 단계별 시간 업데이트
                if (currentStage === 1) {
                    stage1Data.timeRemaining = timeRemaining;
                } else if (currentStage === 2) {
                    stage2Data.timeRemaining = timeRemaining;
                } else if (currentStage === 3) {
                    stage3Data.timeRemaining = timeRemaining;
                } else if (currentStage === 4) {
                    stage4Data.timeRemaining = timeRemaining;
                }

                if (timeRemaining <= 0) {
                    timeRemaining = 0;
                    if (currentStage === 1) {
                        completeStage();
                    } else if (currentStage === 2) {
                        completeStage2();
                    } else if (currentStage === 3) {
                        completeStage3();
                    } else if (currentStage === 4) {
                        completeStage4();
                    } else if (currentStage === 5) {
                        completeStage5();
                    }
                }
                updateTimerBar();
            }, 100);
        }

        function updateTimerBar() {
            const percentage = (timeRemaining / maxTime) * 100;
            document.getElementById('timer-bar').style.width = percentage + '%';
        }

        function addTime(seconds) {
            timeRemaining = Math.min(maxTime, timeRemaining + seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        function subtractTime(seconds) {
            timeRemaining = Math.max(0, timeRemaining - seconds);

            // 단계별 시간 업데이트
            if (currentStage === 1) {
                stage1Data.timeRemaining = timeRemaining;
            } else if (currentStage === 2) {
                stage2Data.timeRemaining = timeRemaining;
            } else if (currentStage === 3) {
                stage3Data.timeRemaining = timeRemaining;
            } else if (currentStage === 4) {
                stage4Data.timeRemaining = timeRemaining;
            }

            updateTimerBar();
        }

        // 문제 카운터 업데이트
        function updateQuestionCounter() {
            if (currentStage === 1) {
                document.getElementById('current-question').textContent = stage1Data.answeredQuestions.size;
                document.getElementById('total-questions').textContent = learningData.questions.length;
            } else if (currentStage === 2) {
                document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage2Data.questions.length;
            } else if (currentStage === 3) {
                document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex;
                document.getElementById('total-questions').textContent = stage3Data.questions.length;
            }
        }

        // 학습 완료
        function completeStage() {
            clearInterval(timerInterval);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage1Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage1Data.correctAnswers + stage1Data.wrongAnswers;
            const progress = Math.round((stage1Data.answeredQuestions.size / learningData.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage1Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '1단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage1Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage1Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage1 = {
                correct: stage1Data.correctAnswers,
                wrong: stage1Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage1은 틀린 문제 추적 안 함
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 1,
                    stageName: '딥리서치',
                    accuracy: accuracy,
                    correctAnswers: stage1Data.correctAnswers,
                    wrongAnswers: stage1Data.wrongAnswers,
                    totalQuestions: learningData.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 시간 포맷
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 다시 학습하기
        function restartStage() {
            stage1Data.currentQuestionIndex = 0;
            stage1Data.answeredQuestions.clear();
            stage1Data.correctAnswers = 0;
            stage1Data.wrongAnswers = 0;
            stage1Data.timeRemaining = 180;
            timeRemaining = 180;
            maxTime = 180;
            stage1Data.startTime = Date.now();

            document.getElementById('result-screen').classList.remove('active');
            // 학습 완료 시스템을 위한 데이터 export
        window.learningResultData = {
            totalStages: totalStages || 5,
            totalCorrect: totalCorrect || 0,
            totalWrong: totalWrong || 0,
            totalAccuracy: totalAccuracy || 0,
            totalScore: totalScore || 0,
            totalElapsedTime: totalElapsedTime || (Date.now() - globalStartTime),
            stagesDetail: stageResults || {}
        };
        console.log('학습 데이터 export:', window.learningResultData);


            document.getElementById('main-content').style.display = 'block';

            // 하이라이트 초기화
            document.querySelectorAll('.highlight').forEach(h => {
                h.classList.remove('correct', 'incorrect', 'active');
            });

            updateQuestionCounter();
            updateTimerBar();
            startTimer();
        }

        // 다음 단계로
        function nextStage() {
            console.log('nextStage() 호출됨, 현재 단계:', currentStage);

            // 현재 단계에 따라 다음 단계로 전환
            if (currentStage === 1) {
                console.log('1단계 → 2단계로 이동');
                currentStage = 2;
                initStage2();
            } else if (currentStage === 2) {
                console.log('2단계 → 3단계로 이동');
                currentStage = 3;
                initStage3();
            } else if (currentStage === 3) {
                console.log('3단계 → 4단계로 이동');
                currentStage = 4;
                initStage4();
            } else if (currentStage === 4) {
                console.log('4단계 → 5단계로 이동');
                currentStage = 5;
                initStage5();
            } else {
                console.log('nextStage() - 알 수 없는 currentStage:', currentStage);
            }
        }

        // ========== 2단계 어휘 학습 함수들 ==========

        // 2단계 초기화
        function initStage2() {
            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // passage-container 숨기기 (2단계에서는 원문 표시 안 함)
            document.getElementById('passage-container').style.display = 'none';

            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;
            timeRemaining = 240; // 4분
            maxTime = 240;

            // 문제 생성
            generateStage2Questions();

            // UI 업데이트
            updateStage2UI();

            // 첫 번째 문제 표시
            showStage2Question();

            // 타이머 시작
            startTimer();
        }

        // 2단계 문제 생성 (양방향)
        function generateStage2Questions() {
            stage2Data.questions = [];

            vocabularyData.forEach(vocab => {
                // vocab.questions 배열의 각 문제를 처리
                vocab.questions.forEach(q => {
                    const question = {
                        type: q.type,
                        question: q.question,
                        correct: q.correct,
                        word: vocab.word,
                        meaning: vocab.meaning,
                        options: shuffleArray([
                            q.correct,
                            ...q.distractors
                        ])
                    };
                    stage2Data.questions.push(question);
                });
            });

            // Fisher-Yates 셔플
            stage2Data.questions = shuffleArray(stage2Data.questions);
        }

        // 배열 셔플 (Fisher-Yates)
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 2단계 UI 업데이트
        function updateStage2UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '2단계: 어휘 학습 - 핵심 용어 마스터';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage2Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="vocabulary-container">
                    <div class="vocabulary-question-card">
                        <div class="question-number">문제 <span id="vocab-current-num">1</span> / ${stage2Data.questions.length}</div>
                        <div class="question-text" id="vocab-question-text"></div>
                        <div class="options-grid" id="vocab-options"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 2단계 문제 표시
        function showStage2Question() {
            if (stage2Data.currentQuestionIndex >= stage2Data.questions.length) {
                completeStage2();
                return;
            }

            const question = stage2Data.questions[stage2Data.currentQuestionIndex];

            // 문제 번호 업데이트
            document.getElementById('vocab-current-num').textContent = stage2Data.currentQuestionIndex + 1;
            document.getElementById('current-question').textContent = stage2Data.currentQuestionIndex + 1;

            // 문제 텍스트 표시
            document.getElementById('vocab-question-text').textContent = question.question;

            // 선택지 표시
            const optionsContainer = document.getElementById('vocab-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'vocab-option-button';
                button.innerHTML = `
                    <span class="option-number">${index + 1}</span>
                    <span class="option-text">${option}</span>
                `;
                button.onclick = () => handleStage2Answer(option, question.correct, button);
                optionsContainer.appendChild(button);
            });
        }

        // 2단계 답변 처리
        function handleStage2Answer(selected, correct, buttonEl) {
            // 중복 클릭 방지
            const buttons = document.querySelectorAll('.vocab-option-button');
            buttons.forEach(btn => btn.disabled = true);

            if (selected === correct) {
                // 정답
                buttonEl.classList.add('correct');
                stage2Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답
                buttonEl.classList.add('incorrect');
                stage2Data.wrongAnswers++;
                subtractTime(20);

                // 정답 표시
                buttons.forEach(btn => {
                    if (btn.querySelector('.option-text').textContent === correct) {
                        btn.classList.add('correct');
                    }
                });
            }

            // 다음 문제로
            setTimeout(() => {
                stage2Data.currentQuestionIndex++;
                showStage2Question();
            }, 1000);
        }

        // 2단계 완료
        function completeStage2() {
            clearInterval(timerInterval);

            // 현재 단계를 2로 명시적으로 설정
            currentStage = 2;

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage2Data.startTime) / 1000);

            // 정답률 계산
            const totalAnswered = stage2Data.correctAnswers + stage2Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage2Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage2Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '2단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage2Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage2Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage2 = {
                correct: stage2Data.correctAnswers,
                wrong: stage2Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage2는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage2()">다시 학습하기</button>
                <button class="result-button primary" onclick="nextStage3()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 2,
                    stageName: '어휘 학습',
                    accuracy: accuracy,
                    correctAnswers: stage2Data.correctAnswers,
                    wrongAnswers: stage2Data.wrongAnswers,
                    totalQuestions: stage2Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 2단계 다시 시작
        function restartStage2() {
            // 변수 초기화
            stage2Data.currentQuestionIndex = 0;
            stage2Data.correctAnswers = 0;
            stage2Data.wrongAnswers = 0;
            stage2Data.startTime = Date.now();
            stage2Data.timeRemaining = 240;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage2();
        }

        // Stage 3로 이동
        function nextStage3() {
            currentStage = 3;
            initStage3();
        }

        // ========== 3단계 문장 독해 함수들 ==========

        // 3단계 초기화
        function initStage3() {
            console.log('initStage3() 호출됨');

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // 이전 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            console.log('currentStage를 3으로 설정함');

            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;
            timeRemaining = 100;
            maxTime = 100;

            // 문제 생성
            generateStage3Questions();

            // UI 업데이트
            updateStage3UI();

            // 첫 번째 문제 표시
            showStage3Question();

            // 타이머 시작
            startTimer();
        }

        // 3단계 문제 생성
        function generateStage3Questions() {
            stage3Data.questions = [];

            sentenceData.forEach(data => {
                const question = {
                    sentence: data.sentence,
                    question: data.question,
                    correct: data.correctAnswer,
                    options: shuffleArray([
                        data.correctAnswer,
                        ...data.distractors
                    ])
                };
                stage3Data.questions.push(question);
            });

            // Fisher-Yates 셔플
            stage3Data.questions = shuffleArray(stage3Data.questions);
        }

        // 3단계 UI 업데이트
        function updateStage3UI() {
            // 헤더 업데이트
            document.querySelector('.subtitle').textContent = '3단계: 문장 독해 - 핵심 이해력 강화';

            // 스테이지 인디케이터 업데이트
            const stageDots = document.querySelectorAll('.stage-dot');
            stageDots[0].classList.remove('active');
            stageDots[0].classList.add('completed');
            stageDots[1].classList.remove('active');
            stageDots[1].classList.add('completed');
            stageDots[2].classList.add('active');

            // 문제 카운터 업데이트
            document.getElementById('current-question').textContent = 0;
            document.getElementById('total-questions').textContent = stage3Data.questions.length;

            // 메인 컨텐츠 업데이트
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = `
                <div class="sentence-container">
                    <div class="sentence-display">
                        <div class="sentence-text" id="sentence-text"></div>
                        <div class="sentence-question" id="sentence-question"></div>
                        <div class="cards-grid" id="cards-grid"></div>
                    </div>
                </div>
            `;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            mainContent.style.display = 'block';
        }

        // 3단계 문제 표시
        function showStage3Question() {
            if (stage3Data.currentQuestionIndex >= stage3Data.questions.length) {
                completeStage3();
                return;
            }

            const question = stage3Data.questions[stage3Data.currentQuestionIndex];

            // 문장 표시 (줄바꿈 처리)
            const sentenceHtml = question.sentence
                .replace(/\n/g, '<br>')
                .replace(/\//g, ' / '); // 슬래시 앞뒤 공백 추가
            document.getElementById('sentence-text').innerHTML = sentenceHtml;

            // 질문 표시 (대괄호 속 부연설명 제거 및 줄바꿈 처리)
            let questionText = question.question
                .replace(/\[.*?\]\s*/g, '') // [괄호 속 내용] 제거
                .replace(/\n/g, '<br>');
            document.getElementById('sentence-question').innerHTML = `<strong>Q.</strong> ${questionText}`;

            // 카운터 업데이트
            document.getElementById('current-question').textContent = stage3Data.currentQuestionIndex + 1;

            // 카드 생성
            const cardsGrid = document.getElementById('cards-grid');
            cardsGrid.innerHTML = '';

            question.options.forEach((option, index) => {
                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card';
                flipCard.setAttribute('data-index', index);
                flipCard.setAttribute('data-option', option); // 원본 option 저장

                const isCorrect = option === question.correct;

                // 선택지도 줄바꿈 처리
                const optionHtml = option.replace(/\n/g, '<br>');

                flipCard.innerHTML = `
                    <div class="flip-card-inner">
                        <div class="flip-card-front">
                            <div class="card-text">${optionHtml}</div>
                        </div>
                        <div class="flip-card-back ${isCorrect ? 'correct' : 'incorrect'}">
                            <div>
                                <div class="card-icon">${isCorrect ? '✅' : '❌'}</div>
                                <div class="card-text">${isCorrect ? '정답!' : '오답'}</div>
                            </div>
                        </div>
                    </div>
                `;

                flipCard.onclick = () => handleStage3Answer(option, question.correct, flipCard);
                cardsGrid.appendChild(flipCard);
            });
        }

        // 3단계 답변 처리
        function handleStage3Answer(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.flip-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            if (selected === correct) {
                // 정답
                stage3Data.correctAnswers++;
                addTime(15);
            } else {
                // 오답
                stage3Data.wrongAnswers++;
                subtractTime(20);

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const cardOption = card.getAttribute('data-option');
                        if (cardOption === correct) {
                            card.classList.add('flipped');
                        }
                    });
                }, 500);
            }

            // 다음 문제로
            setTimeout(() => {
                stage3Data.currentQuestionIndex++;
                showStage3Question();
            }, 1500);
        }

        // 3단계 완료
        function completeStage3() {
            clearInterval(timerInterval);

            // 현재 단계를 3으로 명시적으로 설정
            currentStage = 3;

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage3Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage3Data.correctAnswers + stage3Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage3Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage3Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '3단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage3Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage3Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage3 = {
                correct: stage3Data.correctAnswers,
                wrong: stage3Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: [] // Stage3는 틀린 문제 추적 안 함
            };

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            resultButtons.innerHTML = `
                <button class="result-button secondary" onclick="restartStage3()">다시 학습하기</button>
                <button class="result-button primary" onclick="initStage4()">다음 단계로</button>
            `;

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 3,
                    stageName: '문장 독해',
                    accuracy: accuracy,
                    correctAnswers: stage3Data.correctAnswers,
                    wrongAnswers: stage3Data.wrongAnswers,
                    totalQuestions: stage3Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }
        }

        // 3단계 다시 시작
        function restartStage3() {
            // 변수 초기화
            stage3Data.currentQuestionIndex = 0;
            stage3Data.correctAnswers = 0;
            stage3Data.wrongAnswers = 0;
            stage3Data.startTime = Date.now();
            stage3Data.timeRemaining = 100;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage3();
        }

        // ================== 4단계: OX퀴즈 ==================
        const stage4Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            wrongQuestions: [],  // 틀린 문제 저장
            startTime: null,
            timeRemaining: 120
        };

        // OX퀴즈 데이터
                const oxQuizData = [
            // O 문제 (15개)
            { id: 1, statement: "흥부의 성격은 서두에서 '마음이 인후하여'라고 직접 제시된다.", answer: true, explanation: "전지적 서술자가 인물 성격을 명시적으로 진술(직접 제시)." },
            { id: 2, statement: "이 작품은 판소리계 소설로, 운문체와 산문체가 혼합되어 나타난다.", answer: true, explanation: "판소리 사설 정착 → 운율적 문장 + 산문 서사 병존." },
            { id: 3, statement: "서술자의 개입은 '놀부 놈의 거동 보소', '이년 또한 몹쓸 년이라' 등에서 확인된다.", answer: true, explanation: "독자에게 직접 말을 거는 가치판단적 개입." },
            { id: 4, statement: "놀부는 마당쇠를 시켜 돝자루를 가져오게 하고 그것으로 흥부를 구타한다.", answer: true, explanation: "'보리섬'은 더미 위치를 지시했을 뿐, 실제 구타는 돝자루/몽둥이." },
            { id: 5, statement: "놀부 아내는 밥 주걱으로 흥부의 뺨을 때린다.", answer: true, explanation: "문면의 사실 진술 그대로." },
            { id: 6, statement: "흥부가 뺨에 묻은 밥알을 훔쳐 넣는 장면은 해학/낙천성을 드러낸다.", answer: true, explanation: "비극을 웃음으로 승화하는 판소리계 해학." },
            { id: 7, statement: "흥부는 다친 제비를 치료해 주고 다음 해 박씨를 얻어 부자가 된다.", answer: true, explanation: "선행 → 비현실적 보상(복선·권선징악)." },
            { id: 8, statement: "놀부는 멀쩡한 제비의 다리를 인위적으로 부러뜨린다.", answer: true, explanation: "흥부의 선행을 모방하되 악의적으로 왜곡." },
            { id: 9, statement: "제비는 강남 황제에게 놀부의 만행을 고한다.", answer: true, explanation: "황제가 듣고 보복 박(보수표)을 내림." },
            { id: 10, statement: "황제는 놀부의 악행에 분개하여 '보수표(報讐瓢)'를 내리도록 한다.", answer: true, explanation: "응징을 예고하는 장치(복선)로 기능." },
            { id: 11, statement: "작품의 주제는 권선징악으로 요약된다.", answer: true, explanation: "선(흥부) 보상, 악(놀부) 응징의 구조." },
            { id: 12, statement: "전지적 작가 시점이며, 서술자 개입이 빈번하다.", answer: true, explanation: "인물 평가·독자 호명 등." },
            { id: 13, statement: "'치장' 대목은 남루한 옷차림을 과장·열거하여 궁핍을 부각한다.", answer: true, explanation: "나열법·과장법으로 희화화+현실 고발." },
            { id: 14, statement: "이야기에는 현실적 삶과 비현실적 요소가 공존한다.", answer: true, explanation: "사실적·비현실적 내용의 조화가 특징." },
            { id: 15, statement: "흥부·흥부 아내의 품팔이 나열은 운율감과 생활고의 구체성을 강화한다.", answer: true, explanation: "판소리 사설 특유의 열거·장면 극대화." },

            // X 문제 (15개)
            { id: 16, statement: "놀부는 흥부에게 보리섬을 헐어 곡식을 퍼주었다.", answer: false, explanation: "실제로는 거절+구타. [오답 패턴] 부정/상대어 왜곡(+을 −로 전환)." },
            { id: 17, statement: "'보수표'는 선행에 대한 보상의 박씨를 뜻한다.", answer: false, explanation: "'보수표'는 원수 갚는 박(응징용). [오답 패턴] Good vs Bad(의미 반전)." },
            { id: 18, statement: "제비는 강남 부자에게 놀부의 악행을 고한다.", answer: false, explanation: "대상은 강남 황제. [오답 패턴] A vs B(대상 혼동)." },
            { id: 19, statement: "이 작품은 1인칭 주인공 시점으로 서술된다.", answer: false, explanation: "전지적 작가 시점. [오답 패턴] 개념 바꾸기." },
            { id: 20, statement: "판소리계 소설인 만큼 운문체의 특징만 나타난다.", answer: false, explanation: "운문+산문 혼합. [오답 패턴] 결합/분리(한 요소만 고집)." },
            { id: 21, statement: "흥부는 아내의 권유에 용기를 내어 형 집에 갔다.", answer: false, explanation: "맥락상 '마지못해' 찾아감. [오답 패턴] 부정/상대어(어감 반전)." },
            { id: 22, statement: "놀부 아내는 흥부에게 밥 한 술을 건넨 뒤 내보냈다.", answer: false, explanation: "밥 주걱으로 뺨을 침, 밥은 주지 않음. [오답 패턴] 했냐/안 했냐(비사실 덧붙이기)." },
            { id: 23, statement: "'무거불측(無據不測)'은 놀부의 인색함을 칭송하는 말이다.", answer: false, explanation: "'근거 없고 헤아리기 어렵다'는 부정적 풍자. [오답 패턴] Good vs Bad." },
            { id: 24, statement: "맞은 뒤 흥부의 몸은 멀쩡하여 곧장 발길을 돌렸다.", answer: false, explanation: "'일신이 노릇하여'(거동이 힘듦). [오답 패턴] 부정/상대어 반전." },
            { id: 25, statement: "다친 제비는 흥부가 실수로 다치게 한 것이다.", answer: false, explanation: "구렁이가 물어 다쳤고 흥부가 치료. [오답 패턴] 주체/원인 왜곡." },
            { id: 26, statement: "놀부는 도움 필요한 제비를 정성껏 치료하려 했다.", answer: false, explanation: "오히려 멀쩡한 제비를 부러뜨림. [오답 패턴] 의도/목적 왜곡." },
            { id: 27, statement: "작품의 주제는 인과율 사상으로 요약된다.", answer: false, explanation: "핵심은 권선징악. [오답 패턴] A vs B(개념 교체)." },
            { id: 28, statement: "공간 배경은 주로 서울의 양반가이다.", answer: false, explanation: "핵심 배경은 농촌 마을/민중 삶. [오답 패턴] 결합/분리(배경 왜곡)." },
            { id: 29, statement: "서술자는 객관성 유지를 위해 인물 평가를 삼간다.", answer: false, explanation: "개입·평가 빈번. [오답 패턴] 부정/상대어 반전." },
            { id: 30, statement: "구성은 과거·현재를 교차시키는 입체적 시간 배열이다.", answer: false, explanation: "순행적 전개가 기본. [오답 패턴] 순서/방향 왜곡." }
        ];

        // 4단계 초기화
        function initStage4() {
            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // passage-container 숨기기 (4단계에서는 지문 보기 모달로만 표시)
            const passageContainer = document.getElementById('passage-container');
            if (passageContainer) {
                passageContainer.style.display = 'none';
            }

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 4;

            // 문제 랜덤 셔플
            stage4Data.questions = [...oxQuizData];
            for (let i = stage4Data.questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [stage4Data.questions[i], stage4Data.questions[j]] = [stage4Data.questions[j], stage4Data.questions[i]];
            }

            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            timeRemaining = stage4Data.timeRemaining;
            maxTime = stage4Data.timeRemaining;  // maxTime 설정

            // 헤더 업데이트
            document.querySelector('.title').textContent = '흥부전';
            document.querySelector('.subtitle').textContent = '4단계: OX퀴즈';
            document.querySelector('.stage-indicator').textContent = 'Stage 4 / 4';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage4Data.questions.length}`;

            startTimer();
            showStage4Question();
        }

        // 4단계 문제 표시
        function showStage4Question() {
            if (stage4Data.currentQuestionIndex >= stage4Data.questions.length) {
                completeStage4();
                return;
            }

            const question = stage4Data.questions[stage4Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage4Data.currentQuestionIndex + 1}/${stage4Data.questions.length}`;

            // OX 카드 형식으로 표시
            mainContent.innerHTML = `
                <div class="stage4-container">
                    <div class="question-panel">
                        <h2 class="question-text">${question.statement}</h2>
                        <button class="text-review-btn" onclick="showTextModal()">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>
                    <div class="ox-cards-container">
                        <div class="flip-card ox-card" onclick="handleOXAnswer(true, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">O</div>
                                </div>
                                <div class="flip-card-back ${question.answer === true ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === true ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="flip-card ox-card" onclick="handleOXAnswer(false, ${question.answer}, this)">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="card-symbol">X</div>
                                </div>
                                <div class="flip-card-back ${question.answer === false ? 'correct' : 'incorrect'}">
                                    <div class="result-icon">${question.answer === false ? '✓' : '✗'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${question.explanation ? `<div class="explanation-text" id="explanation" style="display:none;">${question.explanation}</div>` : ''}
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage4-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage4-styles';
                styles.textContent = `
                    .stage4-container {
                        padding: 30px;
                        max-width: 900px;
                        margin: 0 auto;
                    }

                    .question-panel {
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        margin-bottom: 40px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                        position: relative;
                    }

                    .question-text {
                        font-size: 24px;
                        line-height: 1.6;
                        color: #2c3e50;
                        margin: 0 0 20px 0;
                    }

                    .text-review-btn {
                        background: #3498db;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        transition: background 0.3s;
                    }

                    .text-review-btn:hover {
                        background: #2980b9;
                    }

                    .ox-cards-container {
                        display: flex;
                        justify-content: center;
                        gap: 60px;
                        margin-bottom: 30px;
                    }

                    .ox-card {
                        width: 200px;
                        height: 200px;
                    }

                    .ox-card .flip-card-front {
                        background: white;
                        border: 3px solid #e9ecef;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .card-symbol {
                        font-size: 80px;
                        font-weight: bold;
                        color: #3498db;
                    }

                    .ox-card .flip-card-back.correct {
                        background: #27ae60;
                    }

                    .ox-card .flip-card-back.incorrect {
                        background: #e74c3c;
                    }

                    .ox-card .result-icon {
                        font-size: 80px;
                        color: white;
                    }

                    .explanation-text {
                        background: #fff3cd;
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 16px;
                        color: #856404;
                        text-align: center;
                    }

                    /* 텍스트 모달 스타일 */
                    .text-modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: none;
                    }

                    .text-modal-overlay.active {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .text-modal {
                        background: white;
                        border-radius: 12px;
                        width: 90%;
                        max-width: 800px;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                    }

                    .text-modal-header {
                        padding: 20px;
                        border-bottom: 1px solid #e9ecef;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .text-modal-title {
                        font-size: 20px;
                        font-weight: bold;
                        color: #2c3e50;
                    }

                    .text-modal-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #7f8c8d;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                    }

                    .text-modal-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                        font-size: 16px;
                        line-height: 1.8;
                        color: #2c3e50;
                    }

                    @media (max-width: 768px) {
                        /* Stage 4 모바일 최적화 */
                        .ox-cards-container {
                            gap: 20px;  /* 간격 더 줄임 */
                        }

                        .ox-card {
                            width: 120px;  /* 카드 크기 더 작게 */
                            height: 120px;
                        }

                        .card-symbol, .ox-card .result-icon {
                            font-size: 45px;  /* 심볼 크기 축소 */
                        }

                        .question-text {
                            font-size: 16px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;  /* 줄 간격 조정 */
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        // OX 답변 처리
        window.handleOXAnswer = function(selected, correct, cardEl) {
            // 모든 카드 비활성화
            const cards = document.querySelectorAll('.ox-card');
            cards.forEach(card => {
                card.onclick = null;
                card.style.pointerEvents = 'none';
            });

            // 선택한 카드 뒤집기
            cardEl.classList.add('flipped');

            const currentQuestion = stage4Data.questions[stage4Data.currentQuestionIndex];

            if (selected === correct) {
                // 정답
                stage4Data.correctAnswers++;
                addTime(10);
            } else {
                // 오답 - 틀린 문제 저장
                stage4Data.wrongAnswers++;
                subtractTime(15);

                // 틀린 문제 데이터 저장
                stage4Data.wrongQuestions.push({
                    question: currentQuestion.statement,
                    userAnswer: selected ? 'O' : 'X',
                    correctAnswer: correct ? 'O' : 'X',
                    explanation: currentQuestion.explanation || null
                });

                // 정답 카드도 표시
                setTimeout(() => {
                    cards.forEach(card => {
                        const symbol = card.querySelector('.card-symbol').textContent;
                        const isCorrectCard = (symbol === 'O' && correct === true) || (symbol === 'X' && correct === false);
                        if (isCorrectCard) {
                            card.classList.add('flipped');
                        }
                    });
                }, 300);

                // 설명 표시
                const explanation = document.getElementById('explanation');
                if (explanation) {
                    setTimeout(() => {
                        explanation.style.display = 'block';
                    }, 600);
                }
            }

            // 다음 문제로
            setTimeout(() => {
                stage4Data.currentQuestionIndex++;
                showStage4Question();
            }, 2000);
        };

        // 텍스트 모달 표시
        window.showTextModal = function() {
            // 모달이 없으면 생성
            if (!document.getElementById('text-modal-overlay')) {
                const modalHTML = `
                    <div id="text-modal-overlay" class="text-modal-overlay">
                        <div class="text-modal">
                            <div class="text-modal-header">
                                <div class="text-modal-title">원문 확인</div>
                                <button class="text-modal-close" onclick="closeTextModal()">✕</button>
                            </div>
                            <div class="text-modal-body" id="text-modal-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 흥부전 원문 표시
            const originalText = learningData.fullText;
            const modalContent = document.getElementById('text-modal-content');
            modalContent.innerHTML = originalText.replace(/\n/g, '<br>');

            // 모달 표시
            document.getElementById('text-modal-overlay').classList.add('active');
        };

        // 텍스트 모달 닫기
        window.closeTextModal = function() {
            document.getElementById('text-modal-overlay').classList.remove('active');
        };

        // 4단계 완료
        function completeStage4() {
            clearInterval(timerInterval);

            // 현재 단계를 4로 명시적으로 설정
            currentStage = 4;
            console.log('completeStage4() - currentStage 설정:', currentStage);

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage4Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage4Data.correctAnswers + stage4Data.wrongAnswers;
            const progress = Math.round((totalAnswered / stage4Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage4Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '4단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage4Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage4Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage4 = {
                correct: stage4Data.correctAnswers,
                wrong: stage4Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage4Data.wrongQuestions // Stage4는 틀린 문제 추적
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 4,
                    stageName: 'OX퀴즈',
                    accuracy: accuracy,
                    correctAnswers: stage4Data.correctAnswers,
                    wrongAnswers: stage4Data.wrongAnswers,
                    wrongQuestions: stage4Data.wrongQuestions,
                    totalQuestions: stage4Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = `
                <button class="result-button secondary" onclick="restartStage4()">다시 학습하기</button>
            `;

            // 틀린 문제가 있으면 '틀린 문제 다시 보기' 버튼 추가
            if (stage4Data.wrongQuestions.length > 0) {
                buttonsHTML += `<button class="result-button info" onclick="showWrongQuestions()">틀린 문제 다시 보기</button>`;
            }

            buttonsHTML += `<button class="result-button primary" onclick="nextStage()">다음 단계로</button>`;
            resultButtons.innerHTML = buttonsHTML;
        }

        // 4단계 다시 시작
        function restartStage4() {
            // 변수 초기화
            stage4Data.currentQuestionIndex = 0;
            stage4Data.correctAnswers = 0;
            stage4Data.wrongAnswers = 0;
            stage4Data.wrongQuestions = [];  // 틀린 문제 초기화
            stage4Data.startTime = Date.now();
            stage4Data.timeRemaining = 120;

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage4();
        }

        // 틀린 문제 다시 보기
        function showWrongQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('wrong-questions-modal')) {
                const modalHTML = `
                    <div id="wrong-questions-modal" class="wrong-questions-modal-overlay">
                        <div class="wrong-questions-modal">
                            <div class="wrong-questions-header">
                                <h2>틀린 문제 다시 보기</h2>
                                <button class="close-modal-btn" onclick="closeWrongQuestionsModal()">✕</button>
                            </div>
                            <div class="wrong-questions-body" id="wrong-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);

                // 스타일 추가
                if (!document.querySelector('#wrong-questions-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'wrong-questions-styles';
                    styles.textContent = `
                        .wrong-questions-modal-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 10001;
                            display: none;
                            align-items: center;
                            justify-content: center;
                        }

                        .wrong-questions-modal-overlay.active {
                            display: flex;
                        }

                        .wrong-questions-modal {
                            background: white;
                            border-radius: 12px;
                            width: 90%;
                            max-width: 800px;
                            max-height: 80vh;
                            display: flex;
                            flex-direction: column;
                        }

                        .wrong-questions-header {
                            padding: 20px;
                            border-bottom: 2px solid #e9ecef;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        }

                        .wrong-questions-header h2 {
                            margin: 0;
                            color: #2c3e50;
                            font-size: 24px;
                        }

                        .close-modal-btn {
                            background: none;
                            border: none;
                            font-size: 28px;
                            cursor: pointer;
                            color: #7f8c8d;
                            padding: 0;
                            width: 40px;
                            height: 40px;
                        }

                        .wrong-questions-body {
                            padding: 20px;
                            overflow-y: auto;
                            flex: 1;
                        }

                        .wrong-question-card {
                            background: #f8f9fa;
                            padding: 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border: 1px solid #dee2e6;
                        }

                        .wrong-question-number {
                            font-weight: bold;
                            color: #495057;
                            margin-bottom: 10px;
                            font-size: 16px;
                        }

                        .wrong-question-text {
                            font-size: 18px;
                            margin-bottom: 15px;
                            color: #2c3e50;
                            line-height: 1.6;
                        }

                        .wrong-question-answers {
                            display: flex;
                            gap: 30px;
                            margin-bottom: 15px;
                        }

                        .answer-item {
                            display: flex;
                            align-items: center;
                            gap: 10px;
                        }

                        .answer-label {
                            font-weight: 600;
                            color: #6c757d;
                        }

                        .user-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }

                        .correct-answer {
                            padding: 5px 15px;
                            border-radius: 20px;
                            background: #27ae60;
                            color: white;
                            font-weight: bold;
                        }

                        .question-explanation {
                            background: #fff3cd;
                            border: 1px solid #ffc107;
                            border-radius: 6px;
                            padding: 12px;
                            color: #856404;
                            margin-top: 10px;
                        }

                        .question-explanation strong {
                            display: block;
                            margin-bottom: 5px;
                        }

                        .result-button.info {
                            background: #3498db;
                        }

                        .result-button.info:hover {
                            background: #2980b9;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }

            // 틀린 문제 내용 생성
            const content = document.getElementById('wrong-questions-content');
            let html = '';

            stage4Data.wrongQuestions.forEach((q, index) => {
                html += `
                    <div class="wrong-question-card">
                        <div class="wrong-question-number">문제 ${index + 1}</div>
                        <div class="wrong-question-text">${q.question}</div>
                        <div class="wrong-question-answers">
                            <div class="answer-item">
                                <span class="answer-label">내가 선택한 답:</span>
                                <span class="user-answer">${q.userAnswer}</span>
                            </div>
                            <div class="answer-item">
                                <span class="answer-label">정답:</span>
                                <span class="correct-answer">${q.correctAnswer}</span>
                            </div>
                        </div>
                        ${q.explanation ? `
                            <div class="question-explanation">
                                <strong>📝 해설</strong>
                                ${q.explanation}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            content.innerHTML = html;
            document.getElementById('wrong-questions-modal').classList.add('active');
        }

        // 틀린 문제 모달 닫기
        function closeWrongQuestionsModal() {
            document.getElementById('wrong-questions-modal').classList.remove('active');
        }

        // ================== 5단계: 서술형 문제 ==================
        const stage5Data = {
            questions: [],
            currentQuestionIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            skippedQuestions: [],  // 넘긴 문제 저장
            startTime: null,
            timeRemaining: 600,  // 10분으로 변경
            currentArrangement: [],
            draggedCard: null,
            draggedElement: null
        };

        // 서술형 문제 데이터
                const writingQuestions = [
            {
                id: 1,
                question: "흥부와 놀부의 성격을 비교하고, 두 인물의 상반된 성격이 작품의 주제 의식을 어떻게 강화하는지 서술하시오.",
                questionType: "비교형, 내용/해석형",
                correctAnswer: "흥부는 '마음이 인후'한 인물로, 가난하지만 형제애와 청렴함을 지키는 선량한 성격이다. 반면, 놀부는 '모진 마음'을 가진 인물로, 부를 축적했음에도 불구하고 동생의 고통을 외면하는 탐욕스럽고 비인간적인 성격이다. 이처럼 선과 악의 상징인 두 인물의 극명한 대비는 선한 행동이 보상받고 악한 행동이 벌을 받는다는 권선징악이라는 주제를 효과적으로 강화한다.",
                scoringCriteria: "① 흥부와 놀부의 성격 비교, ② 대비가 권선징악 주제를 강화함을 서술",
                correctParts: [
                    "흥부는 '마음이 인후'한 인물로, 가난하지만 형제애와 청렴함을 지키는 선량한 성격이다.",
                    "반면, 놀부는 '모진 마음'을 가진 인물로, 부를 축적했음에도 불구하고 동생의 고통을 외면하는 탐욕스럽고 비인간적인 성격이다.",
                    "이처럼 선과 악의 상징인 두 인물의 극명한 대비는 선한 행동이 보상받고 악한 행동이 벌을 받는다는 권선징악이라는 주제를 효과적으로 강화한다."
                ],
                distractors: ["흥부와 놀부의 대비는 부와 가난의 경제적 불평등을 상징하며, 두 인물의 극단적 대비를 통해 당대 봉건 사회의 계급 모순과 재산 분배의 부조리를 폭로하는 데 주된 의도가 있다.", "흥부는 소극적이고 무력한 인물로 운명에 순응하며, 놀부는 실용적이고 능동적인 인물로 묘사되는데, 이러한 성격 대비는 근대적 자아 의식의 형성 과정을 보여주려는 작가의 의도를 반영한다.", "놀부의 탐욕은 당대의 상업 자본주의 발달과 관련이 있으며, 흥부의 청렴함은 유교적 이상을 상징하므로, 두 인물의 대립은 전통과 근대의 가치관 충돌을 표현한 것으로 해석된다."]
            },
            {
                id: 2,
                question: "놀부가 흥부에게 매를 때리고 놀부 아내가 주걱으로 뺨을 때린 두 장면의 공통점과 차이점을 서술하시오.",
                questionType: "비교형, 내용/해석형",
                correctAnswer: "공통점은 두 장면 모두 재물에 대한 욕심 때문에 혈육에게 폭력을 행사한다는 점이다. 차이점은 놀부의 폭력은 '몽둥이'를 사용한 물리적 폭력이며, 놀부 아내의 폭력은 '주걱'을 사용한 상징적 폭력이라는 점이다. 밥을 주는 척하면서 굶주린 동생의 뺨을 때리는 행위는 놀부의 폭력보다 더욱 비인간적이고 이중적인 모습을 드러낸다.",
                scoringCriteria: "① 공통점(재물욕심, 혈육에게 폭력), ② 차이점(물리적 vs 상징적)",
                correctParts: [
                    "공통점은 두 장면 모두 재물에 대한 욕심 때문에 혈육에게 폭력을 행사한다는 점이다.",
                    "차이점은 놀부의 폭력은 '몽둥이'를 사용한 물리적 폭력이며, 놀부 아내의 폭력은 '주걱'을 사용한 상징적 폭력이라는 점이다.",
                    "밥을 주는 척하면서 굶주린 동생의 뺨을 때리는 행위는 놀부의 폭력보다 더욱 비인간적이고 이중적인 모습을 드러낸다."
                ],
                distractors: ["두 장면 모두 흥부에 대한 거부를 나타내지만, 놀부의 폭력은 과거의 원한에서 비롯된 감정적 분노이며, 아내의 폭력은 가족 내 서열을 확립하려는 규범적 행위로 해석할 수 있다.", "공통점은 혈육에 대한 폭력이라는 점이지만, 놀부는 형으로서의 권위를 세우려는 목적이 있고, 아내는 시동생의 무례한 방문을 응징하는 가정 내 규율 행위로 볼 수 있다.", "두 폭력 장면은 모두 가부장적 질서를 반영하며, 놀부의 매질은 가장으로서의 권위 행사이고, 아내의 주걱질은 부덕을 실천하는 여성의 역할 수행으로 당대 가족 제도를 반영한다."]
            },
            {
                id: 3,
                question: "흥부가 뺨에 묻은 밥알을 훔쳐 먹으며 놀부 아내에게 \"이 뺨마저 쳐 주시오\"라고 말한 행동에 담긴 의미를 해학성 및 흥부의 심리와 관련지어 서술하시오.",
                questionType: "내용/해석형",
                correctAnswer: "이 행동은 극심한 가난과 폭력이라는 비극적인 상황을 웃음으로 승화시키는 해학성을 보여준다. 흥부는 굶주림 때문에 굴욕적인 상황에서도 밥알을 얻기 위해 '더 맞아도 좋다'는 태도를 취한다. 이는 흥부의 순진하고 어리숙한 성격뿐만 아니라, 고통스러운 현실을 유머로 극복하려는 조선 후기 서민들의 낙천적이고 건강한 삶의 태도를 드러낸다.",
                scoringCriteria: "① 해학성(비극을 웃음으로 승화), ② 흥부의 심리(굶주림, 낙천성)",
                correctParts: [
                    "이 행동은 극심한 가난과 폭력이라는 비극적인 상황을 웃음으로 승화시키는 해학성을 보여준다.",
                    "흥부는 굶주림 때문에 굴욕적인 상황에서도 밥알을 얻기 위해 '더 맞아도 좋다'는 태도를 취한다.",
                    "이는 흥부의 순진하고 어리숙한 성격뿐만 아니라, 고통스러운 현실을 유머로 극복하려는 조선 후기 서민들의 낙천적이고 건강한 삶의 태도를 드러낸다."
                ],
                distractors: ["흥부의 행동은 당대 양반 사회의 예법을 조롱하는 풍자적 장치로, 형식적 예의보다 생존이 우선되는 서민의 실용적 가치관을 표현하며, 유교적 엄숙함을 해체하는 서사 전략이다.", "이 장면은 흥부의 교활한 생존 전략을 보여주는 것으로, 표면적으로는 순진해 보이지만 실제로는 놀부 부부를 조종하여 더 많은 시혜를 얻으려는 계산된 행위로 해석된다.", "밥알을 훔쳐 먹는 행동은 흥부가 놀부 아내의 폭력성을 역이용하여 식량을 확보하는 지혜를 드러낸 것으로, 약자가 강자를 상대로 벌이는 지능적 저항의 형태로 볼 수 있다."]
            },
            {
                id: 4,
                question: "윗글의 놀부와 흥부가 품을 파는 모습을 묘사한 부분에서, 서술자가 사용한 표현 기법은 무엇이며 그 효과는 무엇인지 서술하시오.",
                questionType: "개념 적용형",
                correctAnswer: "서술자는 놀부가 재물을 거절하는 장면('쌀이 많이 있다 한들...', '벼가 많이 있다 한들...')과 흥부가 품을 파는 장면('용정하여 방아 찧기...', '온 가지로 품을 팔고...')에서 유사한 어구들을 반복적으로 나열하는 기법을 사용한다. 이러한 기법은 판소리 사설의 특징인 운율감을 형성하고, 놀부의 끝없는 인색함과 흥부 부부의 고달픈 삶을 생동감 있고 구체적으로 보여주는 효과가 있다.",
                scoringCriteria: "① 표현 기법(반복적 나열/열거법), ② 효과(운율감, 구체성)",
                correctParts: [
                    "서술자는 놀부가 재물을 거절하는 장면('쌀이 많이 있다 한들...', '벼가 많이 있다 한들...')과 흥부가 품을 파는 장면('용정하여 방아 찧기...', '온 가지로 품을 팔고...')에서 유사한 어구들을 반복적으로 나열하는 기법을 사용한다.",
                    "이러한 기법은 판소리 사설의 특징인 운율감을 형성하고, 놀부의 끝없는 인색함과 흥부 부부의 고달픈 삶을 생동감 있고 구체적으로 보여주는 효과가 있다."
                ],
                distractors: ["서술자는 대조법을 중심으로 흥부의 곤궁과 놀부의 부유함을 극명하게 대비시키며, 이를 통해 당대 사회의 빈부 격차와 재화 분배의 불평등을 사실주의적 시각에서 고발하고 있다.", "과장법과 직유법을 결합하여 인물의 행동을 희화화하고, 이러한 수사적 장치는 독자의 감정 이입을 강화하여 서사적 몰입도를 높이는 근대 소설의 기법적 특징을 보여준다.", "반복적 나열은 서술의 리듬감을 형성하지만, 이는 서사적 긴장감을 완화시키고 독자의 주의를 분산시키는 역효과를 낳아 전체 서사 구조의 응집력을 저해하는 측면이 있다."]
            },
            {
                id: 5,
                question: "<보기>는 '흥부전'의 한 특징에 대한 설명이다. <보기>를 참고하여, 놀부가 제비 다리를 부러뜨리는 행위가 어떤 의미를 가지는지 서술하시오.\n\n<보기>\n'흥부전'의 비현실적 요소는 현실에서 보상받지 못하는 민중의 희망을 반영한다.",
                questionType: "<보기> 적용형",
                correctAnswer: "<보기>에 따르면 '흥부전'의 비현실적 요소는 현실에서 보상받지 못하는 민중의 희망을 반영한다. 놀부가 제비 다리를 부러뜨리는 행위는, 흥부와 같은 선한 존재에게만 주어져야 할 비현실적 보상을 탐욕으로 강탈하려는 비도덕적인 시도를 의미한다. 이는 선행에 대한 보상이 단순히 주어지지 않고, 오히려 탐욕스러운 자에 의해 빼앗길 수도 있다는 당시 사회의 비정한 현실을 보여주는 동시에, 진정한 보상은 물질적 이익이 아닌 선행에서 비롯됨을 역설적으로 강조한다.",
                scoringCriteria: "① <보기> 내용 이해, ② 놀부 행위의 의미(탐욕으로 강탈 시도, 역설적 강조)",
                correctParts: [
                    "<보기>에 따르면 '흥부전'의 비현실적 요소는 현실에서 보상받지 못하는 민중의 희망을 반영한다. 놀부가 제비 다리를 부러뜨리는 행위는, 흥부와 같은 선한 존재에게만 주어져야 할 비현실적 보상을 탐욕으로 강탈하려는 비도덕적인 시도를 의미한다.",
                    "이는 선행에 대한 보상이 단순히 주어지지 않고, 오히려 탐욕스러운 자에 의해 빼앗길 수도 있다는 당시 사회의 비정한 현실을 보여주는 동시에, 진정한 보상은 물질적 이익이 아닌 선행에서 비롯됨을 역설적으로 강조한다."
                ],
                distractors: ["놀부의 행위는 흥부가 우연히 얻은 행운의 메커니즘을 논리적으로 분석하고 재현하려는 시도로, 민중이 가진 과학적 사고와 합리적 문제 해결 능력의 발현으로 평가할 수 있다.", "제비 다리를 부러뜨리는 것은 놀부 나름의 실험 정신과 도전 의식을 보여주는 행위로, 비록 도덕적 문제가 있지만 기존의 인과 관계를 검증하려는 근대적 탐구 태도의 맹아로 해석된다.", "이 행위는 비현실적 요소가 사회 전반에 평등하게 적용될 수 있는지를 시험하는 과정으로, 특정 계층이나 개인에게만 보상이 주어지는 불공정한 구조에 대한 놀부의 저항으로 볼 수 있다."]
            },
            {
                id: 6,
                question: "흥부가 놀부를 찾아가는 과정에서 '치장'을 묘사하는 문장이 흥부의 처지와 어떻게 연결되는지 서술하시오.",
                questionType: "내용/해석형",
                correctAnswer: "흥부가 형의 집에 가기 위해 '치장'을 하는 모습은 그의 비참한 처지를 희화화하여 보여준다. 찢어진 망건, 낡은 중치막 등 남루하고 해진 옷차림을 과장되게 열거함으로써, 흥부가 얼마나 극심한 궁핍에 시달리고 있는지 구체적으로 드러낸다. 이는 굶주린 자식들을 위해 체면을 버리고 형을 찾아갈 수밖에 없는 흥부의 절박한 상황을 강조하는 역할을 한다.",
                scoringCriteria: "① 치장 묘사의 의미(희화화, 궁핍 부각), ② 흥부 처지와의 연결(절박한 상황)",
                correctParts: [
                    "흥부가 형의 집에 가기 위해 '치장'을 하는 모습은 그의 비참한 처지를 희화화하여 보여준다.",
                    "찢어진 망건, 낡은 중치막 등 남루하고 해진 옷차림을 과장되게 열거함으로써, 흥부가 얼마나 극심한 궁핍에 시달리고 있는지 구체적으로 드러낸다.",
                    "이는 굶주린 자식들을 위해 체면을 버리고 형을 찾아갈 수밖에 없는 흥부의 절박한 상황을 강조하는 역할을 한다."
                ],
                distractors: ["치장 묘사는 조선 후기 의복 문화를 사실적으로 재현한 것으로, 당대 서민 계층의 의생활을 민속학적으로 기록하려는 작가의 의도가 반영되어 있으며, 역사적 자료로서의 가치를 지닌다.", "흥부의 옷차림은 그가 물질적 부를 초월한 정신적 고결함을 유지하고 있음을 상징하는 것으로, 외적 초라함이 내적 풍요로움과 대비되는 불교적 무소유 사상을 표현한 장치이다.", "남루한 치장의 과장된 열거는 흥부가 동생으로서 형에게 효를 다하기 위해 최선을 다해 의관을 정제한 모습을 드러내며, 예를 중시하는 유교적 가치관의 실천 양상을 보여준다."]
            },
            {
                id: 7,
                question: "윗글에 나타난 '흥부전'의 문학적 특징 중, '판소리계 소설'의 특징을 두 가지 이상 찾아 구체적인 근거와 함께 서술하시오.",
                questionType: "개념 적용형",
                correctAnswer: "1. 운문체와 산문체의 혼합: '흥부 마음 인후하여 청산유수와 곤륜옥결이라'처럼 운율이 느껴지는 문장과 '이때 흥부는 어찌 맞았던지 일신이 노릇하여 돌아갈 마음 그지없건만'과 같이 서사를 진행하는 산문체가 섞여 있다. 2. 서술자의 개입: '놀부 놈의 거동 보소', '이년 또한 몹쓸 년이라'와 같이 서술자가 작품 밖에서 인물에 대한 평가를 직접적으로 드러내며 독자에게 말을 건네고 있다. 3. 장면의 극대화: 놀부가 흥부에게 주는 매를 '손 챈 스님의 비질하듯, 상좌 중이 법고 치듯'이라고 묘사하며 과장하고, 흥부 부부가 품을 파는 행위를 여러 가지 예시를 들어 길게 나열하는 등 특정 장면을 풍부하게 확장하여 보여주고 있다.",
                scoringCriteria: "① 판소리계 소설 특징 2가지 이상, ② 각 특징의 구체적 근거 제시",
                correctParts: [
                    "1. 운문체와 산문체의 혼합: '흥부 마음 인후하여 청산유수와 곤륜옥결이라'처럼 운율이 느껴지는 문장과 '이때 흥부는 어찌 맞았던지 일신이 노릇하여 돌아갈 마음 그지없건만'과 같이 서사를 진행하는 산문체가 섞여 있다.",
                    "2. 서술자의 개입: '놀부 놈의 거동 보소', '이년 또한 몹쓸 년이라'와 같이 서술자가 작품 밖에서 인물에 대한 평가를 직접적으로 드러내며 독자에게 말을 건네고 있다.",
                    "3. 장면의 극대화: 놀부가 흥부에게 주는 매를 '손 챈 스님의 비질하듯, 상좌 중이 법고 치듯'이라고 묘사하며 과장하고, 흥부 부부가 품을 파는 행위를 여러 가지 예시를 들어 길게 나열하는 등 특정 장면을 풍부하게 확장하여 보여주고 있다."
                ],
                distractors: ["판소리계 소설은 시간의 역순 배치와 다층적 서사 구조를 특징으로 하며, 흥부전도 놀부의 회상 장면을 통해 과거와 현재를 교차시키는 복잡한 시간 구성을 보여주고, 이를 통해 인물의 심리적 변화를 입체적으로 묘사한다.", "판소리계 소설은 객관적 시점과 심리적 사실주의를 결합한 근대 소설의 기법을 선취하며, 흥부전도 전지적 서술자가 인물의 내면을 깊이 있게 탐구하고, 의식의 흐름 기법을 활용하여 인물의 복잡한 심리를 표현한다.", "판소리계 소설의 주요 특징은 비극적 결말을 통한 사회 비판으로, 흥부전도 마지막에 흥부가 재물을 잃고 다시 가난해지는 결말을 통해 부의 무상함과 운명의 잔혹함을 강조하며 현실 비판적 메시지를 전달한다."]
            },
            {
                id: 8,
                question: "놀부가 멀쩡한 제비의 다리를 부러뜨리는 행위는, 흥부가 구렁이로부터 제비를 구해준 행위와 어떻게 대비되는지 서술하시오.",
                questionType: "비교형",
                correctAnswer: "흥부의 행위는 순수한 선의에서 비롯된 우연적인 행동이다. 그는 보상을 바라지 않고, 위험에 처한 약자를 구하려는 착한 마음에서 제비의 다리를 치료해 주었다. 반면, 놀부의 행위는 탐욕에서 비롯된 의도적이고 악의적인 행동이다. 그는 오직 재물을 얻기 위해 멀쩡한 생명체에 폭력을 가함으로써 비인간적인 면모를 드러낸다. 이처럼 두 인물의 행위는 동기와 과정에서 극명한 대비를 이룬다.",
                scoringCriteria: "① 흥부의 행위(순수한 선의, 우연적), ② 놀부의 행위(탐욕, 의도적), ③ 대비",
                correctParts: [
                    "흥부의 행위는 순수한 선의에서 비롯된 우연적인 행동이다. 그는 보상을 바라지 않고, 위험에 처한 약자를 구하려는 착한 마음에서 제비의 다리를 치료해 주었다.",
                    "반면, 놀부의 행위는 탐욕에서 비롯된 의도적이고 악의적인 행동이다. 그는 오직 재물을 얻기 위해 멀쩡한 생명체에 폭력을 가함으로써 비인간적인 면모를 드러낸다.",
                    "이처럼 두 인물의 행위는 동기와 과정에서 극명한 대비를 이룬다."
                ],
                distractors: ["두 행위는 모두 제비를 매개로 한 초월적 존재와의 소통 시도로 볼 수 있으며, 흥부는 무의식적 직관을 통해, 놀부는 의식적 계획을 통해 같은 목표를 추구했다는 점에서 차이가 있다.", "흥부와 놀부 모두 자신의 가문을 위해 행동했다는 공통점이 있으며, 흥부는 감성적 접근을, 놀부는 이성적 접근을 택했다는 방법론의 차이만 존재하므로, 도덕적 우열을 가리기 어렵다.", "두 행위는 인간과 자연의 관계 설정이라는 측면에서 동일한 성격을 지니며, 흥부는 자연 친화적 태도를, 놀부는 자연 정복적 태도를 보여주는데, 이는 가치 판단의 문제가 아니라 선택의 문제이다."]
            },
            {
                id: 9,
                question: "놀부와 흥부의 아내들은 각각 어떤 인물이며, 그들이 남편과 맺는 관계가 흥부전의 권선징악 주제를 강화하는 데 어떤 역할을 하는지 서술하시오.",
                questionType: "내용/해석형",
                correctAnswer: "흥부 아내는 현실적인 어려움을 극복하기 위해 흥부를 설득하는 생활력 강한 인물이다. 그녀는 남편의 순진함을 뒷받침하며 흥부가 힘을 얻게 하는 역할을 한다. 반면, 놀부 아내는 남편 못지않은 탐욕스러운 인물로, 밥 주걱으로 흥부의 뺨을 때리는 등 남편의 악행에 적극적으로 동조한다. 이처럼 두 아내들은 흥부와 놀부라는 인물의 성격을 각각 보완하고 강화하며, 선(흥부 부부)과 악(놀부 부부)의 대립을 명확히 함으로써 작품의 권선징악 주제를 더욱 효과적으로 드러낸다.",
                scoringCriteria: "① 두 아내의 성격, ② 남편과의 관계, ③ 권선징악 주제 강화 역할",
                correctParts: [
                    "흥부 아내는 현실적인 어려움을 극복하기 위해 흥부를 설득하는 생활력 강한 인물이다. 그녀는 남편의 순진함을 뒷받침하며 흥부가 힘을 얻게 하는 역할을 한다.",
                    "반면, 놀부 아내는 남편 못지않은 탐욕스러운 인물로, 밥 주걱으로 흥부의 뺨을 때리는 등 남편의 악행에 적극적으로 동조한다.",
                    "이처럼 두 아내들은 흥부와 놀부라는 인물의 성격을 각각 보완하고 강화하며, 선(흥부 부부)과 악(놀부 부부)의 대립을 명확히 함으로써 작품의 권선징악 주제를 더욱 효과적으로 드러낸다."
                ],
                distractors: ["두 아내는 모두 남편의 결정을 수동적으로 따르는 전통적 여성상을 보여주며, 흥부 아내는 내조형 여성의, 놀부 아내는 악처형 여성의 전형으로 당대 가부장제 하 여성의 제한된 역할을 반영한다.", "흥부 아내는 가정 경제를 책임지는 근대적 여성상을, 놀부 아내는 가문을 수호하는 전통적 여성상을 대표하며, 두 인물의 대비는 여성 역할의 시대적 변화와 전통과 근대의 충돌을 표현한다.", "두 아내의 성격 차이는 남편 인물을 보조하는 기능에 그치며, 작품의 핵심 갈등과 권선징악 주제는 흥부와 놀부라는 남성 주인공들 간의 대립 구도를 통해서 주로 구현되고 있다."]
            }
        ];

        // 5단계 초기화
        function initStage5() {
            console.log('initStage5() 호출됨');

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            // passage-container 숨기기 (5단계에서는 지문 보기 모달로만 표시)
            const passageContainer = document.getElementById('passage-container');
            if (passageContainer) {
                passageContainer.style.display = 'none';
            }

            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            currentStage = 5;

            // 문제 준비 및 카드 생성 (정답 3장 + 오답 3장 = 총 6장)
            stage5Data.questions = writingQuestions.map(q => {
                // 전체 카드 배열 생성 (정답 부분 + 오답)
                const allCards = [];

                // 정답 카드 3장 추가
                q.correctParts.forEach(part => {
                    allCards.push({
                        text: part,
                        isCorrect: true,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 오답 카드 3장 추가
                q.distractors.forEach(distractor => {
                    allCards.push({
                        text: distractor,
                        isCorrect: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                });

                // 카드 섞기
                for (let i = allCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
                }

                return {
                    ...q,
                    allCards: allCards,
                    correctParts: q.correctParts  // 정답 카드 3장 저장
                };
            });

            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            timeRemaining = stage5Data.timeRemaining;
            maxTime = stage5Data.timeRemaining;

            // 헤더 업데이트
            document.querySelector('.title').textContent = '흥부전';
            document.querySelector('.subtitle').textContent = '5단계: 서술형 문제';
            document.querySelector('.stage-indicator').textContent = 'Stage 5 / 5';
            document.querySelector('.question-counter').textContent = `문제: 1/${stage5Data.questions.length}`;

            startTimer();
            showStage5Question();
        }

        // 5단계 문제 표시
        function showStage5Question() {
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
                return;
            }

            const question = stage5Data.questions[stage5Data.currentQuestionIndex];
            const mainContent = document.getElementById('main-content');
            stage5Data.currentArrangement = [];

            // 문제 카운터 업데이트
            document.querySelector('.question-counter').textContent =
                `문제: ${stage5Data.currentQuestionIndex + 1}/${stage5Data.questions.length}`;

            // UI 생성
            mainContent.innerHTML = `
                <div class="stage5-container">
                    <div class="stage5-question-area">
                        <h2 class="question-number">문제 ${stage5Data.currentQuestionIndex + 1}</h2>
                        <div class="question-text">${question.question}</div>
                        <div class="required-cards-info" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; color: #1976d2; font-weight: 500;">
                            📝 필요한 카드 개수: ${question.correctParts.length}개
                        </div>
                        <button class="text-review-btn" onclick="showTextModal()" style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; display: inline-flex; align-items: center; gap: 8px;">
                            <span>📖</span> 지문 확인
                        </button>
                    </div>

                    <div class="answer-drop-zone" id="answer-drop-zone">
                        <div class="answer-slots" id="answer-slots"></div>
                        <div class="drop-hint">카드를 여기로 드래그하세요</div>
                    </div>

                    <div class="cards-pool" id="cards-pool">
                        ${question.allCards.map((card, index) => `
                            <div class="draggable-card"
                                 data-id="${card.id}"
                                 data-text="${card.text}"
                                 ${('ontouchstart' in window || navigator.maxTouchPoints > 0) ? '' : 'draggable="true"'}>
                                ${card.text}
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="submit-answer-btn" onclick="submitStage5Answer()">제출하기</button>
                        <button class="skip-question-btn" onclick="skipStage5Question()" style="padding: 4px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                            다음 문제로
                        </button>
                    </div>
                </div>
            `;

            // 스타일 추가
            if (!document.querySelector('#stage5-styles')) {
                const styles = document.createElement('style');
                styles.id = 'stage5-styles';
                styles.textContent = `
                    .stage5-container {
                        padding: 20px;
                        max-width: 1000px;
                        margin: 0 auto;
                    }

                    .stage5-question-area {
                        background: white;
                        padding: 25px;
                        border-radius: 12px;
                        margin-bottom: 25px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    }

                    .question-number {
                        color: #3498db;
                        font-size: 20px;
                        margin-bottom: 15px;
                    }

                    .question-text {
                        font-size: 22px;
                        line-height: 1.6;
                        color: #2c3e50;
                    }

                    .answer-drop-zone {
                        min-height: 150px;
                        background: #f8f9fa;
                        border: 3px dashed #dee2e6;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 25px 0;
                        position: relative;
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .answer-drop-zone.drag-over {
                        border-color: #3498db;
                        background: #e3f2fd;
                        transform: scale(1.02);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
                    }

                    .answer-slots {
                        min-height: 60px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }

                    .answer-slots:not(:empty) + .drop-hint {
                        display: none;
                    }

                    .drop-hint {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: #95a5a6;
                        font-size: 18px;
                        pointer-events: none;
                    }

                    .cards-pool {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        padding: 20px;
                        background: white;
                        border-radius: 12px;
                        min-height: 150px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                        transition: all 0.3s ease, transform 0.2s ease;
                    }

                    .cards-pool.drag-over {
                        transform: scale(1.01);
                        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
                        background: #f8f9fa;
                    }

                    .draggable-card {
                        display: inline-block;
                        padding: 12px 20px;
                        background: white;
                        border: 2px solid #e9ecef;
                        border-radius: 25px;
                        cursor: move;
                        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                                    opacity 0.25s ease,
                                    background-color 0.25s ease,
                                    border-color 0.25s ease,
                                    box-shadow 0.25s ease;
                        user-select: none;
                        font-size: 16px;
                        color: #2c3e50;
                        position: relative;
                        touch-action: none; /* 터치 드래그 방해 방지 */
                        will-change: transform;
                    }

                    .draggable-card.shifting {
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .draggable-card:hover:not(.dragging) {
                        border-color: #3498db;
                        transform: translateY(-3px) scale(1.02);
                        box-shadow: 0 6px 12px rgba(52, 152, 219, 0.2);
                    }

                    .draggable-card:active:not(.dragging) {
                        transform: scale(0.98);
                    }

                    .draggable-card.dragging {
                        opacity: 0.7;
                        transform: scale(1.08) rotate(2deg);
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
                        transition: none;
                        border-color: #3498db;
                        background: #e3f2fd;
                    }

                    .draggable-card.placeholder {
                        opacity: 0.25;
                        border: 2px dashed #3498db;
                        background: #e3f2fd;
                        transition: all 0.2s ease;
                    }

                    /* 카드 위치 교체 시각화 효과 */
                    .draggable-card.card-placeholder {
                        position: relative;
                        transition: transform 0.25s ease, margin 0.25s ease;
                    }

                    .draggable-card.card-placeholder::before {
                        content: '';
                        position: absolute;
                        left: -10px;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 4px;
                        height: 70%;
                        background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
                        border-radius: 4px;
                        animation: placeholder-pulse 0.6s ease-in-out infinite;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
                    }

                    @keyframes placeholder-pulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: translateY(-50%) scaleY(0.8);
                            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
                        }
                        50% {
                            opacity: 1;
                            transform: translateY(-50%) scaleY(1);
                            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
                        }
                    }

                    /* placeholder 카드 애니메이션 */
                    @keyframes placeholderPulse {
                        0%, 100% {
                            opacity: 0.5;
                            transform: scale(0.98);
                        }
                        50% {
                            opacity: 0.7;
                            transform: scale(1.02);
                        }
                    }

                    /* 드래그 중인 카드가 다른 카드 위로 올 때 공간 확보 애니메이션 */
                    .draggable-card.card-placeholder:not(.dragging) {
                        transform: translateX(12px);
                        margin-left: 8px;
                    }

                    .draggable-card.in-answer {
                        background: #3498db;
                        color: white;
                        border-color: #2980b9;
                    }

                    .draggable-card.hidden {
                        display: none;
                    }

                    .draggable-card.correct-animation {
                        animation: correctPulse 0.6s;
                        background: #27ae60 !important;
                        color: white;
                        border-color: #229954 !important;
                    }

                    .draggable-card.wrong-animation {
                        animation: wrongShake 0.6s;
                        background: #e74c3c !important;
                        color: white;
                        border-color: #c0392b !important;
                    }

                    @keyframes correctPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }

                    @keyframes wrongShake {
                        0%, 100% { transform: translateX(0); }
                        25% { transform: translateX(-10px); }
                        75% { transform: translateX(10px); }
                    }

                    .submit-answer-btn {
                        display: block;
                        margin: 30px auto;
                        padding: 15px 40px;
                        font-size: 18px;
                        font-weight: bold;
                        background: #27ae60;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                    }

                    .submit-answer-btn:hover {
                        background: #229954;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
                    }

                    .submit-answer-btn:disabled {
                        background: #95a5a6;
                        cursor: not-allowed;
                        transform: none;
                        box-shadow: none;
                    }

                    @media (max-width: 768px) {
                        /* Stage 5 모바일 최적화 */
                        .stage5-container {
                            padding: 10px;  /* 패딩 더 줄임 */
                        }

                        .stage5-question-area {
                            padding: 15px;  /* 질문 영역 패딩 축소 */
                        }

                        .question-number {
                            font-size: 16px;  /* 문제 번호 크기 축소 */
                        }

                        .question-text {
                            font-size: 14px;  /* 질문 텍스트 더 작게 */
                            line-height: 1.4;
                        }

                        .required-cards-info {
                            font-size: 13px !important;  /* 필요 카드 개수 표시 축소 */
                            padding: 8px !important;
                        }

                        .draggable-card {
                            padding: 8px 12px;  /* 카드 패딩 축소 */
                            font-size: 12px;  /* 카드 텍스트 더 작게 */
                            min-height: 35px;  /* 최소 높이 축소 */
                        }

                        .cards-pool {
                            gap: 6px;  /* 카드 간격 더 줄임 */
                            padding: 12px;  /* 카드 풀 패딩 축소 */
                            padding: 15px;
                        }
                    }

                    @media (max-width: 480px) {
                        .draggable-card {
                            padding: 8px 12px;
                            font-size: 13px;
                        }

                        .submit-answer-btn {
                            width: 100%;
                            padding: 12px 20px;
                            font-size: 16px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정 (러셀 방식)
        function setupDragAndDrop() {
            const answerSlots = document.getElementById('answer-slots');
            const cardsPool = document.getElementById('cards-pool');
            const cards = document.querySelectorAll('.draggable-card');

            let draggedCard = null;
            let draggedClone = null;
            let placeholder = null;

            console.log('드래그 설정 시작 (러셀 방식):', { cards: cards.length });

            cards.forEach((card) => {
                card.draggable = false; // HTML5 드래그 비활성화

                // 마우스 이벤트
                card.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 왼쪽 클릭만
                        startDrag(e, card);
                    }
                });

                // 터치 이벤트
                card.addEventListener('touchstart', (e) => {
                    startDrag(e, card);
                }, { passive: false });
            });

            function startDrag(e, card) {
                e.preventDefault();
                draggedCard = card;

                // 카드의 원래 크기와 위치 가져오기
                const rect = card.getBoundingClientRect();

                // 플레이스홀더 생성 (원래 자리 표시) - 시각화 개선
                placeholder = document.createElement('div');
                placeholder.className = 'draggable-card placeholder';
                placeholder.style.width = rect.width + 'px';
                placeholder.style.height = rect.height + 'px';
                placeholder.style.opacity = '0.5';
                placeholder.style.border = '3px dashed #3498db';
                placeholder.style.background = 'linear-gradient(135deg, #e3f2fd 25%, transparent 25%, transparent 50%, #e3f2fd 50%, #e3f2fd 75%, transparent 75%, transparent)';
                placeholder.style.backgroundSize = '20px 20px';
                placeholder.style.animation = 'placeholderPulse 1.5s ease-in-out infinite';
                placeholder.style.boxShadow = '0 4px 12px rgba(52, 152, 219, 0.3)';
                placeholder.style.borderRadius = '25px';

                // 클론 생성 (커서를 따라다닐 요소)
                draggedClone = card.cloneNode(true);
                draggedClone.classList.add('dragging');
                draggedClone.style.position = 'fixed';
                draggedClone.style.width = rect.width + 'px';
                draggedClone.style.pointerEvents = 'none';
                draggedClone.style.zIndex = '1000';
                draggedClone.style.opacity = '0.8';
                draggedClone.style.transform = 'scale(1.08) rotate(2deg)';
                draggedClone.style.boxShadow = '0 12px 24px rgba(0,0,0,0.25)';
                document.body.appendChild(draggedClone);

                // 원본 카드를 플레이스홀더로 교체
                card.parentNode.insertBefore(placeholder, card);
                card.style.display = 'none';

                // 클릭 위치 오프셋 계산
                const offsetX = e.clientX ? e.clientX - rect.left : e.touches[0].clientX - rect.left;
                const offsetY = e.clientY ? e.clientY - rect.top : e.touches[0].clientY - rect.top;

                function moveCard(clientX, clientY) {
                    // 클론을 커서 위치로 이동
                    draggedClone.style.left = (clientX - offsetX) + 'px';
                    draggedClone.style.top = (clientY - offsetY) + 'px';

                    // 드롭 위치 계산
                    draggedClone.style.display = 'none'; // 임시로 숨김
                    const elemBelow = document.elementFromPoint(clientX, clientY);
                    draggedClone.style.display = ''; // 다시 표시

                    // 드롭 가능한 영역 찾기
                    const dropZone = elemBelow?.closest('#answer-drop-zone');
                    const poolZone = elemBelow?.closest('#cards-pool');

                    // 원래 카드가 어디에 있는지 확인
                    const isFromPool = draggedCard.parentElement === cardsPool || placeholder.parentElement === cardsPool;

                    if (dropZone || poolZone) {
                        const targetContainer = dropZone ? answerSlots : cardsPool;
                        const targetCard = elemBelow?.closest('.draggable-card:not(.dragging)');

                        // 대기열에서 정답란으로 이동하는 경우: 무조건 맨 뒤에 추가
                        if (dropZone && isFromPool) {
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                        // 정답란 내부에서 이동하거나 대기열 내에서 이동하는 경우: 정확한 위치에 삽입
                        else if (targetCard && targetCard !== draggedCard) {
                            const rect = targetCard.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (clientX < midpoint) {
                                // 왼쪽에 삽입
                                targetCard.parentNode.insertBefore(placeholder, targetCard);
                                targetCard.parentNode.insertBefore(draggedCard, placeholder);
                            } else {
                                // 오른쪽에 삽입
                                if (targetCard.nextSibling) {
                                    targetCard.parentNode.insertBefore(placeholder, targetCard.nextSibling);
                                    targetCard.parentNode.insertBefore(draggedCard, placeholder);
                                } else {
                                    targetCard.parentNode.appendChild(placeholder);
                                    targetCard.parentNode.appendChild(draggedCard);
                                }
                            }
                        } else if (targetContainer && !targetContainer.querySelector('.draggable-card:not([style*="display: none"])')) {
                            // 빈 컨테이너에 추가
                            targetContainer.appendChild(placeholder);
                            targetContainer.appendChild(draggedCard);
                        }
                    }
                }

                function onMove(e) {
                    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    moveCard(clientX, clientY);
                }

                function onEnd(e) {
                    // 클론 제거
                    if (draggedClone) {
                        draggedClone.remove();
                        draggedClone = null;
                    }

                    // 플레이스홀더를 원본 카드로 교체
                    if (placeholder && placeholder.parentNode) {
                        const wasInAnswer = placeholder.parentNode === answerSlots;
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        placeholder = null;

                        // in-answer 클래스 업데이트
                        if (wasInAnswer) {
                            draggedCard.classList.add('in-answer');
                        } else {
                            draggedCard.classList.remove('in-answer');
                        }
                    }

                    // 원본 카드 다시 표시
                    draggedCard.style.display = '';
                    draggedCard = null;

                    // 배치 데이터 업데이트
                    updateArrangementData();

                    // 이벤트 리스너 제거
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                }

                // 초기 위치 설정
                const initialX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                const initialY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                moveCard(initialX, initialY);

                // 이벤트 리스너 추가
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                } else {
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }
            }
        }

        // 답안 제출
        function submitStage5Answer() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 답안 영역의 카드들을 순서대로 가져오기
            const answerSlots = document.getElementById('answer-slots');
            const answerCards = Array.from(answerSlots.children);

            // 사용자 답안 생성
            const userAnswer = answerCards
                .map(card => card.dataset.text)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            // 정답 부분들로 정답 문장 구성
            const correctParts = question.correctParts;

            // 각 카드가 정답인지 확인
            const cardResults = answerCards.map(card => {
                const cardText = card.dataset.text;
                return correctParts.includes(cardText);
            });

            // 전체 정답 여부 확인 (모든 정답 카드가 포함되고 순서가 맞아야 함)
            const isCorrect = correctParts.every(part =>
                userAnswer.includes(part)
            ) && answerCards.length === correctParts.length;

            // 제출 버튼 비활성화
            const submitBtn = document.querySelector('.submit-answer-btn');
            submitBtn.disabled = true;

            // 개별 카드 애니메이션
            answerCards.forEach((card, index) => {
                setTimeout(() => {
                    if (cardResults[index]) {
                        card.classList.add('correct-card-animation');
                        card.style.backgroundColor = '#d4edda';
                        card.style.borderColor = '#28a745';
                    } else {
                        card.classList.add('wrong-card-animation');
                        card.style.backgroundColor = '#f8d7da';
                        card.style.borderColor = '#dc3545';
                    }
                }, index * 100);
            });

            if (isCorrect) {
                // 정답 처리
                stage5Data.correctAnswers++;
                addTime(15);

                // 다음 문제로
                setTimeout(() => {
                    stage5Data.currentQuestionIndex++;
                    showStage5Question();
                }, 2000);
            } else {
                // 오답 처리
                stage5Data.wrongAnswers++;
                subtractTime(20);

                // 다시 시도할 수 있도록
                setTimeout(() => {
                    answerCards.forEach(card => {
                        card.classList.remove('wrong-card-animation');
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    });
                    submitBtn.disabled = false;
                }, 2000);
            }
        }

        // 배치 데이터 업데이트
        function updateArrangementData() {
            const answerSlots = document.getElementById('answer-slots');
            const cards = answerSlots.querySelectorAll('.draggable-card');

            stage5Data.currentArrangement = Array.from(cards).map(card => ({
                id: card.dataset.id,
                text: card.dataset.text
            }));
        }

        // 문제 넘기기 함수
        function skipStage5Question() {
            const question = stage5Data.questions[stage5Data.currentQuestionIndex];

            // 넘긴 문제도 오답으로 처리
            stage5Data.wrongAnswers++;

            // 현재 문제를 넘긴 문제 목록에 추가
            stage5Data.skippedQuestions.push({
                questionNumber: stage5Data.currentQuestionIndex + 1,
                question: question.question,
                correctAnswer: question.correctAnswer,
                userAnswer: '(문제를 넘김)'
            });

            // 다음 문제로 이동
            stage5Data.currentQuestionIndex++;

            // 모든 문제를 완료했는지 확인
            if (stage5Data.currentQuestionIndex >= stage5Data.questions.length) {
                completeStage5();
            } else {
                showStage5Question();
            }
        }

        // 5단계 완료
        function completeStage5() {
            clearInterval(timerInterval);

            // 현재 단계를 5로 명시적으로 설정
            currentStage = 5;

            const endTime = Date.now();
            const elapsedTime = Math.floor((endTime - stage5Data.startTime) / 1000);

            // 진행률과 정답률 계산
            const totalAnswered = stage5Data.correctAnswers + stage5Data.wrongAnswers;
            const progress = Math.round((stage5Data.correctAnswers / stage5Data.questions.length) * 100);
            const accuracy = totalAnswered > 0 ? Math.round((stage5Data.correctAnswers / totalAnswered) * 100) : 0;

            // 결과 화면 표시
            document.getElementById('main-content').style.display = 'none';
            const resultScreen = document.getElementById('result-screen');
            resultScreen.classList.add('active');

            // 제목 업데이트
            resultScreen.querySelector('.result-title').textContent = '5단계 학습 완료!';

            // 통계 업데이트
            document.getElementById('progress-stat').textContent = progress + '%';
            document.getElementById('accuracy-stat').textContent = accuracy + '%';
            document.getElementById('correct-stat').textContent = stage5Data.correctAnswers;
            document.getElementById('wrong-stat').textContent = stage5Data.wrongAnswers;
            document.getElementById('time-stat').textContent = formatTime(elapsedTime);

            // 결과 저장
            const score = (accuracy / 100) * 10; // 10점 만점으로 환산
            stageResults.stage5 = {
                correct: stage5Data.correctAnswers,
                wrong: stage5Data.wrongAnswers,
                score: score,
                elapsedTime: elapsedTime,
                wrongQuestions: stage5Data.skippedQuestions  // Stage5는 넘긴 문제를 틀린 문제로 저장
            };

            // 부모 창으로 데이터 전송
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'stage-complete',
                    stage: 5,
                    stageName: '서술형 문제',
                    accuracy: accuracy,
                    correctAnswers: stage5Data.correctAnswers,
                    wrongAnswers: stage5Data.wrongAnswers,
                    skippedQuestions: stage5Data.skippedQuestions,  // 넘긴 문제 데이터 포함
                    totalQuestions: stage5Data.questions.length,
                    elapsedTime: elapsedTime,
                    timeRemaining: timeRemaining
                }, '*');
            }

            // 버튼 업데이트
            const resultButtons = resultScreen.querySelector('.result-buttons');
            let buttonsHTML = '<button class="result-button secondary" onclick="restartStage5()">다시 학습하기</button>';

            // 넘긴 문제가 있으면 버튼 추가 (넘긴 문제도 틀린 문제로 표시)
            if (stage5Data.skippedQuestions.length > 0) {
                buttonsHTML += `<button class="result-button warning" onclick="showSkippedQuestions()" style="background: #dc3545; color: white;">틀린 문제 보기 (${stage5Data.skippedQuestions.length}문제)</button>`;
            }

            buttonsHTML += '<button class="result-button primary" onclick="showFinalResults()">전체 결과 보기</button>';
            resultButtons.innerHTML = buttonsHTML;
        }

        // 틀린 문제 보기 (넘긴 문제 포함)
        function showSkippedQuestions() {
            // 모달이 없으면 생성
            if (!document.getElementById('skipped-questions-modal')) {
                const modalHTML = `
                    <div id="skipped-questions-modal" class="modal-overlay">
                        <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                            <div class="modal-header">
                                <h3>틀린 문제 목록</h3>
                                <button class="close-modal-btn" onclick="closeSkippedQuestionsModal()">✕</button>
                            </div>
                            <div class="modal-body" id="skipped-questions-content"></div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            // 틀린 문제 내용 표시
            const content = document.getElementById('skipped-questions-content');
            content.innerHTML = stage5Data.skippedQuestions.map((item, index) => `
                <div class="skipped-question-item" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin-bottom: 10px;">문제 ${item.questionNumber}</h4>
                    <p style="font-size: 18px; margin-bottom: 15px;"><strong>문제:</strong> ${item.question}</p>
                    <p style="color: #28a745;"><strong>정답:</strong> ${item.correctAnswer}</p>
                    <p style="color: #6c757d; font-style: italic;">상태: ${item.userAnswer}</p>
                </div>
            `).join('');

            document.getElementById('skipped-questions-modal').classList.add('active');
        }

        // 넘긴 문제 모달 닫기
        function closeSkippedQuestionsModal() {
            document.getElementById('skipped-questions-modal').classList.remove('active');
        }

        // 5단계 다시 시작
        function restartStage5() {
            // 변수 초기화
            stage5Data.currentQuestionIndex = 0;
            stage5Data.correctAnswers = 0;
            stage5Data.wrongAnswers = 0;
            stage5Data.skippedQuestions = [];  // 넘긴 문제도 초기화
            stage5Data.currentArrangement = [];
            stage5Data.startTime = Date.now();
            stage5Data.timeRemaining = 600;  // 10분으로 변경

            // 결과 화면 숨기기
            document.getElementById('result-screen').classList.remove('active');
            document.getElementById('main-content').style.display = 'block';

            initStage5();
        }

        // 전체 결과 표시
        function showFinalResults() {
            // 기존 타이머 정리
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // 결과 화면과 메인 컨텐츠 숨기기
            document.getElementById('result-screen').classList.remove('active');

            // 전체 결과 계산
            const totalCorrect = Object.values(stageResults).reduce((sum, s) => sum + s.correct, 0);
            const totalWrong = Object.values(stageResults).reduce((sum, s) => sum + s.wrong, 0);
            const overallAccuracy = (totalCorrect + totalWrong) > 0 ?
                                   Math.round((totalCorrect / (totalCorrect + totalWrong)) * 100) : 0;
            const totalScore = Object.values(stageResults).reduce((sum, s) => sum + s.score, 0);
            const totalElapsedTime = (Date.now() - globalStartTime) / 1000;

            // 스테이지명 맵핑
            const stageNames = {
                stage1: '1단계: 딥리서치',
                stage2: '2단계: 어휘 학습',
                stage3: '3단계: 문장 독해',
                stage4: '4단계: OX퀴즈',
                stage5: '5단계: 서술형 문제'
            };

            // HTML 생성
            let html = `
                <div style="max-width: 1000px; margin: 0 auto; padding: 40px 20px;">
                    <div style="text-align: center; margin-bottom: 40px;">
                        <h1 style="font-size: 36px; color: #2c3e50; margin-bottom: 10px;">🎉 학습 완료!</h1>
                        <p style="font-size: 18px; color: #7f8c8d;">모든 학습 단계를 완료했습니다.</p>
                    </div>

                    <!-- 전체 학습 결과 -->
                    <div style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #3498db;">
                        <h2 style="margin-bottom: 25px; font-size: 24px; color: #2c3e50;">📊 전체 학습 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총점</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${totalScore.toFixed(1)}점</div>
                                <div style="font-size: 12px; margin-top: 5px; color: #7f8c8d;">/ 50.0점</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #3498db;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">전체 정답률</div>
                                <div style="font-size: 32px; font-weight: bold; color: #2c3e50;">${overallAccuracy}%</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #22c55e;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">정답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #16a34a;">${totalCorrect}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #ef4444;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">오답 수</div>
                                <div style="font-size: 32px; font-weight: bold; color: #dc2626;">${totalWrong}개</div>
                            </div>
                            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #eab308;">
                                <div style="font-size: 14px; margin-bottom: 10px; color: #2c3e50; font-weight: 600;">총 소요 시간</div>
                                <div style="font-size: 28px; font-weight: bold; color: #2c3e50;">${formatTime(Math.floor(totalElapsedTime))}</div>
                            </div>
                        </div>
                    </div>

                    <!-- 단계별 결과 -->
                    <h2 style="margin-bottom: 25px; color: #2c3e50; font-size: 24px;">📈 단계별 학습 결과</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 40px;">
            `;

            // 각 단계별 결과 카드
            ['stage1', 'stage2', 'stage3', 'stage4', 'stage5'].forEach(stageKey => {
                const result = stageResults[stageKey];
                const stageAccuracy = (result.correct + result.wrong) > 0 ?
                    Math.round((result.correct / (result.correct + result.wrong)) * 100) : 0;

                html += `
                    <div style="background: white; border: 2px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #3498db; margin-bottom: 15px; font-size: 18px;">${stageNames[stageKey]}</h3>
                        <div style="line-height: 1.8; font-size: 14px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답률:</span>
                                <strong style="color: #27ae60;">${stageAccuracy}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">정답:</span>
                                <strong>${result.correct}개</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">오답:</span>
                                <strong style="color: #e74c3c;">${result.wrong}회</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">점수:</span>
                                <strong style="color: #3498db;">${result.score.toFixed(1)}점</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                                <span style="color: #7f8c8d;">소요 시간:</span>
                                <strong>${formatTime(result.elapsedTime)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `
        </div>

        <!-- 틀린 문제 상세 정보 -->
        <h2 style="margin-top: 50px; margin-bottom: 25px; color: #2c3e50; font-size: 24px; font-weight: 600;">❌ 틀린 문제 상세</h2>
`;

            // Stage 4와 Stage 5의 틀린 문제 표시
            let hasWrongQuestions = false;

            // Stage 4 틀린 문제
            if (stageResults.stage4.wrongQuestions && stageResults.stage4.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin-bottom: 20px; font-size: 20px;">📝 Stage 4 - 틀린 문제</h3>
`;
                stageResults.stage4.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // Stage 5 틀린 문제
            if (stageResults.stage5.wrongQuestions && stageResults.stage5.wrongQuestions.length > 0) {
                hasWrongQuestions = true;
                html += `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #721c24; margin-bottom: 20px; font-size: 20px;">🔤 Stage 5 - 틀린 문제</h3>
`;
                stageResults.stage5.wrongQuestions.forEach((item, idx) => {
                    html += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <p style="font-weight: 600; color: #495057; margin-bottom: 12px;">문제 ${idx + 1}: ${item.question}</p>
                <p style="color: #dc3545; margin-bottom: 8px;">❌ 당신의 답: ${item.userAnswer}</p>
                <p style="color: #28a745;">✅ 정답: ${item.correctAnswer}</p>
            </div>
`;
                });
                html += `
        </div>
`;
            }

            // 틀린 문제가 없는 경우
            if (!hasWrongQuestions) {
                html += `
        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 12px; padding: 25px; text-align: center;">
            <p style="color: #155724; font-size: 18px; font-weight: 600;">🎉 완벽합니다! 모든 문제를 맞추셨습니다!</p>
        </div>
`;
            }

            html += `
        <!-- 액션 버튼 -->
        <div style="text-align: center; margin-top: 50px; padding-bottom: 50px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="saveFinalResultsAsImage()" style="
                background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 211, 153, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 211, 153, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 211, 153, 0.4)';">
                📷 결과 이미지 저장
            </button>
            <button onclick="location.reload()" style="
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 18px 50px;
                font-size: 18px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.6)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)';">
                🔄 처음부터 다시하기
            </button>
        </div>
    </div>
`;

            // HTML 설정 및 표시
            document.getElementById('main-content').innerHTML = html;
            document.getElementById('main-content').style.display = 'block';

            // 부모 프로그램에 최종 결과 전송
            sendFinalDataToParent();
            // 학습 완료 버튼 추가
            if (typeof addCompleteLearningButton === 'function') {
                setTimeout(() => addCompleteLearningButton(), 500);
            }
        }

        // 부모 프로그램으로 최종 데이터 전송
        function sendFinalDataToParent() {
            const totalElapsedTime = Date.now() - globalStartTime;

            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'korean-farm-v2',
                    event: 'all-stages-complete',
                    data: {
                        totalStages: 5,
                        totalCorrect: totalCorrect,
                        totalWrong: totalWrong,
                        totalAccuracy: totalAccuracy,
                        totalScore: totalScore,
                        totalElapsedTime: totalElapsedTime,
                        stagesDetail: stageResults,
                        timestamp: Date.now()
                    }
                }, '*');
            }
        }

        // 전체 다시 시작 (중복 함수 제거)
        function restartAll() {
            // 모든 스테이지 결과 초기화
            for (let key in stageResults) {
                stageResults[key] = { correct: 0, wrong: 0, score: 0, elapsedTime: 0, wrongQuestions: [] };
            }
            globalStartTime = null;
            location.reload();
        }

        // 최종 결과 페이지 이미지 저장
        function saveFinalResultsAsImage() {
            if (typeof htmlToImage === 'undefined') {
                alert('이미지 라이브러리가 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const mainContent = document.getElementById('main-content');

            // 저장 버튼들 임시 숨김
            const buttons = mainContent.querySelectorAll('button');
            const buttonStates = Array.from(buttons).map(btn => btn.style.display);
            buttons.forEach(btn => btn.style.display = 'none');

            // 약간의 딜레이 후 캡처
            setTimeout(() => {
                htmlToImage.toBlob(mainContent, {
                    backgroundColor: '#f5f7fa',
                    pixelRatio: 2,
                    cacheBust: true
                }).then(blob => {
                    // 버튼 다시 표시
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);

                    // 이미지 다운로드
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `흥부전_워크북_최종결과_${timestamp}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }).catch(err => {
                    buttons.forEach((btn, idx) => btn.style.display = buttonStates[idx]);
                    console.error('이미지 저장 실패:', err);
                    alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
                });
            }, 100);
        }

        // 초기화 실행
        window.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- 학습 완료 시스템 -->
    <script src="../js/config.js"></script>
    <script src="../js/learning-complete.js"></script>
</body>
</html>